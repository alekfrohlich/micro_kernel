diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..6ee3754
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,9 @@
+{
+    "files.associations": {
+        "makeinc": "makefile",
+        "makedefs": "makefile",
+        "*.cfg": "plaintext",
+        "atomic": "cpp",
+        "vector": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/app/hello/hello.cc b/app/hello_usr/hello_usr.cc
similarity index 88%
rename from app/hello/hello.cc
rename to app/hello_usr/hello_usr.cc
index 40c7c05..2246846 100644
--- a/app/hello/hello.cc
+++ b/app/hello_usr/hello_usr.cc
@@ -1,4 +1,5 @@
 #include <utility/ostream.h>
+#include <time.h>
 
 using namespace EPOS;
 
@@ -7,6 +8,5 @@ OStream cout;
 int main()
 {
     cout << "Hello world!" << endl;
-
     return 0;
 }
diff --git a/app/hello_usr/hello_usr_traits.h b/app/hello_usr/hello_usr_traits.h
new file mode 100644
index 0000000..0c80155
--- /dev/null
+++ b/app/hello_usr/hello_usr_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/hello/makefile b/app/hello_usr/makefile
similarity index 100%
rename from app/hello/makefile
rename to app/hello_usr/makefile
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 6661b46..0c80155 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -9,19 +9,19 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = BUILTIN;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
     static const bool monitored = false;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool hysterically_debugged = true;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
@@ -106,7 +106,7 @@ template<> struct Traits<System>: public Traits<Build>
     static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
     static const bool multitask = (mode != Traits<Build>::LIBRARY);
     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
-    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 6661b46..bdd7794 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -9,7 +9,7 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = BUILTIN;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/test_rm1/makefile b/app/test_rm1/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_rm1/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_rm1/test_rm1.cc b/app/test_rm1/test_rm1.cc
new file mode 100644
index 0000000..09b22e0
--- /dev/null
+++ b/app/test_rm1/test_rm1.cc
@@ -0,0 +1,73 @@
+#include <system.h>
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+typedef unsigned int Tick;
+
+int function_periodic_a(){
+    // CPU::int_enable_for_test(); // ints were disabled
+    for(int i=0;i<5;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin a tick: " << begin << endl;
+        while(tot <= 100){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ a is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end a tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+int function_periodic_b(){
+    // CPU::int_enable_for_test();
+    for(int i=0;i<5;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin b tick: " << begin << endl;
+        while(tot <= 1000){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ b is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end b tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+
+int main()
+{
+    cout << "\n\n\n\n============ Hello world!" << endl;
+
+
+    Periodic_Thread * a = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 500, 5) , &function_periodic_a);
+    Periodic_Thread * b = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 1600, 5) , &function_periodic_b);
+
+    a->join();
+    b->join();
+    cout << "============ Goodbye world!\n\n\n\n" << endl;
+
+    return 0;
+}
\ No newline at end of file
diff --git a/app/test_rm1/test_rm1_traits.h b/app/test_rm1/test_rm1_traits.h
new file mode 100644
index 0000000..86e9470
--- /dev/null
+++ b/app/test_rm1/test_rm1_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/app/test_rm2/RM-example.png b/app/test_rm2/RM-example.png
new file mode 100644
index 0000000..9e55b1f
Binary files /dev/null and b/app/test_rm2/RM-example.png differ
diff --git a/app/test_rm2/makefile b/app/test_rm2/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_rm2/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_rm2/test_rm2.cc b/app/test_rm2/test_rm2.cc
new file mode 100644
index 0000000..6f8f368
--- /dev/null
+++ b/app/test_rm2/test_rm2.cc
@@ -0,0 +1,97 @@
+// A reference to this test is in this directory (RM-example.png). Here, the values are multiplied by 5.
+
+#include <system.h>
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+typedef unsigned int Tick;
+
+int function_periodic_a(){
+    for(int i=0;i<4;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin a tick: " << begin << endl;
+        while(tot <= 100){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();    
+                cout << "============ a is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end a tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+int function_periodic_b(){
+    for(int i=0;i<3;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin b tick: " << begin << endl;
+        while(tot <= 200){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ b is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end b tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+int function_periodic_c(){
+    for(int i=0;i<2 ;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin c tick: " << begin << endl;
+        while(tot <= 500){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ c is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end c tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+
+int main()
+{
+    cout << "\n\n\n\n============ Hello world!" << endl;
+
+
+    Periodic_Thread * a = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 500,  4) , &function_periodic_a);
+    Periodic_Thread * b = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 750,  3) , &function_periodic_b);
+    Periodic_Thread * c = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 1750, 2) , &function_periodic_c);
+
+    a->join();
+    b->join();
+    c->join();
+    cout << "============ Goodbye world!\n\n\n\n" << endl;
+
+    return 0;
+}
\ No newline at end of file
diff --git a/app/test_rm2/test_rm2_traits.h b/app/test_rm2/test_rm2_traits.h
new file mode 100644
index 0000000..b9053c9
--- /dev/null
+++ b/app/test_rm2/test_rm2_traits.h
@@ -0,0 +1,156 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    // typedef RR Criterion;
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/app/test_worst_fit/makefile b/app/test_worst_fit/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_worst_fit/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_worst_fit/test_worst_fit.cc b/app/test_worst_fit/test_worst_fit.cc
new file mode 100644
index 0000000..4fd6bb2
--- /dev/null
+++ b/app/test_worst_fit/test_worst_fit.cc
@@ -0,0 +1,34 @@
+// We show the Worst Fit behavior by allocating 3 blocks (one large, two small), and then
+// freeing the outer blocks (b1, b3). This will fragment the Heap into two blocks: b1, b3.
+// Then, we alloc something in b3, which is the biggest block (but last in the underlying Grouping_List).
+// 
+// Traits<Application>::HEAP_SIZE = 16KB
+// For comparision purposes, we print how First Fit would have handled each allocation.
+
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+char * alloc(int bytes) {
+    return new char[bytes];
+}
+
+int main()
+{
+    // Terminal output is important after the following line
+    cout << "Testing Worst-Fit..." << endl;
+    CPU::int_disable();
+
+    char * b1 = alloc(15*1024);
+    char * b2 = alloc(128);
+    char * b3 = alloc(128);
+    
+    free(b3);
+    free(b1);
+
+    char * a1 = alloc(16);
+
+    return 0;
+}
diff --git a/app/test_worst_fit/test_worst_fit_traits.h b/app/test_worst_fit/test_worst_fit_traits.h
new file mode 100644
index 0000000..0fad2b3
--- /dev/null
+++ b/app/test_worst_fit/test_worst_fit_traits.h
@@ -0,0 +1,156 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = 16*1024;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    // typedef RR Criterion;
+    typedef FCFS Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/docs/build.txt b/docs/build.txt
new file mode 100644
index 0000000..f8445fd
--- /dev/null
+++ b/docs/build.txt
@@ -0,0 +1,180 @@
+We did not specify target: execute all; APPLICATION was defined => execute all1
+all1: etc tools src app img
+
+ETC
+=======
+etc: config eposcfg eposcc.conf eposmkbi.conf
+config: config.h (config always execute?)
+    defines SMOD, ARCH, MACH, etc. in config.h
+eposcfg: FORCE
+    removes eposcfg executable
+eposcc.conf and eposmkbi.conf: FORCE
+    use eposcfg to build .conf files (which I suppose are used by tools?)
+=======
+
+TOOLS
+=======
+Mostly, just compile them
+=======
+
+SRC
+=======
+src: utility architecture machine api setup boot system init
+
+    UTIL
+    =======
+    just compiles utility/ and groups it inside lib/libutil_sifive_e.a
+    =======
+
+    ARCH
+    =======
+    forwards to rv32,
+    
+        RV32
+        =======
+        compiles crts and installs them under lib/crtxxx_sifive_e.o, then compiles the cpu/mmu/tsc _inits and their corresponding
+        _inits and places them under libarch and libinit.
+        =======
+    =======
+
+    MACH
+    =======
+    Does common and places them under libmach, then forwards to riscv
+    //!: what is common for?
+
+        RISCV
+        =======
+        Compiles ic/machine/timer and their corresponding _inits and places them under libmach and libinit.
+        =======
+    =======
+
+    API
+    =======
+    Same with libsys.
+    =======
+
+    SETUP
+    =======
+    If SETUP is NOT_USED, then just install the .o file under lib/
+    =======
+
+    SYSTEM
+    =======
+    links system_binding.o + system_scaffold.o together under system_sifive.o and installs it and application_scaffold
+    (now application_sifive_e) under lib/ 
+    =======
+
+    INIT
+    =======
+    Just renames the inits and places them under lib/
+    =======
+=======
+
+APP
+=======
+eposcc is finally used. Compiles the application with eposcc, links it, and then installs it under img/
+
+=======
+
+EPOSCC
+=======
+language=C
+link_objs=hello.o
+//!: Note various different compiler flags are used throughout the build.
+=======
+
+IMG
+=======
+Flashing/GDB/QEMU stuff; not important for now
+=======
+
+CLEAN
+=======
+-clean:
+    etc: resets config.h
+    app: do nothing?
+    src: everything below src? or excludes system, image, init?
+    img: do nothing?
+-cleanapps:
+    clean for every app
+-veryclean: clean cleanapps cleantest
+=======
+
+DEFS
+=======
+
+
+=======
+
+Doubts:
+- Does epos need eposcfg to use makedefs?
+- I saw .sdata as section 1 (right after .init), werent we assuming they would
+    be contiguous on the logical address space?
+
+/usr/local/rv32/bin/riscv32-unknown-linux-gnu-g++ -c -Wl, -mno-relax -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit
+--no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch
+-Wno-array-bounds -Wno-attribute-alias
+-Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member -Wattributes -I/home/alek/so2/nicolas2/so2_remote/include elf.cc
+
+
+--no-warn-mismatch 
+
+usr/local/rv32/bin/riscv32-unknown-linux-gnu-ld --no-relax -nostdlib -L/home/alek/so2/nicolas2/so2_remote/lib -Bstatic 
+-L`/usr/local/rv32/bin/riscv32-unknown-linux-gnu-gcc -ansi -c -Wl, 
+-mno-relax -O -nostdinc -fno-stack-protector -fno-pie -Wno-builtin-declaration-mismatch 
+-Wno-array-bounds -Wno-address-of-packed-member -print-file-name=` --nmagic \
+        --section-start .init=0x80010000 \
+        --section-start .sdata=0x80040000 \
+        --entry=_init -o system_sifive_e \
+        /home/alek/so2/nicolas2/so2_remote/lib/crtbegin_sifive_e.o \
+        system_scaffold.o system_binding.o \
+        /home/alek/so2/nicolas2/so2_remote/lib/crtend_sifive_e.o \
+        --whole-archive \
+        -lsys_sifive_e -lmach_sifive_e -larch_sifive_e \
+        --no-whole-archive \
+        -lutil_sifive_e -linit_sifive_e -lgcc
+
+
+GDB
+=======
+0x81000000 -> 16MB
+0x80100000 -> 1MB
+
+INIT:     0x80200000; 
+SYS_CODE: 0x80300000;
+SYS_DATA: 0x80400000;
+dump memory core2 0x80000000 0x8012a2c8
+find 0x80000000, 0x802fffff, (char) 0x7F , 'E', 'L', 'F'       
+0x80000004
+0x80019b6c
+0x8006ec00
+0x8013a538
+
+entry_point     setup 0x80000080
+
+init global constructors
+
+app entry 
+
+
+
+
+Init:
+rv32_cpu_init.o
+rv32_mmu_init.o
+riscv_ic_init.o
+riscv_machine_init.o
+riscv_timer_init.o
+alarm_init.o
+system_init.o
+thread_init.o
+
+crtbegin_sifive_e.o
+init_first.o
+init_system.o
+crtend_sifive_e.o
+
+
+Reduzir o PAGE_TABLES (vamos usar mais que 544+1 tabelas de pagina?)
+=======
+        
\ No newline at end of file
diff --git a/docs/cur_diff.patch b/docs/cur_diff.patch
new file mode 100644
index 0000000..cbac896
--- /dev/null
+++ b/docs/cur_diff.patch
@@ -0,0 +1,1691 @@
+diff --git a/app/hello_usr/hello_usr.cc b/app/hello_usr/hello_usr.cc
+new file mode 100644
+index 0000000..2246846
+--- /dev/null
++++ b/app/hello_usr/hello_usr.cc
+@@ -0,0 +1,12 @@
++#include <utility/ostream.h>
++#include <time.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++int main()
++{
++    cout << "Hello world!" << endl;
++    return 0;
++}
+diff --git a/app/hello_usr/hello_usr_traits.h b/app/hello_usr/hello_usr_traits.h
+new file mode 100644
+index 0000000..8fe3f88
+--- /dev/null
++++ b/app/hello_usr/hello_usr_traits.h
+@@ -0,0 +1,154 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = BUILTIN;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = true;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = true;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+diff --git a/app/hello_usr/makefile b/app/hello_usr/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/hello_usr/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/etc/makefile b/etc/makefile
+index 1e29432..7e25768 100644
+--- a/etc/makefile
++++ b/etc/makefile
+@@ -31,7 +31,8 @@ eposcc.conf: FORCE
+ 		@echo "APP_DATA=$(shell $(BIN)/eposcfg APP_DATA)" >> $@
+ 		@echo "SETUP=$(shell $(BIN)/eposcfg SETUP)" >> $@
+ 		@echo "BOOT_STACK=$(shell $(BIN)/eposcfg BOOT_STACK)" >> $@
+-		@echo "MACH_CC_FLAGS='$(MACH_CC_FLAGS)'" >> $@
++#!P2: Why CC and not CXX?
++		@echo "MACH_CC_FLAGS='$(MACH_CXX_FLAGS)'" >> $@
+ 		@echo "MACH_LD_FLAGS='$(MACH_LD_FLAGS)'" >> $@
+ 		@echo "MACH_CODE_NAME='$(MACH_CODE_NAME)'" >> $@
+ 		@echo "MACH_DATA_NAME='$(MACH_DATA_NAME)'" >> $@
+@@ -47,6 +48,8 @@ eposmkbi.conf:	FORCE
+ 		@echo "ENDIANESS=$(shell $(BIN)/eposcfg ENDIANESS)" >> $@
+ 		@echo "MEM_BASE=$(shell $(BIN)/eposcfg MEM_BASE)" >> $@
+ 		@echo "MEM_TOP=$(shell $(BIN)/eposcfg MEM_TOP)" >> $@
++		@echo "MIO_BASE=$(shell $(BIN)/eposcfg MIO_BASE)" >> $@
++		@echo "MIO_TOP=$(shell $(BIN)/eposcfg MIO_TOP)" >> $@
+ 		@echo "BOOT_LENGTH_MIN=$(shell $(BIN)/eposcfg BOOT_LENGTH_MIN)" >> $@
+ 		@echo "BOOT_LENGTH_MAX=$(shell $(BIN)/eposcfg BOOT_LENGTH_MAX)" >> $@
+ 		@echo "NODE_ID=$(NODE_ID)" >> $@
+diff --git a/img/makefile b/img/makefile
+index 0799121..9b1b14f 100644
+--- a/img/makefile
++++ b/img/makefile
+@@ -18,18 +18,20 @@ else
+ FLASH		:= $(IMAGE)
+ endif
+ 
++#!P2: Solve debugger
+ DEBUGGER	:= $(MACH_DEBUGGER)
+ ifeq ($(DEBUG),1)
+-ifneq ($(wildcard $(IMG)/$(MACH)_setup),)
+-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/$(MACH)_setup,.text)"
+-endif
+-ifneq ($(wildcard $(IMG)/$(MACH)_init),)
+-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/$(MACH)_init,.text)"
+-endif
+-ifneq ($(wildcard $(IMG)/$(MACH)_system),)
+-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
+-endif
+-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
++# ifneq ($(wildcard $(IMG)/$(MACH)_setup),)
++# DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/$(MACH)_setup,.text)"
++# endif
++# ifneq ($(wildcard $(IMG)/$(MACH)_init),)
++# DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/$(MACH)_init,.text)"
++# endif
++# ifneq ($(wildcard $(IMG)/$(MACH)_system),)
++# DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
++# endif
++# DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
++DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000000"
+ PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
+ endif
+ 
+diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
+index 57da06c..6618b02 100644
+--- a/include/architecture/mmu.h
++++ b/include/architecture/mmu.h
+@@ -79,6 +79,7 @@ public:
+     static unsigned int directory(const Log_Addr & addr) { return addr >> DIRECTORY_SHIFT; }
+ 
+     static Log_Addr align_page(const Log_Addr & addr) { return (addr + sizeof(Page) - 1) & ~(sizeof(Page) - 1); }
++    //!P2: yet to be merged
+     static Log_Addr align_directory(const Log_Addr & addr) { return (addr + sizeof(Page) * sizeof(Page) - 1) &  ~(sizeof(Page) * sizeof(Page) - 1); }
+ };
+ 
+diff --git a/include/machine/riscv/riscv_info.h b/include/machine/riscv/riscv_info.h
+deleted file mode 100644
+index f50bdda..0000000
+--- a/include/machine/riscv/riscv_info.h
++++ /dev/null
+@@ -1,63 +0,0 @@
+-// EPOS RISC-V Common Run-Time System Information
+-
+-#ifndef __riscv_info_h
+-#define __riscv_info_h
+-
+-#include <system/info.h>
+-
+-__BEGIN_SYS
+-
+-struct System_Info
+-{
+-private:
+-    typedef unsigned int LAddr;
+-    typedef unsigned int PAddr;
+-    typedef unsigned int Size;
+-
+-public:
+-    // The information we have at boot time (built by MKBI)
+-    // Modifications to this map requires adjustments at MKBI
+-    struct Boot_Map
+-    {
+-        volatile unsigned int n_cpus;     // Number of CPUs in SMPs
+-        PAddr mem_base;                   // Memory base address
+-        PAddr mem_top;                    // Memory top address
+-        PAddr io_base;                    // I/O Memory base address
+-        PAddr io_top;                     // I/O Memory top address
+-        int node_id;                      // Local node id in SAN (-1 => RARP)
+-        int space_x;                      // Spatial coordinates of a node (-1 => mobile)
+-        int space_y;                      //
+-        int space_z;                      //
+-        unsigned char uuid[8];            // EPOS image Universally Unique Identifier
+-        Size img_size;                    // Boot image size (in bytes)
+-        Size setup_offset;                // Image offsets (-1 => not present)
+-        Size init_offset;
+-        Size system_offset;
+-        Size application_offset;
+-        Size extras_offset;
+-    };
+-
+-    // Load Map (not used in this machine, but kept for architectural transparency)
+-    struct Load_Map
+-    {
+-        bool  has_ext;
+-        LAddr app_entry;
+-        Size  app_segments;
+-        LAddr app_code;
+-        Size  app_code_size;
+-        LAddr app_data;
+-        LAddr app_stack;
+-        LAddr app_heap;
+-        Size  app_data_size;
+-        PAddr app_extra;
+-        Size  app_extra_size;
+-    };
+-
+-public:
+-    Boot_Map bm;
+-    Load_Map lm;
+-};
+-
+-__END_SYS
+-
+-#endif
+diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
+index f50bdda..865e083 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_info.h
++++ b/include/machine/riscv/sifive_e/sifive_e_info.h
+@@ -1,7 +1,7 @@
+ // EPOS RISC-V Common Run-Time System Information
+ 
+-#ifndef __riscv_info_h
+-#define __riscv_info_h
++#ifndef __riscv_sifive_e_info_h
++#define __riscv_sifive_e_info_h
+ 
+ #include <system/info.h>
+ 
+@@ -22,8 +22,8 @@ public:
+         volatile unsigned int n_cpus;     // Number of CPUs in SMPs
+         PAddr mem_base;                   // Memory base address
+         PAddr mem_top;                    // Memory top address
+-        PAddr io_base;                    // I/O Memory base address
+-        PAddr io_top;                     // I/O Memory top address
++        PAddr mio_base;                   // Memory-mapped I/O base address
++        PAddr mio_top;                    // Memory-mapped I/O top address
+         int node_id;                      // Local node id in SAN (-1 => RARP)
+         int space_x;                      // Spatial coordinates of a node (-1 => mobile)
+         int space_y;                      //
+@@ -49,7 +49,7 @@ public:
+         LAddr app_stack;
+         LAddr app_heap;
+         Size  app_data_size;
+-        PAddr app_extra;
++        LAddr app_extra;
+         Size  app_extra_size;
+     };
+ 
+diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+index eb7606c..cb8beac 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
++++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+@@ -11,7 +11,9 @@ __BEGIN_SYS
+ 
+ struct Memory_Map
+ {
+-    // Physical Memory
++    static const unsigned int NOT_USED = Traits<Machine>::NOT_USED;
++    
++    // Memory Mapped stuff
+     enum {
+         TEST_BASE                   = 0x00100000, // SiFive test engine
+         RTC_BASE                    = 0x00101000, // goldfish_rtc
+@@ -24,23 +26,32 @@ struct Memory_Map
+     // Physical Memory
+     enum {
+         MEM_BASE        = Traits<Machine>::MEM_BASE,
+-        MEM_TOP         = Traits<Machine>::MEM_TOP
++        MEM_TOP         = Traits<Machine>::MEM_TOP,
++        MIO_BASE        = Traits<Machine>::MIO_BASE,
++        MIO_TOP         = Traits<Machine>::MIO_TOP,
++        BOOT_STACK      = Traits<Machine>::BOOT_STACK,
++
+     };
+ 
+     // Logical Address Space
+     enum {
++        BOOT            = Traits<Machine>::BOOT,
++        IMAGE           = Traits<Machine>::IMAGE,
++        SETUP           = Traits<Machine>::SETUP,
++        INIT            = Traits<Machine>::INIT,
++
+         APP_LOW         = Traits<Machine>::APP_LOW,
+-        APP_CODE        = 0x88000000,
+-        APP_DATA        = 0xffc00000,
++        APP_CODE        = Traits<Machine>::APP_CODE,
++        APP_DATA        = Traits<Machine>::APP_DATA,
+         APP_HIGH        = Traits<Machine>::APP_HIGH,
+ 
+         PHY_MEM         = Traits<Machine>::PHY_MEM,
+         IO              = Traits<Machine>::IO_BASE,
+ 
+-        SYS             = Traits<Machine>::NOT_USED,
++        SYS             = Traits<Machine>::SYS,
+         SYS_INFO        = unsigned(-1),                 // Dynamically built during initialization.
+-        SYS_CODE        = Traits<Machine>::NOT_USED,
+-        SYS_DATA        = Traits<Machine>::NOT_USED,
++        SYS_CODE        = Traits<Machine>::SYS_CODE,
++        SYS_DATA        = Traits<Machine>::SYS_DATA,
+         SYS_HEAP        = Traits<Machine>::NOT_USED,
+         SYS_STACK       = Traits<Machine>::NOT_USED
+     };
+diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
+index 2b3718c..2acbf80 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
++++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
+@@ -20,33 +20,41 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
+     // Boot Image
+     static const unsigned int BOOT_LENGTH_MIN   = NOT_USED;
+     static const unsigned int BOOT_LENGTH_MAX   = NOT_USED;
++    static const unsigned int BOOT_STACK        = 0x87ffffff;
+ 
+     // Physical Memory
+     static const unsigned int MEM_BASE          = 0x80000000;
++    static const unsigned int MEM_TOP           = 0x87ffffff; // 128 MB
++    static const unsigned int MIO_BASE          = 0x00000000;
++    static const unsigned int MIO_TOP           = 0x100081ff;
++
+     static const unsigned int VECTOR_TABLE      = NOT_USED;
+     static const unsigned int PAGE_TABLES       = 0x87ffffff + 1 - 16*1024 - ((1024+1)*4*1024); // 0x87BFB000
+-    static const unsigned int MEM_TOP           = 0x87ffffff; // 128 MB
+-    static const unsigned int BOOT_STACK        = 0x87ffffff;
+ 
+     // Logical Memory Map
+     static const unsigned int BOOT              = NOT_USED;
+-    static const unsigned int SETUP             = NOT_USED;
+-    static const unsigned int INIT              = NOT_USED;
+-
+-    static const unsigned int APP_LOW           = 0x80000000;
+-    static const unsigned int APP_CODE          = 0x80000000;
+-    static const unsigned int APP_DATA          = 0x80000000;
++    static const unsigned int IMAGE             = NOT_USED;
++    static const unsigned int SETUP             = 0x80000000; // This controls whether an ELF file is generated for setup
++    // static const unsigned int SETUP             = NOT_USED;
++    static const unsigned int INIT              = 0x80010000; // 16 pages for setup
++
++    static const unsigned int APP_LOW           = 0x88000000;
++    static const unsigned int APP_CODE          = 0x88000000;
++    static const unsigned int APP_DATA          = 0xffc00000;
+     static const unsigned int APP_HIGH          = 0x87ffffff;
+ 
+-    static const unsigned int PHY_MEM           = NOT_USED; // No paging MMU
+-    static const unsigned int IO_BASE           = NOT_USED; // No paging MMU
+-    static const unsigned int IO_TOP            = NOT_USED; // No paging MMU
+-
+-    static const unsigned int SYS               = NOT_USED; // No paging MMU
+-    static const unsigned int SYS_CODE          = NOT_USED; // No paging MMU
+-    static const unsigned int SYS_DATA          = NOT_USED; // No paging MMU
+-    static const unsigned int SYS_HEAP          = NOT_USED; // No paging MMU
+-    static const unsigned int SYS_STACK         = NOT_USED; // No paging MMU
++    static const unsigned int PHY_MEM           = NOT_USED;
++    static const unsigned int IO_BASE           = NOT_USED;
++    static const unsigned int IO_TOP            = NOT_USED;
++
++    //!P2: This can be optimized
++    //!P2: Is SYS_HEAP necessary?
++    //!P2: we can let the BOOT_STACK be the kernel stack
++    static const unsigned int SYS               = NOT_USED;
++    static const unsigned int SYS_CODE          = 0x80020000;
++    static const unsigned int SYS_DATA          = 0x80040000;
++    static const unsigned int SYS_HEAP          = NOT_USED;
++    static const unsigned int SYS_STACK         = NOT_USED;
+ 
+     // Default Sizes and Quantities
+     static const unsigned int STACK_SIZE        = 16 * 1024;
+diff --git a/makedefs b/makedefs
+index 7c5fd92..5e654fb 100644
+--- a/makedefs
++++ b/makedefs
+@@ -182,8 +182,8 @@ riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp
+ riscv_DEBUGGER          := $(COMP_PREFIX)gdb
+ riscv_FLASHER           := 
+ riscv_MAGIC             := --nmagic
+-riscv_CODE_NAME := .init
+-riscv_DATA_NAME :=
++riscv_CODE_NAME 		:= .init
++riscv_DATA_NAME 		:= .sdata
+ riscv_IMG_SUFFIX        := .img
+ endif
+ 
+@@ -251,7 +251,7 @@ TLD		:= gcc
+ TLDFLAGS	:= -m32
+ 
+ # Tools and flags to compile applications
+-ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
++ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
+ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
+ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
+diff --git a/notes/build.txt b/notes/build.txt
+new file mode 100644
+index 0000000..25a091f
+--- /dev/null
++++ b/notes/build.txt
+@@ -0,0 +1,135 @@
++We did not specify target: execute all; APPLICATION was defined => execute all1
++all1: etc tools src app img
++
++ETC
++=======
++etc: config eposcfg eposcc.conf eposmkbi.conf
++config: config.h (config always execute?)
++    defines SMOD, ARCH, MACH, etc. in config.h
++eposcfg: FORCE
++    removes eposcfg executable
++eposcc.conf and eposmkbi.conf: FORCE
++    use eposcfg to build .conf files (which I suppose are used by tools?)
++=======
++
++TOOLS
++=======
++Mostly, just compile them
++=======
++
++SRC
++=======
++src: utility architecture machine api setup boot system init
++
++    UTIL
++    =======
++    just compiles utility/ and groups it inside lib/libutil_sifive_e.a
++    =======
++
++    ARCH
++    =======
++    forwards to rv32,
++    
++        RV32
++        =======
++        compiles crts and installs them under lib/crtxxx_sifive_e.o, then compiles the cpu/mmu/tsc _inits and their corresponding
++        _inits and places them under libarch and libinit.
++        =======
++    =======
++
++    MACH
++    =======
++    Does common and places them under libmach, then forwards to riscv
++    //!: what is common for?
++
++        RISCV
++        =======
++        Compiles ic/machine/timer and their corresponding _inits and places them under libmach and libinit.
++        =======
++    =======
++
++    API
++    =======
++    Same with libsys.
++    =======
++
++    SETUP
++    =======
++    If SETUP is NOT_USED, then just install the .o file under lib/
++    =======
++
++    SYSTEM
++    =======
++    links system_binding.o + system_scaffold.o together under system_sifive.o and installs it and application_scaffold
++    (now application_sifive_e) under lib/ 
++    =======
++
++    INIT
++    =======
++    Just renames the inits and places them under lib/
++    =======
++=======
++
++APP
++=======
++eposcc is finally used. Compiles the application with eposcc, links it, and then installs it under img/
++
++=======
++
++EPOSCC
++=======
++language=C
++link_objs=hello.o
++//!: Note various different compiler flags are used throughout the build.
++=======
++
++IMG
++=======
++Flashing/GDB/QEMU stuff; not important for now
++=======
++
++CLEAN
++=======
++-clean:
++    etc: resets config.h
++    app: do nothing?
++    src: everything below src? or excludes system, image, init?
++    img: do nothing?
++-cleanapps:
++    clean for every app
++-veryclean: clean cleanapps cleantest
++=======
++
++DEFS
++=======
++
++
++=======
++
++Doubts:
++- Does epos need eposcfg to use makedefs?
++- I saw .sdata as section 1 (right after .init), werent we assuming they would
++    be contiguous on the logical address space?
++
++/usr/local/rv32/bin/riscv32-unknown-linux-gnu-g++ -c -Wl, -mno-relax -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit
++--no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch
++-Wno-array-bounds -Wno-attribute-alias
++-Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member -Wattributes -I/home/alek/so2/nicolas2/so2_remote/include elf.cc
++
++
++--no-warn-mismatch 
++
++usr/local/rv32/bin/riscv32-unknown-linux-gnu-ld --no-relax -nostdlib -L/home/alek/so2/nicolas2/so2_remote/lib -Bstatic 
++-L`/usr/local/rv32/bin/riscv32-unknown-linux-gnu-gcc -ansi -c -Wl, 
++-mno-relax -O -nostdinc -fno-stack-protector -fno-pie -Wno-builtin-declaration-mismatch 
++-Wno-array-bounds -Wno-address-of-packed-member -print-file-name=` --nmagic \
++        --section-start .init=0x80010000 \
++        --section-start .sdata=0x80040000 \
++        --entry=_init -o system_sifive_e \
++        /home/alek/so2/nicolas2/so2_remote/lib/crtbegin_sifive_e.o \
++        system_scaffold.o system_binding.o \
++        /home/alek/so2/nicolas2/so2_remote/lib/crtend_sifive_e.o \
++        --whole-archive \
++        -lsys_sifive_e -lmach_sifive_e -larch_sifive_e \
++        --no-whole-archive \
++        -lutil_sifive_e -linit_sifive_e -lgcc
+\ No newline at end of file
+diff --git a/notes/check_list.txt b/notes/check_list.txt
+deleted file mode 100644
+index 0c58e23..0000000
+--- a/notes/check_list.txt
++++ /dev/null
+@@ -1,3 +0,0 @@
+-1) Change Where Page Tables are created (move down a bit)
+-2) Force constructor to be a function
+-3) set satp later
+\ No newline at end of file
+diff --git a/src/architecture/rv32/rv32_cpu.cc b/src/architecture/rv32/rv32_cpu.cc
+index c47a597..47e8f61 100644
+--- a/src/architecture/rv32/rv32_cpu.cc
++++ b/src/architecture/rv32/rv32_cpu.cc
+@@ -14,7 +14,7 @@ void CPU::Context::save() volatile
+ {
+     ASM("       csrr     gp,  sstatus           \n"
+         "       sw       gp, -120(sp)           \n"     // push sstatus
+-        "       la       gp,      pc            \n"
++        "       auipc    gp, 0                  \n"     //!P2: Is still ok?
+         "       sw       gp, -116(sp)           \n"     // push pc
+         "       sw       x1, -112(sp)           \n"     // push ra
+         "       sw       x5, -108(sp)           \n"     // push x5-x31
+diff --git a/src/architecture/rv32/rv32_mmu_init.cc b/src/architecture/rv32/rv32_mmu_init.cc
+index bfcc416..c295a25 100644
+--- a/src/architecture/rv32/rv32_mmu_init.cc
++++ b/src/architecture/rv32/rv32_mmu_init.cc
+@@ -13,7 +13,7 @@ void MMU::init()
+     db<Init, MMU>(TRC) << "MMU::init()" << endl;
+ 
+     db<Init, MMU>(INF) << "MMU::init::dat.e=" << &_edata << ",bss.b=" << &__bss_start << ",bss.e=" << &_end << endl;
+-
++    //!P2: free everything below Traits<Machine>::SYS; worst fit will guarantee no issue w/ this.
+     // For machines that do not feature a real MMU, frame size = 1 byte
+     // Allocations (using Grouping_List<Frame>::search_decrementing() start from the end
+     // To preserve the BOOT stacks until the end of INIT, the free memory list initialization is split in two sections
+diff --git a/src/init/init_first.cc b/src/init/init_first.cc
+index da4ccf1..ecbbe4a 100644
+--- a/src/init/init_first.cc
++++ b/src/init/init_first.cc
+@@ -26,7 +26,8 @@ public:
+ 
+         // Interrupts have been disable at Thread::init() and will be reenabled by CPU::Context::load()
+         // but we first reset the timer to avoid getting a time interrupt during load()
+-        Timer::reset();
++        if (Traits<Timer>::enabled)
++            Timer::reset();
+         first->_context->load();
+     }
+ };
+diff --git a/src/setup/makefile b/src/setup/makefile
+index b5ead57..5fb98cc 100644
+--- a/src/setup/makefile
++++ b/src/setup/makefile
+@@ -5,9 +5,9 @@ include ../../makedefs
+ TARGET := $(if $(shell find setup_$(MMOD)* 2> /dev/null), $(if $(SETUP_ADDR), install, install.o))
+ 
+ all:	$(TARGET)
+-
++#!P2: Switch to mode-based ruling
+ setup_$(MMOD):	setup_$(MMOD).o
+-		$(LD) $(LDFLAGS) -L$(CCLIB) --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
++		$(LD) $(LDFLAGS) -L$(CCLIB) --trace --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
+ 
+ install:	setup_$(MMOD)
+ 		$(INSTALL) $< $(IMG)
+diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
+index 2750ef4..194e2e5 100644
+--- a/src/setup/setup_sifive_e.cc
++++ b/src/setup/setup_sifive_e.cc
+@@ -1,22 +1,35 @@
+ // EPOS RISC-V sifive SETUP
+ 
++#include <utility/ostream.h>
++
++#include <system/info.h>
+ #include <architecture.h>
+ #include <machine.h>
+ 
+ using namespace EPOS::S;
+ typedef unsigned int Reg;
+ 
++//!P2:
++// _start is now inside init
++// _int_entry and _mmode_forward must be rellocated to avoid being erased from MMU::_free
++// How can we run machine_pre_init before Init_System if it is part of SYS?
++
+ extern "C"
+ {
+     [[gnu::naked, gnu::section(".init")]] void _setup();
+-    void _int_entry();
+-    void _start();
++    // void _int_entry();
++    // void _start();
+     void _wait() {
+         CPU::halt();
+-        _start();
++        // _start();
+     }
++    void _print(const char * s) { Display::puts(s); }
+ }
+ 
++char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________";
++System_Info * si;
++EPOS::S::U::OStream kout, kerr;
++
+ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+     Reg id = CPU::mcause();
+     if((id & IC::INT_MASK) == CLINT::IRQ_MAC_TIMER) {
+@@ -81,7 +94,7 @@ void Setup_SifiveE::clean_bss()
+ 
+ void Setup_SifiveE::setup_supervisor_environment()
+ {
+-    CPU::stvec_write((unsigned)&_int_entry & 0xfffffffc);
++    // CPU::stvec_write((unsigned)&_int_entry & 0xfffffffc);
+ 
+     // We must clean the bss before setting MMU::_master
+     clean_bss();
+@@ -89,9 +102,22 @@ void Setup_SifiveE::setup_supervisor_environment()
+     // This creates and configures the kernel page tables (which map logical==physical)
+     build_page_tables();
+ 
++    //!P2: How could machine pre_init run before Init_System if it was linked w/ SYS?
++    // if(CPU::id() == 0)
++    //     Display::init();
++
++    // db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
++
++    // if(CPU::id() == 0 && Traits<IC>::enabled) {
++    //     IC::init();
++
++    //     if(Traits<System>::multicore)
++    //         smp_barrier_init(Traits<Build>::CPUS);
++    // }
++
+     // forward everything
+     CPU::satp((0x1 << 31) | (Traits<Machine>::PAGE_TABLES >> 12));
+-    CPU::sepc_write((unsigned)&_start);
++    // CPU::sepc_write((unsigned)&_start);
+ 
+     // Interrupts will remain disable until the Context::load at Init_First
+     CPU::sstatus_write(CPU::SPP_S);
+@@ -102,10 +128,10 @@ void Setup_SifiveE::setup_supervisor_environment()
+ 
+ void Setup_SifiveE::setup_machine_environment()
+ {
++    si = reinterpret_cast<System_Info*>(placeholder);
+     // We first configure the M-mode CSRs and then switch to S-mode
+     // configure paging. After that, we won't return to M-mode; an exception
+     // is the forwarding of ints and excps to S-mode.
+-
+     CPU::mie_write(CPU::MSI | CPU::MTI | CPU::MEI);
+     CPU::mmode_int_disable();
+ 
+diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
+index cfb0d35..95f1ce4 100644
+--- a/src/system/system_scaffold.cc
++++ b/src/system/system_scaffold.cc
+@@ -15,7 +15,7 @@ class First_Object
+ {
+ public:
+     First_Object() {
+-        Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
++        // Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
+     }
+ };
+ 
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
+index dbe3578..3fb68de 100644
+--- a/tools/eposcc/eposcc
++++ b/tools/eposcc/eposcc
+@@ -44,27 +44,30 @@ C_LINK_FLGS="$MACH_LD_FLAGS"
+ C_LINK_OBJS=
+ C_LINK_LIBS=
+ 
++#!P2: C++ flags are now used
++# 
++
+ CPP_COMPILER="$TOOLS_PREFIX""g++"
+-CPP_COMP_FLGS="--no-exceptions --no-rtti --no-use-cxa-atexit -std=c++14"
++CPP_COMP_FLGS="$MACH_CC_FLAGS"
+ CPP_COMP_HDRS=
+ CPP_LINK_FLGS="$MACH_LD_FLAGS"
+ CPP_LINK_OBJS=
+ CPP_LINK_LIBS=
+ 
+-F77_COMPILER="$TOOLS_PREFIX""g77"
+-F77_COMP_FLGS=
+-F77_COMP_HDRS=
+-F77_LINK_FLGS="$MACH_LD_FLAGS"
+-F77_LINK_OBJS=
+-F77_LINK_LIBS="f2c"
++# F77_COMPILER="$TOOLS_PREFIX""g77"
++# F77_COMP_FLGS=
++# F77_COMP_HDRS=
++# F77_LINK_FLGS="$MACH_LD_FLAGS"
++# F77_LINK_OBJS=
++# F77_LINK_LIBS="f2c"
+ 
+ LINKER="$TOOLS_PREFIX""ld"
+ 
+ LINKER_LIBRARY=$LINKER
+ LINK_FLGS_LIBRARY="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE"
+-if [ "$MACH_DATA_NAME" != "" ] ; then
+-    LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=$APP_DATA"
+-fi
++# if [ "$MACH_DATA_NAME" != "" ] ; then
++#     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=0x86000000"
++# fi
+ if [ "$BOOT_STACK" != "" ] ; then
+     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --defsym=__boot_stack__=$BOOT_STACK"
+ fi
+@@ -76,6 +79,7 @@ if [ "$SETUP" = "" ] ; then
+     LINK_OBJI_LIBRARY="$LIB/setup_$MMOD.o $LINK_OBJI_LIBRARY"
+ fi
+ 
++#!P2: Epos changed this
+ LINKER_BUILTIN=$LINKER
+ LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+ LINK_OBJI_BUILTIN="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
+@@ -86,12 +90,12 @@ if [ "$SETUP" = "" ] ; then
+ LINK_OBJN_BUILTIN="$LIB/setup_$MMOD.o $LINK_OBJN_BUILTIN"
+ fi
+ 
+-LINKER_KERNEL=$LINKER
+-LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+-LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
+-LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
+-LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
+-LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
++# LINKER_KERNEL=$LINKER
++# LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
++# LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
++# LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
++# LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
++# LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
+ 
+ #=========================================================================
+ # VARIABLES
+@@ -271,6 +275,7 @@ done
+ #=========================================================================
+ # COMMAND ISSUING
+ #=========================================================================
++
+ if [ "$language" = "F77" ] ; then
+     compiler=$F77_COMPILER
+     compile_flgs="$compile_flgs $F77_COMP_FLGS"
+@@ -289,6 +294,8 @@ elif [ "$language" = "CPP" ] ; then
+         compile_flgs="$compile_flgs -I$hdr"
+     done
+     link_flgs="$link_flgs $CPP_LINK_FLGS"
++    echo "LD FLAGS1\n"
++    echo $link_flgs
+     link_objs="$CPP_LINK_OBJS $link_objs"
+     for lib in $CPP_LINK_LIBS ; do
+         link_libs="$link_libs -l$lib"
+@@ -347,51 +354,54 @@ if [ $need_compile = 1 -a ! -f "$key_file" ] ; then
+ fi
+ 
+ # disabled for EPOS
+-if [ $need_analyze = 5 ] ; then
+-    analyze_flgs=$compile_flgs
++# if [ $need_analyze = 5 ] ; then
++#     analyze_flgs=$compile_flgs
+ 
+-    if [ $has_dash_c = 0 ] ; then
+-        analyze_flgs="-c $analyze_flgs"
+-    fi
+-    tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
+-    analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
+-    analyze_flgs="$analyze_flgs -o $tmp_file.o"
+-    $do_echo $compiler $analyze_flgs $analyze_args $input_file
+-    $do_exec $compiler $analyze_flgs $analyze_args $input_file
+-    status=$?
+-    if [ $status != 0 ] ; then
+-        $do_echo rm -f "$tmp_file.*"
+-        $do_exec rm -f "$tmp_file.*"
+-        exit $status
+-    fi
++#     if [ $has_dash_c = 0 ] ; then
++#         analyze_flgs="-c $analyze_flgs"
++#     fi
++#     tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
++#     analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
++#     analyze_flgs="$analyze_flgs -o $tmp_file.o"
++#     $do_echo $compiler $analyze_flgs $analyze_args $input_file
++#     $do_exec $compiler $analyze_flgs $analyze_args $input_file
++#     status=$?
++#     if [ $status != 0 ] ; then
++#         $do_echo rm -f "$tmp_file.*"
++#         $do_exec rm -f "$tmp_file.*"
++#         exit $status
++#     fi
+ 
+-    $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+-    $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+-    status=$?
+-    if [ $status != 0 ] ; then
+-        $do_echo rm -f "$tmp_file.*"
+-        $do_exec rm -f "$tmp_file.*"
+-        exit $status
+-    fi
++#     $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
++#     $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
++#     status=$?
++#     if [ $status != 0 ] ; then
++#         $do_echo rm -f "$tmp_file.*"
++#         $do_exec rm -f "$tmp_file.*"
++#         exit $status
++#     fi
+ 
+-    if [ $only_analyze = 1 -a -n "$output_file" ] ; then
+-        configurator_output_file=$output_file
+-    else
+-        configurator_output_file=$key_file
+-    fi
+-    $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+-    $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
++#     if [ $only_analyze = 1 -a -n "$output_file" ] ; then
++#         configurator_output_file=$output_file
++#     else
++#         configurator_output_file=$key_file
++#     fi
++#     $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
++#     $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+ 
+-    status=$?
+-    $do_echo rm -f "$tmp_file.*"
+-    $do_exec rm -f "$tmp_file.*"
++#     status=$?
++#     $do_echo rm -f "$tmp_file.*"
++#     $do_exec rm -f "$tmp_file.*"
+ 
+-    if [ $only_analyze = 1 ] ; then
+-        exit $status
+-    fi
+-fi
++#     if [ $only_analyze = 1 ] ; then
++#         exit $status
++#     fi
++# fi
+ 
+ if [ $need_compile = 1 ] ; then
++    # echo $has_dash_c
++    # echo $language
++    # echo $compile_flgs
+     if [ $has_dash_c = 0 ] ; then
+         compile_flgs="-c $compile_flgs"
+     fi
+@@ -412,7 +422,7 @@ if [ $need_link = 1 ] ; then
+         link_flgs="$link_flgs -o $output_file"
+     fi
+     $do_echo "$linker $link_flgs $link_objs $link_args $link_libs"
+-    $do_exec $linker $link_flgs $link_objs $link_args $link_libs
++    $do_exec $linker --trace $link_flgs $link_objs $link_args $link_libs
+     status=$?
+ fi
+ 
+diff --git a/tools/eposcfg/eposcfg.cc b/tools/eposcfg/eposcfg.cc
+index 51b0f64..ec54b41 100644
+--- a/tools/eposcfg/eposcfg.cc
++++ b/tools/eposcfg/eposcfg.cc
+@@ -10,6 +10,7 @@
+ 
+ // Traits are included in config.h
+ #include <system/config.h>
++#include <system/memory_map.h>
+ 
+ // Using only bare C to avoid conflicts with EPOS
+ #include <stdio.h>
+@@ -21,7 +22,7 @@ using namespace EPOS::S;
+ using namespace EPOS::S::U;
+ 
+ // Constants
+-const unsigned int TOKENS = 24;
++const unsigned int TOKENS = 31;
+ const unsigned int COMPONENTS = 62;
+ const unsigned int STRING_SIZE = 128;
+ 
+@@ -40,14 +41,21 @@ char tokens[TOKENS][STRING_SIZE] = {
+     "MEM_TOP",
+     "MEM_SIZE",
+     "MEM_SIZE_KB",
++    "MIO_BASE",
++    "MIO_TOP",
++    "MIO_SIZE",
++    "MIO_SIZE_KB",
+     "BOOT_STACK",
+     "BOOT",
++    "IMAGE",
+     "SETUP",
+     "INIT",
+     "APP_CODE",
+     "APP_DATA",
+     "SYS_CODE",
+     "SYS_DATA",
++    "SYS_STACK",
++    "SYS_HEAP",
+     "BOOT_LENGTH_MIN",
+     "BOOT_LENGTH_MAX",
+     "EXPECTED_SIMULATION_TIME"
+@@ -192,66 +200,96 @@ void populate_strings()
+     snprintf(string, STRING_SIZE, "%i", Traits<CPU>::WORD_SIZE);
+     set_token_value("WORD_SIZE", string);
+ 
+-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_BASE);
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_BASE);
+     set_token_value("MEM_BASE", string);
+ 
+-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP);
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP);
+     set_token_value("MEM_TOP", string);
+ 
+-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE);
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE);
+     set_token_value("MEM_SIZE", string);
+ 
+-    snprintf(string, STRING_SIZE, "0x%08x", (Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE) / 1024);
++    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE) / 1024);
+     set_token_value("MEM_SIZE_KB", string);
+ 
+-    if(Traits<Machine>::BOOT_STACK != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT_STACK);
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_BASE);
++    set_token_value("MIO_BASE", string);
++
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP);
++    set_token_value("MIO_TOP", string);
++
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE);
++    set_token_value("MIO_SIZE", string);
++
++    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE) / 1024);
++    set_token_value("MIO_SIZE_KB", string);
++
++    if(Memory_Map::BOOT_STACK != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT_STACK);
+     else
+         string[0] = '\0';
+     set_token_value("BOOT_STACK", string);
+ 
+-    if(Traits<Machine>::BOOT != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT);
++    if(Memory_Map::BOOT != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT);
+     else
+         string[0] = '\0';
+     set_token_value("BOOT", string);
+ 
+-    if(Traits<Machine>::SETUP != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SETUP);
++    if(Memory_Map::IMAGE != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::IMAGE);
++    else
++        string[0] = '\0';
++    set_token_value("IMAGE", string);
++
++    if(Memory_Map::SETUP != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SETUP);
+     else
+         string[0] = '\0';
+     set_token_value("SETUP", string);
+ 
+-    if(Traits<Machine>::INIT != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::INIT);
++    if(Memory_Map::INIT != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::INIT);
+     else
+         string[0] = '\0';
+     set_token_value("INIT", string);
+ 
+-    if(Traits<Machine>::APP_CODE != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_CODE);
++    if(Memory_Map::APP_CODE != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_CODE);
+     else
+         string[0] = '\0';
+     set_token_value("APP_CODE", string);
+ 
+-    if(Traits<Machine>::APP_DATA != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_DATA);
++    if(Memory_Map::APP_DATA != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_DATA);
+     else
+         string[0] = '\0';
+     set_token_value("APP_DATA", string);
+ 
+-    if(Traits<Machine>::SYS_CODE != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_CODE);
++    if(Memory_Map::SYS_CODE != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_CODE);
+     else
+         string[0] = '\0';
+     set_token_value("SYS_CODE", string);
+ 
+-    if(Traits<Machine>::SYS_DATA != Traits<Machine>::NOT_USED)
+-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_DATA);
++    if(Memory_Map::SYS_DATA != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_DATA);
+     else
+         string[0] = '\0';
+     set_token_value("SYS_DATA", string);
+ 
++    if(Memory_Map::SYS_STACK != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_STACK);
++    else
++        string[0] = '\0';
++    set_token_value("SYS_STACK", string);
++
++    if(Memory_Map::SYS_HEAP != Memory_Map::NOT_USED)
++        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_HEAP);
++    else
++        string[0] = '\0';
++    set_token_value("SYS_HEAP", string);
++
+     if(Traits<Machine>::BOOT_LENGTH_MIN != Traits<Machine>::NOT_USED)
+         snprintf(string, STRING_SIZE, "%i", Traits<Machine>::BOOT_LENGTH_MIN);
+     else
+diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
+index da82176..75a2801 100644
+--- a/tools/eposmkbi/eposmkbi.cc
++++ b/tools/eposmkbi/eposmkbi.cc
+@@ -38,6 +38,8 @@ struct Configuration
+     bool           endianess;  // true => little, false => big
+     unsigned int   mem_base;
+     unsigned int   mem_top;
++    unsigned int   mio_base;
++    unsigned int   mio_top;
+     unsigned int   boot_length_min;
+     unsigned int   boot_length_max;
+     short          node_id;   // nodes in SAN (-1 => dynamic)
+@@ -52,13 +54,13 @@ typedef _SYS::System_Info System_Info;
+ 
+ // PROTOTYPES
+ bool parse_config(FILE * cfg_file, Configuration * cfg);
+-void strtolower (char *dst,const char* src);
++void strtolower (char * dst,const char * src);
+ bool add_machine_secrets(int fd_img, unsigned int i_size, char * mach, char * mmod);
+ 
+ bool file_exist(char *file);
+ 
+-int put_buf(int fd_out, void *buf, int size);
+-int put_file(int fd_out, char *file);
++int put_buf(int fd_out, void * buf, int size);
++int put_file(int fd_out, char * file);
+ int pad(int fd_out, int size);
+ bool lil_endian();
+ 
+@@ -140,7 +142,7 @@ int main(int argc, char **argv)
+     }
+ 
+     // Open destination file (rewrite)
+-    int fd_img = open(argv[optind + 1], O_WRONLY | O_CREAT | O_TRUNC, 00644);
++    int fd_img = open(argv[optind + 1], O_RDWR | O_CREAT | O_TRUNC, 00644);
+     if(fd_img < 0) {
+         fprintf(err, "Error: can't create boot image \"%s\"!\n", argv[optind + 1]);
+         return 1;
+@@ -152,7 +154,8 @@ int main(int argc, char **argv)
+     fprintf(out, "  Model: %s\n", CONFIG.mmod);
+     fprintf(out, "  Processor: %s (%d bits, %s-endian)\n", CONFIG.arch, CONFIG.word_size, CONFIG.endianess ? "little" : "big");
+     fprintf(out, "  Memory: %d KBytes\n", (CONFIG.mem_top - CONFIG.mem_base) / 1024);
+-    fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
++    if((CONFIG.boot_length_min + CONFIG.boot_length_max) > 0)
++        fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
+     if(CONFIG.space_x != -1)
+         fprintf(out, "  Node location: (%d, %d, %d)\n", CONFIG.space_x, CONFIG.space_y, CONFIG.space_z);
+     fprintf(out, "  UUID: ");
+@@ -179,29 +182,43 @@ int main(int argc, char **argv)
+     }
+     unsigned int boot_size = image_size;
+ 
++    // Determine if System_Info is needed and how it must be handled
++    bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
++    bool si_in_setup = (need_si && (boot_size == 0)); // If the image contains a boot sector, then SI will be on a separate disk sector. Otherwise, it will be inside SETUP.
++
+     // Reserve space for System_Info if necessary
+-    System_Info si;
+-    bool need_si = true;
+-    if(image_size == 0) {
+-        need_si = false;
+-    } else
+-        if(sizeof(System_Info) > MAX_SI_LEN) {
++    if(need_si && !si_in_setup) {
++        if(sizeof(System_Info) <= MAX_SI_LEN) {
++            image_size += pad(fd_img, MAX_SI_LEN);
++        } else {
+             fprintf(out, " failed!\n");
+             fprintf(err, "System_Info structure is too large (%d)!\n", sizeof(System_Info));
+             return 1;
+-        } else
+-            image_size += pad(fd_img, MAX_SI_LEN);
++        }
++    }
+ 
+     // Initialize the Boot_Map in System_Info
+-    si.bm.n_cpus   = CONFIG.n_cpus; // can be adjusted by SETUP in some machines
++    System_Info si;
++    si.bm.n_cpus   = CONFIG.n_cpus;     // can be adjusted by SETUP in some machines
+     si.bm.mem_base = CONFIG.mem_base;
+     si.bm.mem_top  = CONFIG.mem_top;
+-    si.bm.io_base  = 0; // will be adjusted by SETUP
+-    si.bm.io_top   = 0; // will be adjusted by SETUP
++    si.bm.mio_base = CONFIG.mio_base;   // can be adjusted by SETUP in some machines
++    si.bm.mio_top  = CONFIG.mio_top;    // can be adjusted by SETUP in some machines
+     si.bm.node_id  = CONFIG.node_id;
+     si.bm.space_x  = CONFIG.space_x;
+     si.bm.space_y  = CONFIG.space_y;
+     si.bm.space_z  = CONFIG.space_z;
++
++    fprintf(out, "\nsi.bm.n_cpus %u", si.bm.n_cpus);
++    fprintf(out, "\nsi.bm.mem_base %u", si.bm.mem_base);
++    fprintf(out, "\nsi.bm.mem_top %u", si.bm.mem_top);
++    fprintf(out, "\nsi.bm.mio_base %u", si.bm.mio_base);
++    fprintf(out, "\nsi.bm.mio_top %u", si.bm.mio_top);
++    fprintf(out, "\nsi.bm.node_id %u", si.bm.node_id);
++    fprintf(out, "\nsi.bm.space_x %u", si.bm.space_x);
++    fprintf(out, "\nsi.bm.space_y %u", si.bm.space_y);
++    fprintf(out, "\nsi.bm.space_z %u", si.bm.space_z);
++
+     for(unsigned int i = 0; i < 8; i++)
+         si.bm.uuid[i]  = CONFIG.uuid[i];
+ 
+@@ -256,8 +273,42 @@ int main(int argc, char **argv)
+ 
+     // Add System_Info
+     if(need_si) {
+-        fprintf(out, "    Adding system info:");
+-        if(lseek(fd_img, boot_size, SEEK_SET) < 0) {
++        unsigned int si_offset = boot_size;
++        fprintf(out, "    Adding system info");
++        if(si_in_setup) {
++            fprintf(out, " to SETUP:");
++            struct stat stat;
++            if(fstat(fd_img, &stat) < 0)  {
++                fprintf(out, " failed! (stat)\n");
++                return 0;
++            }
++            char * buffer = (char *) malloc(stat.st_size);
++            if(!buffer) {
++                fprintf(out, " failed! (malloc)\n");
++                return 0;
++            }
++            memset(buffer, '\1', stat.st_size);
++            lseek(fd_img, 0, SEEK_SET);
++            if(read(fd_img, buffer, stat.st_size) < 0) {
++                fprintf(out, " failed! (read)\n");
++                free(buffer);
++                return 0;
++            }
++
++            char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
++            char * setup_si = reinterpret_cast<char *>(memmem(buffer, stat.st_size, placeholder, strlen(placeholder)));
++            if(setup_si) {
++                si_offset = setup_si - buffer;
++            } else {
++                fprintf(out, " failed! (SETUP does not contain System_Info placeholder)\n");
++                free(buffer);
++                return 0;
++            }
++        } else {
++            fprintf(out, " to image:");
++            si_offset = boot_size;
++        }
++        if(lseek(fd_img, si_offset, SEEK_SET) < 0) {
+             fprintf(err, "Error: can't seek the boot image!\n");
+             return 1;
+         }
+@@ -279,7 +330,7 @@ int main(int argc, char **argv)
+     }
+     fprintf(out, " done.\n");
+ 
+-    //Finish
++    // Finish
+     close(fd_img);
+     fprintf(out, "\n  Image successfully generated (%d bytes)!\n\n", image_size);
+ 
+@@ -400,7 +451,7 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
+         fprintf(err, "Error: no valid MEM_BASE in configuration!\n");
+         return false;
+     }
+-    cfg->mem_base = strtol(token, 0, 16);
++    cfg->mem_base = strtoll(token, 0, 16);
+ 
+     // Memory Top
+     if(fgets(line, 256, cfg_file) != line) {
+@@ -412,7 +463,31 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
+         fprintf(err, "Error: no valid MEM_TOP in configuration!\n");
+         return false;
+     }
+-    cfg->mem_top=strtol(token, 0, 16);
++    cfg->mem_top = strtoll(token, 0, 16);
++
++    // I/O Base
++    if(fgets(line, 256, cfg_file) != line) {
++        fprintf(err, "Error: failed to read MIO_BASE from configuration file!\n");
++        return false;
++    }
++    token = strtok(line, "=");
++    if(strcmp(token, "MIO_BASE") || !(token = strtok(NULL, "\n"))) {
++        fprintf(err, "Error: no valid MIO_BASE in configuration!\n");
++        return false;
++    }
++    cfg->mio_base = strtoll(token, 0, 16);
++
++    // I/O Top
++    if(fgets(line, 256, cfg_file) != line) {
++        fprintf(err, "Error: failed to read MIO_TOP from configuration file!\n");
++        return false;
++    }
++    token = strtok(line, "=");
++    if(strcmp(token, "MIO_TOP") || !(token = strtok(NULL, "\n"))) {
++        fprintf(err, "Error: no valid MIO_TOP in configuration!\n");
++        return false;
++    }
++    cfg->mio_top = strtoll(token, 0, 16);
+ 
+     // Boot Length Min
+     if(fgets(line, 256, cfg_file) != line)
+@@ -474,9 +549,9 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
+     if(!put_number(fd, static_cast<T>(si->bm.mem_top)))
+         return false;
+ 
+-    if(!put_number(fd, static_cast<T>(0))) // io_base
++    if(!put_number(fd, static_cast<T>(si->bm.mio_base)))
+         return false;
+-    if(!put_number(fd, static_cast<T>(0))) // io_top
++    if(!put_number(fd, static_cast<T>(si->bm.mio_top)))
+         return false;
+ 
+     if(!put_number(fd, si->bm.node_id))
+@@ -512,7 +587,7 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
+ //=============================================================================
+ bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
+ {
+-    if (!strcmp(mach, "pc")) { // PC
++    if(!strcmp(mach, "pc")) { // PC
+         const unsigned int floppy_size   = 1474560;
+         const unsigned int secrets_offset   = CONFIG.boot_length_min - 6;
+         const unsigned short boot_id        = 0xaa55;
+@@ -552,7 +627,7 @@ bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
+         char key_string[] = ":020000040027D3\r\n:0CFFD400FFFFFFEF000000000000200015\r\n:00000001FF\r\n"; // Bootloader Disabled
+         const int key_offset = -strlen(":00000001FF\r\n");
+ 
+-        // Write key string to unlock epos
++        // Write key string to unlock EPOS
+         if(lseek(fd,key_offset,SEEK_END) < 0) {
+             fprintf(err, "Error: can't seek the boot image!\n");
+             return false;
diff --git a/docs/diff_edf.txt b/docs/diff_edf.txt
new file mode 100644
index 0000000..776cfeb
--- /dev/null
+++ b/docs/diff_edf.txt
@@ -0,0 +1,3065 @@
+diff --git a/app/hello/hello.cc b/app/hello/hello.cc
+index 40c7c05..c935003 100644
+--- a/app/hello/hello.cc
++++ b/app/hello/hello.cc
+@@ -1,12 +1,36 @@
+ #include <utility/ostream.h>
++#include <time.h>
+ 
+ using namespace EPOS;
+ 
+ OStream cout;
+ 
++int __attribute__((optimize("O0"))) dummy(int n) {
++    long long int a = 0;
++    for (int i = 0; i < n; i++) {
++        for (int j = 0; j < n; j++) {
++            a += i*j;
++        }
++    }
++    return a;
++}
++
++static unsigned ITERATIONS = 1000;
+ int main()
+ {
+-    cout << "Hello world!" << endl;
+-
++    Chronometer chron;
++    unsigned chron_freq = chron.frequency();
++    unsigned alarm_freq = Alarm::frequency();
++    cout << "Chron Frequency: " << chron_freq << endl;
++    cout << "Alarm Frequency: " << alarm_freq << endl;
++    unsigned int RESCALE = chron_freq / alarm_freq;
++    chron.reset();
++    chron.start();
++    for (int i = 0; i < ITERATIONS; i++) {
++        dummy(900);
++    }
++    chron.stop();
++    unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
++    cout << "T=" << avg << endl; 
+     return 0;
+ }
+diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
+index 6661b46..9b52d33 100644
+--- a/app/hello/hello_traits.h
++++ b/app/hello/hello_traits.h
+@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
+     static const bool trace_idle = hysterically_debugged;
+     static const bool simulate_capacity = false;
+ 
+-    static const bool preemptive = true;
++    typedef FCFS Criterion;
+     static const unsigned int QUANTUM = 10000; // us
+ };
+ 
+diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
+index 6661b46..ea0ed11 100644
+--- a/app/philosophers_dinner/philosophers_dinner_traits.h
++++ b/app/philosophers_dinner/philosophers_dinner_traits.h
+@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
+     static const bool trace_idle = hysterically_debugged;
+     static const bool simulate_capacity = false;
+ 
+-    static const bool preemptive = true;
++    typedef EDF Criterion;
+     static const unsigned int QUANTUM = 10000; // us
+ };
+ 
+diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
+index 6661b46..d1ca6d5 100644
+--- a/app/producer_consumer/producer_consumer_traits.h
++++ b/app/producer_consumer/producer_consumer_traits.h
+@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
+     static const bool trace_idle = hysterically_debugged;
+     static const bool simulate_capacity = false;
+ 
+-    static const bool preemptive = true;
++    typedef RR Criterion;
+     static const unsigned int QUANTUM = 10000; // us
+ };
+ 
+diff --git a/app/test_edf/makefile b/app/test_edf/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/test_edf/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/test_edf/test_edf.cc b/app/test_edf/test_edf.cc
+new file mode 100644
+index 0000000..0bbba9e
+--- /dev/null
++++ b/app/test_edf/test_edf.cc
+@@ -0,0 +1,82 @@
++// Description:
++// In the current configuration, we have
++//  preemptive = true
++//  dynamic = true
++//  timed = false
++// We've decided to turn off timed preemptions since that increased the time
++// system spent in between job execution without any benefits.
++
++// Test scenario:
++// Two tasks,
++//  A: cap=1000, deadline=2000
++//  B: cap=1500, deadline=3000
++// CPU_Usage = 100%; to avoid missing deadlines due to system execution, we actualy
++// have A and B execute a little bit faster than their caps.
++// The idea is to obtain the following timeline:
++//
++// 0000-1000: A runs and finishes (wait_next())
++// 1000-2000: B runs until A's alarm (50 leftover)
++// 2000-2500: 300 < 400, so B runs and finishes (wait_next())
++// 2500-3000: A runs until B's alarm (50 leftover)
++// 3000-3500: 400 < 600, so A runs and finishes (wait_next())
++// 3500-4000: B runs until A's alarm (100 leftover)
++// Here, in practice, A runs before B due to the reschedule provoked by A's alarm (choose() will insert B at tail and so A will be returned from remove_head())
++// 4000-5000: B continues and finishes (wait_next())
++// 5000-6000: A runs and finishes (wait_next())
++// Then, the system repeats (at every 6000 ticks we reset _priority = _period to avoid overflow)
++
++// Observations:
++// The EDF time unit is Alarm::Tick
++
++#include <utility/ostream.h>
++#include <machine/display.h>
++#include <architecture.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++static const unsigned DEADLINE[] = {
++    2000,
++    3000,
++};
++
++int __attribute__((optimize("O0"))) work(int n) {
++    EPOS::S::CPU::int_enable(); // Join makes so that Task_A starts executing with interrupts disabled.
++    cout << "Begin: " << ((n == 0) ? 'A' : 'B') << ", Prio=" << Periodic_Thread::self()->priority() << " [" << Alarm::elapsed() << "]" << endl;
++    while (Alarm::elapsed() < 15000) {
++        unsigned last_time = Alarm::elapsed();
++        unsigned tot = 0;
++        while (tot < DEADLINE[n]/2 - 50) { // -50 to allow for system time
++            EPOS::S::CPU::int_disable();
++            if (Alarm::elapsed() - last_time < 500) // we might be interrupted, so only add if we werent
++                tot += Alarm::elapsed() - last_time;
++            last_time = Alarm::elapsed();
++            EPOS::S::CPU::int_enable();
++        }
++        cout << "End: " << ((n == 0) ? 'A' : 'B') << ", Prio=" << Periodic_Thread::self()->priority() << " [" << Alarm::elapsed() << "]" << endl;
++        Periodic_Thread::wait_next();
++        cout << "Begin: " << ((n == 0) ? 'A' : 'B') << ", Prio=" << Periodic_Thread::self()->priority() << " [" << Alarm::elapsed() << "]" << endl;
++    }
++    return 0;
++}
++
++Periodic_Thread * task[2];
++
++int main()
++{
++    Display::clear();;
++
++    task[0] = new Periodic_Thread(DEADLINE[0], &work, 0);
++    task[1] = new Periodic_Thread(DEADLINE[1], &work, 1);
++
++    // main will halt forever
++    for (int i = 0; i < 2; i++)
++        task[i]->join();
++
++    for (int i = 0; i < 2; i++)
++        delete task[i];
++
++    return 0;
++}
+diff --git a/app/test_edf/test_edf_traits.h b/app/test_edf/test_edf_traits.h
+new file mode 100644
+index 0000000..cda0daa
+--- /dev/null
++++ b/app/test_edf/test_edf_traits.h
+@@ -0,0 +1,157 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = true;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    // typedef RR Criterion;
++    // typedef FCFS Criterion;
++    typedef EDF Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++
++__END_SYS
++
++#endif
+diff --git a/app/test_worst_fit/makefile b/app/test_worst_fit/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/test_worst_fit/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/test_worst_fit/test_worst_fit.cc b/app/test_worst_fit/test_worst_fit.cc
+new file mode 100644
+index 0000000..0f20446
+--- /dev/null
++++ b/app/test_worst_fit/test_worst_fit.cc
+@@ -0,0 +1,47 @@
++// Description:
++// The Heap reaches main() containing two elements: E1 and E2.
++//    E1 begun from &_end to BOOT_STACK, but now has 32904 less bytes due to the allocations
++//  of System::init().
++//    E2 is still untouched and ranges from MEM_TOP to MEM_TOP-STACK_SIZE.
++// E1 is way larger than E2.
++//    In this test program, we allocate almost all of E1 so that Worst-Fit has to reach for E2
++//  in its second allocation (line 30).
++// For comparision purposes, we print how First Fit would have handled each allocation.
++
++#include <utility/ostream.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++// for Single System Heap
++static const int REMAINING_SYS_HEAP = 134201064 - 32904 - 16*1024;
++// for Application Heap
++static const int REMAINING_APP_HEAP = 16777216;
++
++enum {
++    TEST_SINGLE_HEAP,
++    TEST_MULTI_HEAP,
++};
++
++static const unsigned int MODE = TEST_MULTI_HEAP;
++static const unsigned int REMAINING = (MODE==TEST_MULTI_HEAP)? REMAINING_APP_HEAP : REMAINING_SYS_HEAP;
++
++// TODO: test only multi-heap and do it right
++
++char * alloc(int bytes) {
++    return new char[bytes];
++}
++
++int main()
++{
++    // terminal output is important after the following line
++    cout << "Testing Worst-Fit..." << endl;
++
++    // leave less than a stack worth of memory on E1
++    alloc(REMAINING - 8*1024);
++    // this should go to E2
++    alloc(16); // will alloc 16+4 due to size
++
++    return 0;
++}
+diff --git a/app/test_worst_fit/test_worst_fit_traits.h b/app/test_worst_fit/test_worst_fit_traits.h
+new file mode 100644
+index 0000000..e8d912b
+--- /dev/null
++++ b/app/test_worst_fit/test_worst_fit_traits.h
+@@ -0,0 +1,156 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = true;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = true;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    // typedef RR Criterion;
++    typedef FCFS Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++
++__END_SYS
++
++#endif
+diff --git a/img/makefile b/img/makefile
+index f048773..0799121 100644
+--- a/img/makefile
++++ b/img/makefile
+@@ -83,7 +83,7 @@ endif
+ 
+ debug:		$(IMAGE)
+ ifeq ($(NODES),1)
+-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
++		$(EMULATOR)$(IMAGE) &
+ 		$(DEBUGGER)
+ else
+ 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
+@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
+ 		@echo "Running $(APPLICATION) ..."
+ posrun_$(APPLICATION):
+ 		@echo "done!"
+-		
++
+ FORCE:
+diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
+index 1c809b2..1fac9b9 100644
+--- a/include/architecture/rv32/rv32_mmu.h
++++ b/include/architecture/rv32/rv32_mmu.h
+@@ -117,7 +117,6 @@ public:
+ 
+     static void free(Phy_Addr addr, unsigned int n = 1) {
+         db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
+-
+         // No unaligned addresses if the CPU doesn't support it
+         assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
+ 
+diff --git a/include/memory.h b/include/memory.h
+index b2f8be5..e6802aa 100644
+--- a/include/memory.h
++++ b/include/memory.h
+@@ -43,7 +43,7 @@ public:
+     typedef MMU::Flags Flags;
+ 
+ public:
+-    Segment(unsigned int bytes, const Color & color = Color::WHITE, const Flags & flags = Flags::APP);
++    Segment(unsigned int bytes, const Flags & flags = Flags::APP);
+     Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
+     ~Segment();
+ 
+diff --git a/include/process.h b/include/process.h
+index 5978227..4c00514 100644
+--- a/include/process.h
++++ b/include/process.h
+@@ -7,6 +7,7 @@
+ #include <machine.h>
+ #include <utility/queue.h>
+ #include <utility/handler.h>
++#include <scheduler.h>
+ 
+ extern "C" { void __exit(); }
+ 
+@@ -16,12 +17,14 @@ class Thread
+ {
+     friend class Init_First;            // context->load()
+     friend class Init_System;           // for init() on CPU != 0
++    friend class Scheduler<Thread>;     // for link()
+     friend class Synchronizer_Common;   // for lock() and sleep()
+     friend class Alarm;                 // for lock()
+     friend class System;                // for init()
++    friend class IC;                    // for link() for priority ceiling
+ 
+ protected:
+-    static const bool preemptive = Traits<Thread>::preemptive;
++    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
+     static const bool reboot = Traits<System>::reboot;
+ 
+     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
+@@ -40,26 +43,26 @@ public:
+         FINISHING
+     };
+ 
+-    // Thread Priority
+-    typedef unsigned int Priority;
++    // Thread Scheduling Criterion
++    typedef Traits<Thread>::Criterion Criterion;
+     enum {
+-        MAIN   = 0,
+-        HIGH   = 1,
+-        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 4,
+-        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
+-        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2
++        HIGH    = Criterion::HIGH,
++        NORMAL  = Criterion::NORMAL,
++        LOW     = Criterion::LOW,
++        MAIN    = Criterion::MAIN,
++        IDLE    = Criterion::IDLE
+     };
+ 
+     // Thread Queue
+-    typedef Ordered_Queue<Thread, Priority> Queue;
++    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
+ 
+     // Thread Configuration
+     struct Configuration {
+-        Configuration(const State & s = READY, const Priority & p = NORMAL, unsigned int ss = STACK_SIZE)
+-        : state(s), priority(p), stack_size(ss) {}
++        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
++        : state(s), criterion(c), stack_size(ss) {}
+ 
+         State state;
+-        Priority priority;
++        Criterion criterion;
+         unsigned int stack_size;
+     };
+ 
+@@ -78,8 +81,8 @@ public:
+ 
+     int join();
+     void pass();
+-    void suspend() { suspend(false); }
+-    void resume() { resume(false); }
++    void suspend();
++    void resume();
+ 
+     static Thread * volatile self() { return running(); }
+     static void yield();
+@@ -89,15 +92,15 @@ protected:
+     void constructor_prologue(unsigned int stack_size);
+     void constructor_epilogue(const Log_Addr & entry, unsigned int stack_size);
+ 
+-    static Thread * volatile running() { return _running; }
++    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
++    Queue::Element * link() { return &_link; }
++
++    static Thread * volatile running() { return _scheduler.chosen(); }
+ 
+     static void lock() { CPU::int_disable(); }
+     static void unlock() { CPU::int_enable(); }
+     static bool locked() { return CPU::int_disabled(); }
+ 
+-    void suspend(bool locked);
+-    void resume(bool unpreemptive);
+-
+     static void sleep(Queue * q);
+     static void wakeup(Queue * q);
+     static void wakeup_all(Queue * q);
+@@ -105,7 +108,7 @@ protected:
+     static void reschedule();
+     static void time_slicer(IC::Interrupt_Id interrupt);
+ 
+-    static void dispatch(Thread * prev, Thread * next);
++    static void dispatch(Thread * prev, Thread * next, bool charge = true);
+ 
+     static int idle();
+ 
+@@ -122,11 +125,7 @@ protected:
+ 
+     static volatile unsigned int _thread_count;
+     static Scheduler_Timer * _timer;
+-
+-private:
+-    static Thread * volatile _running;
+-    static Queue _ready;
+-    static Queue _suspended;
++    static Scheduler<Thread> _scheduler;
+ };
+ 
+ 
+@@ -141,7 +140,7 @@ inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
+ 
+ template<typename ... Tn>
+ inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.priority)
++: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
+ {
+     constructor_prologue(conf.stack_size);
+     _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
+@@ -149,6 +148,22 @@ inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ...
+ }
+ 
+ 
++// A Java-like Active Object
++class Active: public Thread
++{
++public:
++    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
++    virtual ~Active() {}
++
++    virtual int run() = 0;
++
++    void start() { resume(); }
++
++private:
++    static int entry(Active * runnable) { return runnable->run(); }
++};
++
++
+ // An event handler that triggers a thread (see handler.h)
+ class Thread_Handler : public Handler
+ {
+diff --git a/include/real-time.h b/include/real-time.h
+new file mode 100644
+index 0000000..f61c11b
+--- /dev/null
++++ b/include/real-time.h
+@@ -0,0 +1,122 @@
++// EPOS Real-time Declarations
++
++#ifndef __real_time_h
++#define __real_time_h
++
++#include <utility/handler.h>
++#include <utility/math.h>
++#include <utility/convert.h>
++#include <time.h>
++#include <process.h>
++#include <synchronizer.h>
++
++__BEGIN_SYS
++
++// Aperiodic Thread
++typedef Thread Aperiodic_Thread;
++
++// Periodic threads are achieved by programming an alarm handler to invoke
++// p() on a control semaphore after each job (i.e. task activation). Base
++// threads are created in BEGINNING state, so the scheduler won't dispatch
++// them before the associate alarm and semaphore are created. The first job
++// is dispatched by resume() (thus the _state = SUSPENDED statement)
++
++// Periodic Thread
++class Periodic_Thread: public Thread
++{
++public:
++    // enum {
++    //     SAME,
++    //     NOW,
++    //     UNKNOWN,
++    //     ANY
++    // };
++
++protected:
++    // Alarm Handler for periodic threads under static scheduling policies
++    class Static_Handler: public Semaphore_Handler
++    {
++    public:
++        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
++        ~Static_Handler() {}
++    };
++
++    // Alarm Handler for periodic threads under dynamic scheduling policies
++    class Dynamic_Handler: public Semaphore_Handler
++    {
++    public:
++        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
++        ~Dynamic_Handler() {}
++
++        void operator()() {
++            _thread->criterion().update();
++
++            Semaphore_Handler::operator()();
++        }
++
++    private:
++        Periodic_Thread * _thread;
++    };
++
++    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
++
++public:
++    // struct Configuration: public Thread::Configuration {
++    //     Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
++    //     : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
++
++    //     Microsecond period;
++    //     Microsecond deadline;
++    //     Microsecond capacity;
++    //     Microsecond activation;
++    //     unsigned int times;
++    // };
++
++public:
++    // template<typename ... Tn>
++    // Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
++    // : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
++    //   _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
++    typedef Alarm::Tick Tick;
++
++    template<typename ... Tn>
++    Periodic_Thread(const Tick & t, int (* entry)(Tn ...), Tn ... an)
++    : Thread(Thread::Configuration(SUSPENDED, Criterion(t)), entry, an ...),
++      _semaphore(0), _handler(&_semaphore, this), _alarm(t * Alarm::timer_period(), &_handler, INFINITE) { resume(); }
++
++    // template<typename ... Tn>
++    // Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
++    // : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
++    //   _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
++    //     if((conf.state == READY) || (conf.state == RUNNING)) {
++    //         _state = SUSPENDED;
++    //         resume();
++    //     } else
++    //         _state = conf.state;
++    // }
++
++    const Microsecond & period() const { return _alarm.period(); }
++    void period(const Microsecond & p) { _alarm.period(p); }
++
++    static volatile bool wait_next() {
++        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
++
++        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
++
++        if(t->_alarm.times())
++            t->_semaphore.p();
++
++        return t->_alarm.times();
++    }
++
++protected:
++    Semaphore _semaphore;
++    Handler _handler;
++    Alarm _alarm;
++};
++
++typedef Periodic_Thread::Configuration RTConf;
++
++__END_SYS
++
++#endif
+diff --git a/include/scheduler.h b/include/scheduler.h
+new file mode 100644
+index 0000000..a1832a6
+--- /dev/null
++++ b/include/scheduler.h
+@@ -0,0 +1,174 @@
++// EPOS Scheduler Component Declarations
++
++#ifndef __scheduler_h
++#define __scheduler_h
++
++#include <architecture/cpu.h>
++#include <architecture/pmu.h>
++#include <architecture/tsc.h>
++#include <utility/scheduling.h>
++#include <utility/math.h>
++#include <utility/convert.h>
++
++__BEGIN_SYS
++
++// All scheduling criteria, or disciplines, must define operator int() with
++// the semantics of returning the desired order of a given object within the
++// scheduling list
++class Scheduling_Criterion_Common
++{
++    friend class _SYS::Thread;
++    friend class _SYS::Periodic_Thread;
++    friend class _SYS::RT_Thread;
++    friend class _SYS::Clerk<System>;         // for _statistics
++
++public:
++    // Priorities
++    enum : int {
++        MAIN   = 0,
++        HIGH   = 1,
++        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
++        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2,
++        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
++    };
++
++    // Constructor helpers
++    enum : unsigned int {
++        SAME        = 0,
++        NOW         = 0,
++        UNKNOWN     = 0,
++        ANY         = -1U
++    };
++
++    // Policy types
++    enum : int {
++        PERIODIC    = HIGH,
++        APERIODIC   = NORMAL,
++        SPORADIC    = NORMAL
++    };
++
++    // Policy traits
++    static const bool timed = false;
++    static const bool dynamic = false;
++    static const bool preemptive = true;
++    static const bool collecting = false;
++    static const bool charging = false;
++    static const bool awarding = false;
++    static const bool migrating = false;
++    static const bool track_idle = false;
++    static const bool task_wide = false;
++    static const bool cpu_wide = false;
++    static const bool system_wide = false;
++    static const unsigned int QUEUES = 1;
++
++    // Runtime Statistics (for policies that don't use any; thats why its a union)
++    union Statistics {
++        // Thread Execution Time
++        TSC::Time_Stamp thread_execution_time;  // accumulated thread execution time
++        TSC::Time_Stamp last_thread_dispatch;   // time stamp of last dispatch
++
++        // Deadline Miss count - Used By Clerk
++        Alarm * alarm_times;                    // pointer to RT_Thread private alarm (for monitoring purposes)
++        unsigned int finished_jobs;             // number of finished jobs given by the number of times alarm->p() was called for this thread
++        unsigned int missed_deadlines;          // number of missed deadlines given by the number of finished jobs (finished_jobs) minus the number of dispatched jobs (alarm_times->times)
++
++        // CPU Execution Time (capture ts)
++        static TSC::Time_Stamp _cpu_time[Traits<Build>::CPUS];              // accumulated CPU time in the current hyperperiod for each CPU
++        static TSC::Time_Stamp _last_dispatch_time[Traits<Build>::CPUS];    // time Stamp of last dispatch in each CPU
++        static TSC::Time_Stamp _last_activation_time;                       // global time stamp of the last heuristic activation
++    };
++
++protected:
++    Scheduling_Criterion_Common() {}
++
++public:
++    const Microsecond period() { return 0;}
++    void period(const Microsecond & p) {}
++
++    unsigned int queue() const { return 0; }
++    void queue(unsigned int q) {}
++
++    bool update() { return false; }
++
++    bool collect(bool end = false) { return false; }
++    bool charge(bool end = false) { return true; }
++    bool award(bool end = false) { return true; }
++
++    volatile Statistics & statistics() { return _statistics; }
++
++    static void init() {}
++
++protected:
++    Statistics _statistics;
++};
++
++// Priority (static and dynamic)
++class Priority: public Scheduling_Criterion_Common
++{
++    friend class _SYS::Thread;
++    friend class _SYS::Periodic_Thread;
++    friend class _SYS::RT_Thread;
++
++public:
++    template <typename ... Tn>
++    Priority(int p = NORMAL, Tn & ... an): _priority(p) {}
++
++    operator const volatile int() const volatile { return _priority; }
++
++protected:
++    volatile int _priority;
++};
++
++// Round-Robin
++class RR: public Priority
++{
++public:
++    static const bool timed = true;
++    static const bool dynamic = false;
++    static const bool preemptive = true;
++
++public:
++    template <typename ... Tn>
++    RR(int p = NORMAL, Tn & ... an): Priority(p) {}
++};
++
++// First-Come, First-Served (FIFO)
++class FCFS: public Priority
++{
++public:
++    static const bool timed = false;
++    static const bool dynamic = false;
++    static const bool preemptive = false;
++
++public:
++    template <typename ... Tn>
++    FCFS(int p = NORMAL, Tn & ... an);
++};
++
++// Earliest Deadline First (EDF)
++class EDF: public Priority
++{
++public:
++    static const bool timed = false;
++    static const bool dynamic = true;
++    static const bool preemptive = true;
++
++    typedef int Tick;
++
++public:
++    EDF(int p = NORMAL): Priority(p), _period(p) {}
++    
++    bool update() {
++        if ((_priority % 6000) < 5)
++            _priority = _period;
++        else
++            _priority += _period;
++        return false;
++    }
++private:
++    Tick _period;
++};
++
++__END_SYS
++
++#endif
+diff --git a/include/time.h b/include/time.h
+index a024cb7..ff88b01 100644
+--- a/include/time.h
++++ b/include/time.h
+@@ -31,6 +31,7 @@ class Alarm
+ {
+     friend class System;                        // for init()
+     friend class Alarm_Chronometer;             // for elapsed()
++    friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
+     friend class FCFS;                          // for ticks() and elapsed()
+ 
+ private:
+@@ -47,15 +48,15 @@ public:
+     void reset();
+ 
+     static Hertz frequency() { return _timer->frequency(); }
++    static Microsecond timer_period() { return 1000000 / frequency(); }
++    static volatile Tick & elapsed() { return _elapsed; }
+ 
+     static void delay(const Microsecond & time);
+ 
+ private:
+-    static void init();
++    unsigned int times() const { return _times; }
+ 
+-    static volatile Tick & elapsed() { return _elapsed; }
+ 
+-    static Microsecond timer_period() { return 1000000 / frequency(); }
+     static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
+ 
+     static void lock();
+@@ -63,6 +64,8 @@ private:
+ 
+     static void handler(IC::Interrupt_Id i);
+ 
++    static void init();
++
+ private:
+     Microsecond _time;
+     Handler * _handler;
+@@ -102,8 +105,6 @@ public:
+     void stop() { lap(); }
+ 
+     Microsecond read() { return ticks() * 1000000 / frequency(); }
+-
+-private:
+     Time_Stamp ticks() {
+         if(_start == 0)
+             return 0;
+@@ -112,6 +113,8 @@ private:
+         return _stop - _start;
+     }
+ 
++private:
++
+ private:
+     TSC tsc;
+     Time_Stamp _start;
+diff --git a/include/utility/heap.h b/include/utility/heap.h
+index f377454..57fd84b 100644
+--- a/include/utility/heap.h
++++ b/include/utility/heap.h
+@@ -18,6 +18,9 @@ protected:
+ public:
+     using Grouping_List<char>::empty;
+     using Grouping_List<char>::size;
++    using Grouping_List<char>::search_decrementing;
++    using Grouping_List<char>::find_first;
++    using Grouping_List<char>::find_worst;
+ 
+     Heap() {
+         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
+@@ -30,8 +33,7 @@ public:
+     }
+ 
+     void * alloc(unsigned int bytes) {
+-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
+-
++        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
+         if(!bytes)
+             return 0;
+ 
+@@ -45,6 +47,8 @@ public:
+         if(bytes < sizeof(Element))
+             bytes = sizeof(Element);
+ 
++        db<Heaps>(TRC) << "First Fit: " << find_first(bytes) << endl;
++        db<Heaps>(TRC) << "Worst Fit: " << find_worst(bytes) << endl;
+         Element * e = search_decrementing(bytes);
+         if(!e) {
+             out_of_memory();
+@@ -65,7 +69,7 @@ public:
+     void free(void * ptr, unsigned int bytes) {
+         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
+ 
+-        if(ptr && (bytes >= sizeof(Element))) {
++        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
+             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
+             Element * m1, * m2;
+             insert_merging(e, &m1, &m2);
+diff --git a/include/utility/list.h b/include/utility/list.h
+index ccc8954..eca1174 100644
+--- a/include/utility/list.h
++++ b/include/utility/list.h
+@@ -1348,7 +1348,7 @@ public:
+ 
+     Element * search_size(unsigned int s) {
+         Element * e = head();
+-        if(sizeof(Object_Type) < sizeof(Element))
++        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
+             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
+         else
+             for(; e && (e->size() < s); e = e->next());
+@@ -1381,7 +1381,7 @@ public:
+         print_head();
+         print_tail();
+ 
+-        Element * e = search_size(s);
++        Element * e = find_worst(s);
+         if(e) {
+             e->shrink(s);
+             _grouped_size -= s;
+@@ -1392,6 +1392,33 @@ public:
+         return e;
+     }
+ 
++    // Used by Heap/Worst-Fit
++    // for empty lists, return 0
++    // for nonempty lists,
++    //      return 0 if there is no element big enough to fit s
++    //      return the element with biggest size otherwise
++    // precons:
++    //  1. s >= sizeof(Element) [s >= 16]
++    Element * find_worst(unsigned int s) {
++        Element * max = 0;
++        unsigned max_size = 0;
++        for(Element * e = head(); e; e = e->next()) {
++            if (e->size() > max_size) {
++                max_size = e->size();
++                max = e;
++            }
++        }
++
++        if (max_size < s)
++            return 0;
++
++        return max;
++    }
++
++    Element * find_first(unsigned int s) {
++        return search_size(s);
++    }
++
+ private:
+     Element * search_left(const Object_Type * obj) {
+         Element * e = head();
+diff --git a/makedefs b/makedefs
+index 21674d9..9275107 100644
+--- a/makedefs
++++ b/makedefs
+@@ -103,7 +103,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
+ pc_AS_FLAGS		:= --32
+ pc_LD_FLAGS		:= -m elf_i386
+ pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
+-pc_DEBUGGER		:= gdb
++pc_DEBUGGER		:= gdb -tui
+ pc_FLASHER		:=
+ pc_MAGIC		:= --nmagic
+ pc_CODE_NAME		:= .init
+@@ -254,7 +254,7 @@ TLDFLAGS	:= -m32
+ ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
+ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
++ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
+ ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
+ 
+ # Tools and flags to compile the system
+@@ -315,7 +315,7 @@ TEE		:= tee
+ ifndef DISPLAY
+ TERM        := sh -c
+ else
+-TERM        := xterm -e
++TERM        := konsole -e
+ endif
+ 
+ TOUCH		:= touch
+diff --git a/notes/diff_wf.txt b/notes/diff_wf.txt
+new file mode 100644
+index 0000000..71c8f8d
+--- /dev/null
++++ b/notes/diff_wf.txt
+@@ -0,0 +1,510 @@
++diff --git a/app/test/makefile b/app/test/makefile
++new file mode 100644
++index 0000000..8a6578a
++--- /dev/null
+++++ b/app/test/makefile
++@@ -0,0 +1,17 @@
+++# EPOS Application Makefile
+++
+++include ../../makedefs
+++
+++all: install
+++
+++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+++
+++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+++		$(ACC) $(ACCFLAGS) -o $@ $<
+++
+++install: $(APPLICATION)
+++		$(INSTALL) $(APPLICATION) $(IMG)
+++
+++clean:
+++		$(CLEAN) *.o $(APPLICATION)
++diff --git a/app/test/notes_heap.txt b/app/test/notes_heap.txt
++new file mode 100644
++index 0000000..a11a5a3
++--- /dev/null
+++++ b/app/test/notes_heap.txt
++@@ -0,0 +1,62 @@
+++Machine:
+++0x00020000k -> 128mb? (tah 128MB no traits)
+++
+++Heap:
+++tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
+++Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
+++- Alarm_Timer (20 bytes)
+++% Idle
+++- Thread (36 bytes)
+++- Stack (STACK_SIZE)
+++% Main
+++- Thread (36 bytes)
+++- Stack (STACK_SIZE)
+++- Scheduler_Timer(20 bytes)
+++Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
+++
+++Allocs:
+++MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
+++MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
+++MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
+++Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
+++Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
+++% Idle
+++Heap::alloc(this=0x80004064,bytes=36 (Thread)
+++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+++% Main
+++Heap::alloc(this=0x80004064,bytes=36 (Thread)
+++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+++Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
+++MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
+++Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
+++MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
+++Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
+++
+++Conclusoes:
+++Quando chegamos na main(),
+++
+++1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
+++2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
+++3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
+++4) A BOOT_STACK foi absorvida pela _heap
+++5) A _free esta vazia (size=0; _grouped_size=0)
+++6) So a _heap foi alocada em _free (em duas etapas)
+++7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
+++8) Tamanho inicial de _free=134201064
+++9) sizeof(Page) = 1 e pages(x) = x  
+++
+++Desafios:
+++A busca comeca em head e a insercao em tail?
+++Aglutinacao e insert na lista?
+++
+++Matheus:
+++explicar sequencia de inicializacao
+++onde esta bootstack?
+++onde eh inicializada a _free?
+++quantos elementos tem _free antes de construir a heap de sistema?
+++onde foram construidos?
+++qnt retorna pages? (sizeof no gdb)
+++algo foi alocado ah mais na MMU antes de criar a Heap?
+++
+++Teste:
+++So precisa mostrar o algoritmo skippando um bloco que cabe?
++\ No newline at end of file
++diff --git a/app/test/notes_mmu.txt b/app/test/notes_mmu.txt
++new file mode 100644
++index 0000000..1239a86
++--- /dev/null
+++++ b/app/test/notes_mmu.txt
++@@ -0,0 +1,3 @@
+++Desafios:
+++Em que momento liga paginacao na intel?
+++Como que liga paginacao no rv32?
++diff --git a/app/test/test.cc b/app/test/test.cc
++new file mode 100644
++index 0000000..4a473a9
++--- /dev/null
+++++ b/app/test/test.cc
++@@ -0,0 +1,34 @@
+++// Description:
+++// The Heap reaches main() containing two elements: E1 and E2.
+++//    E1 begun from &_end to BOOT_STACK, but now has 32904 less bytes due to the allocations
+++//  of System::init().
+++//    E2 is still untouched and ranges from MEM_TOP to MEM_TOP-STACK_SIZE.
+++// E1 is way larger than E2.
+++//    In this test program, we allocate almost all of E1 so that Worst-Fit has to reach for E2
+++//  in its second allocation (line 30).
+++// For comparision purposes, we print how First Fit would have handled each allocation.
+++
+++#include <utility/ostream.h>
+++
+++using namespace EPOS;
+++
+++OStream cout;
+++
+++static const int SIZE_OF_E1 = 134201064 - 32904 - 16*1024;
+++
+++char * alloc(int bytes) {
+++    return new char[bytes];
+++}
+++
+++int main()
+++{
+++    // terminal output is important after the following line
+++    cout << "Testing Worst-Fit..." << endl;
+++
+++    // leave less than a stack worth of memory on E1
+++    alloc(SIZE_OF_E1 - 8*1024);
+++    // this should go to E2
+++    alloc(16); // will alloc 16+4 due to size
+++
+++    return 0;
+++}
++diff --git a/app/test/test_traits.h b/app/test/test_traits.h
++new file mode 100644
++index 0000000..008c06f
++--- /dev/null
+++++ b/app/test/test_traits.h
++@@ -0,0 +1,155 @@
+++#ifndef __traits_h
+++#define __traits_h
+++
+++#include <system/config.h>
+++
+++__BEGIN_SYS
+++
+++// Build
+++template<> struct Traits<Build>: public Traits_Tokens
+++{
+++    // Basic configuration
+++    static const unsigned int MODE = LIBRARY;
+++    static const unsigned int ARCHITECTURE = RV32;
+++    static const unsigned int MACHINE = RISCV;
+++    static const unsigned int MODEL = SiFive_E;
+++    static const unsigned int CPUS = 1;
+++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+++
+++    // Default flags
+++    static const bool enabled = true;
+++    static const bool monitored = false;
+++    static const bool debugged = true;
+++    static const bool hysterically_debugged = false;
+++
+++    // Default aspects
+++    typedef ALIST<> ASPECTS;
+++};
+++
+++
+++// Utilities
+++template<> struct Traits<Debug>: public Traits<Build>
+++{
+++    static const bool error   = true;
+++    static const bool warning = true;
+++    static const bool info    = false;
+++    static const bool trace   = false;
+++};
+++
+++template<> struct Traits<Lists>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Spin>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Heaps>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++template<> struct Traits<Observers>: public Traits<Build>
+++{
+++    // Some observed objects are created before initializing the Display
+++    // Enabling debug may cause trouble in some Machines
+++    static const bool debugged = false;
+++};
+++
+++
+++// System Parts (mostly to fine control debugging)
+++template<> struct Traits<Boot>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Setup>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Init>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Framework>: public Traits<Build>
+++{
+++};
+++
+++template<> struct Traits<Aspect>: public Traits<Build>
+++{
+++    static const bool debugged = hysterically_debugged;
+++};
+++
+++
+++__END_SYS
+++
+++// Mediators
+++#include __ARCHITECTURE_TRAITS_H
+++#include __MACHINE_TRAITS_H
+++
+++__BEGIN_SYS
+++
+++
+++// API Components
+++template<> struct Traits<Application>: public Traits<Build>
+++{
+++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+++};
+++
+++template<> struct Traits<System>: public Traits<Build>
+++{
+++    static const unsigned int mode = Traits<Build>::MODE;
+++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+++
+++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+++
+++    static const bool reboot = true;
+++
+++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+++};
+++
+++template<> struct Traits<Task>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multitask;
+++};
+++
+++template<> struct Traits<Thread>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multithread;
+++    static const bool smp = Traits<System>::multicore;
+++    static const bool trace_idle = hysterically_debugged;
+++    static const bool simulate_capacity = false;
+++
+++    static const bool preemptive = true;
+++    static const unsigned int QUANTUM = 10000; // us
+++};
+++
+++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+++{
+++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+++};
+++
+++template<> struct Traits<Synchronizer>: public Traits<Build>
+++{
+++    static const bool enabled = Traits<System>::multithread;
+++};
+++
+++template<> struct Traits<Alarm>: public Traits<Build>
+++{
+++    static const bool visible = hysterically_debugged;
+++};
+++
+++
+++
+++__END_SYS
+++
+++#endif
++diff --git a/img/makefile b/img/makefile
++index f048773..0799121 100644
++--- a/img/makefile
+++++ b/img/makefile
++@@ -83,7 +83,7 @@ endif
++ 
++ debug:		$(IMAGE)
++ ifeq ($(NODES),1)
++-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
+++		$(EMULATOR)$(IMAGE) &
++ 		$(DEBUGGER)
++ else
++ 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
++@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
++ 		@echo "Running $(APPLICATION) ..."
++ posrun_$(APPLICATION):
++ 		@echo "done!"
++-		
+++
++ FORCE:
++diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
++index 1c809b2..59fe619 100644
++--- a/include/architecture/rv32/rv32_mmu.h
+++++ b/include/architecture/rv32/rv32_mmu.h
++@@ -105,6 +105,7 @@ public:
++                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
++         }
++         db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+++        kout << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
++ 
++         return phy;
++     };
++@@ -117,7 +118,7 @@ public:
++ 
++     static void free(Phy_Addr addr, unsigned int n = 1) {
++         db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
++-
+++        kout << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
++         // No unaligned addresses if the CPU doesn't support it
++         assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
++ 
++diff --git a/include/utility/heap.h b/include/utility/heap.h
++index f377454..0235644 100644
++--- a/include/utility/heap.h
+++++ b/include/utility/heap.h
++@@ -18,6 +18,9 @@ protected:
++ public:
++     using Grouping_List<char>::empty;
++     using Grouping_List<char>::size;
+++    using Grouping_List<char>::search_decrementing;
+++    using Grouping_List<char>::find_first;
+++    using Grouping_List<char>::find_worst;
++ 
++     Heap() {
++         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
++@@ -30,8 +33,8 @@ public:
++     }
++ 
++     void * alloc(unsigned int bytes) {
++-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
++-
+++        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
+++        kout << "Heap::alloc(this=" << this << ",bytes=" << bytes  << ")" << endl;
++         if(!bytes)
++             return 0;
++ 
++@@ -45,6 +48,8 @@ public:
++         if(bytes < sizeof(Element))
++             bytes = sizeof(Element);
++ 
+++        kout << "First Fit: " << find_first(bytes) << endl;
+++        kout << "Worst Fit: " << find_worst(bytes) << endl;
++         Element * e = search_decrementing(bytes);
++         if(!e) {
++             out_of_memory();
++@@ -65,11 +70,12 @@ public:
++     void free(void * ptr, unsigned int bytes) {
++         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
++ 
++-        if(ptr && (bytes >= sizeof(Element))) {
+++        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
++             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
++             Element * m1, * m2;
++             insert_merging(e, &m1, &m2);
++         }
+++        kout << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
++     }
++ 
++     static void typed_free(void * ptr) {
++diff --git a/include/utility/list.h b/include/utility/list.h
++index ccc8954..eca1174 100644
++--- a/include/utility/list.h
+++++ b/include/utility/list.h
++@@ -1348,7 +1348,7 @@ public:
++ 
++     Element * search_size(unsigned int s) {
++         Element * e = head();
++-        if(sizeof(Object_Type) < sizeof(Element))
+++        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
++             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
++         else
++             for(; e && (e->size() < s); e = e->next());
++@@ -1381,7 +1381,7 @@ public:
++         print_head();
++         print_tail();
++ 
++-        Element * e = search_size(s);
+++        Element * e = find_worst(s);
++         if(e) {
++             e->shrink(s);
++             _grouped_size -= s;
++@@ -1392,6 +1392,33 @@ public:
++         return e;
++     }
++ 
+++    // Used by Heap/Worst-Fit
+++    // for empty lists, return 0
+++    // for nonempty lists,
+++    //      return 0 if there is no element big enough to fit s
+++    //      return the element with biggest size otherwise
+++    // precons:
+++    //  1. s >= sizeof(Element) [s >= 16]
+++    Element * find_worst(unsigned int s) {
+++        Element * max = 0;
+++        unsigned max_size = 0;
+++        for(Element * e = head(); e; e = e->next()) {
+++            if (e->size() > max_size) {
+++                max_size = e->size();
+++                max = e;
+++            }
+++        }
+++
+++        if (max_size < s)
+++            return 0;
+++
+++        return max;
+++    }
+++
+++    Element * find_first(unsigned int s) {
+++        return search_size(s);
+++    }
+++
++ private:
++     Element * search_left(const Object_Type * obj) {
++         Element * e = head();
++diff --git a/makedefs b/makedefs
++index 21674d9..9275107 100644
++--- a/makedefs
+++++ b/makedefs
++@@ -103,7 +103,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
++ pc_AS_FLAGS		:= --32
++ pc_LD_FLAGS		:= -m elf_i386
++ pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
++-pc_DEBUGGER		:= gdb
+++pc_DEBUGGER		:= gdb -tui
++ pc_FLASHER		:=
++ pc_MAGIC		:= --nmagic
++ pc_CODE_NAME		:= .init
++@@ -254,7 +254,7 @@ TLDFLAGS	:= -m32
++ ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
++ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
++ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
++-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
+++ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
++ ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
++ 
++ # Tools and flags to compile the system
++@@ -315,7 +315,7 @@ TEE		:= tee
++ ifndef DISPLAY
++ TERM        := sh -c
++ else
++-TERM        := xterm -e
+++TERM        := konsole -e
++ endif
++ 
++ TOUCH		:= touch
++diff --git a/src/api/thread.cc b/src/api/thread.cc
++index fdd0583..12cb8e7 100644
++--- a/src/api/thread.cc
+++++ b/src/api/thread.cc
++@@ -295,7 +295,6 @@ void Thread::reschedule()
++     yield();
++ }
++ 
++-
++ void Thread::time_slicer(IC::Interrupt_Id i)
++ {
++     reschedule();
++diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
++index c54f943..fb06a1b 100755
++--- a/tools/eposctors/eposctors
+++++ b/tools/eposctors/eposctors
++@@ -13,11 +13,13 @@ FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '
++ 
++ echo "CTOR_LIST:"
++ if [ "$GDB" = "" ] ; then
++-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+++    LIST=`hexdump -s $INIT_ARRAY_OFFSET -n $INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+++
++     for item in $LIST; do
+++        # echo $item
++         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
++         echo 0x$item $sym
++-    done   
+++    done
++ else
++     hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "break *0x%08x\n"' $ELF
++ fi
+diff --git a/notes/notes_edf.txt b/notes/notes_edf.txt
+new file mode 100644
+index 0000000..5f9391c
+--- /dev/null
++++ b/notes/notes_edf.txt
+@@ -0,0 +1,150 @@
++Preemptive:
++Coisas que fazem reescalonar
++    1. Criacao de Thread READY com PRIO > IDLE
++    2. Thread::priority
++    3. Thread::resume
++    4. Thread::wakeup/wakeup_all (~resume)
++
++Periodic_Thread
++    wait_next() faz esperar no semaforo
++
++
++QUANTUM = 10000 us 
++FREQUENCY = 1000 Ticks/s
++PERIOD = 0.001 s => 1000 us => 1ms
++1 Quantum = 10 Ticks
++
++End: A, Prio=2000 [952]
++Begin: B, Prio=3000 [952]
++Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)
++End: B, Prio=3000 [2402]
++Begin: A, Prio=4000 [2402]
++Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)
++End: A, Prio=4000 [3352]
++Begin: B, Prio=6000 [3352]
++Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)
++Begin: A, Prio=6000 [4000]
++End: A, Prio=6000 [4950]
++End: B, Prio=6000 [5753]
++Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)
++Begin: B, Prio=3000 [6000]
++Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)
++Begin: A, Prio=2000 [6001]
++End: A, Prio=2000 [6951]
++Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)
++End: B, Prio=3000 [8401]
++Begin: A, Prio=4000 [8401]
++Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
++End: A, Prio=4000 [9351]
++Begin: B, Prio=6000 [9351]
++Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
++Begin: A, Prio=6000 [10001]
++End: A, Prio=6000 [10951]
++End: B, Prio=6000 [11752]
++Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
++Begin: B, Prio=3000 [12000]
++Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
++Begin: A, Prio=2000 [12001]
++End: A, Prio=2000 [12951]
++Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
++End: B, Prio=3000 [14401]
++Begin: A, Prio=4000 [14401]
++Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
++End: A, Prio=4000 [15351]
++Begin: B, Prio=6000 [15351]
++Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
++Begin: A, Prio=6000 [16001]
++The last thread has exited!
++
++2)
++End: A, Prio=2000 [952]                                                       
++Begin: B, Prio=3000 [952]
++Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)                           
++End: B, Prio=3000 [2402]
++Begin: A, Prio=4000 [2402]                                                    
++Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)                           
++End: A, Prio=4000 [3352]                                                      
++Begin: B, Prio=6000 [3352]
++Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)                           
++Begin: A, Prio=6000 [4000]
++End: A, Prio=6000 [4950]                                                      
++End: B, Prio=6000 [5753]                                                      
++Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)                           A
++Begin: B, Prio=3000 [6000]
++Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)                           
++Begin: A, Prio=2000 [6001]                                                    
++End: A, Prio=2000 [6951]
++Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)                           
++End: B, Prio=3000 [8401]
++Begin: A, Prio=4000 [8401]
++Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
++End: A, Prio=4000 [9351]
++Begin: B, Prio=6000 [9351]
++Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
++Begin: A, Prio=6000 [10001]
++End: A, Prio=6000 [10951]
++End: B, Prio=6000 [11752]
++Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
++Begin: B, Prio=3000 [12000]
++Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
++Begin: A, Prio=2000 [12001]
++End: A, Prio=2000 [12951]
++Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
++End: B, Prio=3000 [14401]
++Begin: A, Prio=4000 [14401]
++Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
++End: A, Prio=4000 [15351]
++Begin: B, Prio=6000 [15351]
++Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
++Begin: A, Prio=6000 [16001]
++
++Comparing resets:
++
++1)
++
++End: A, Prio=2000 [952]                                                       
++Begin: B, Prio=3000 [952]
++Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)                           
++End: B, Prio=3000 [2402]
++Begin: A, Prio=4000 [2402]                                                    
++Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)                           
++End: A, Prio=4000 [3352]                                                      
++Begin: B, Prio=6000 [3352]
++Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)                           
++Begin: A, Prio=6000 [4000]
++End: A, Prio=6000 [4950]                                                      
++End: B, Prio=6000 [5753]     
++
++2)
++
++Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)                           A
++Begin: B, Prio=3000 [6000]
++Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)                           
++Begin: A, Prio=2000 [6001]                                                    
++End: A, Prio=2000 [6951]
++Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)                           
++End: B, Prio=3000 [8401]
++Begin: A, Prio=4000 [8401]
++Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
++End: A, Prio=4000 [9351]
++Begin: B, Prio=6000 [9351]
++Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
++Begin: A, Prio=6000 [10001]
++End: A, Prio=6000 [10951]
++End: B, Prio=6000 [11752]
++
++3)
++
++Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
++Begin: B, Prio=3000 [12000]
++Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
++Begin: A, Prio=2000 [12001]
++End: A, Prio=2000 [12951]
++Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
++End: B, Prio=3000 [14401]
++Begin: A, Prio=4000 [14401]
++Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
++End: A, Prio=4000 [15351]
++Begin: B, Prio=6000 [15351]
++Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
++Begin: A, Prio=6000 [16001]
+\ No newline at end of file
+diff --git a/notes/notes_heap.txt b/notes/notes_heap.txt
+new file mode 100644
+index 0000000..315169d
+--- /dev/null
++++ b/notes/notes_heap.txt
+@@ -0,0 +1,64 @@
++Machine:
++0x00020000k -> 128mb? (tah 128MB no traits)
++
++Heap:
++tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
++Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
++- Alarm_Timer (20 bytes)
++% Idle
++- Thread (36 bytes)
++- Stack (STACK_SIZE)
++% Main
++- Thread (36 bytes)
++- Stack (STACK_SIZE)
++- Scheduler_Timer(20 bytes)
++Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
++
++Allocs:
++MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
++MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
++MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
++Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
++Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
++% Idle
++Heap::alloc(this=0x80004064,bytes=36 (Thread)
++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
++% Main
++Heap::alloc(this=0x80004064,bytes=36 (Thread)
++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
++Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
++MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
++Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
++MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
++Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
++
++Conclusoes:
++Quando chegamos na main(),
++
++1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
++2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
++3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
++4) A BOOT_STACK foi absorvida pela _heap
++5) A _free esta vazia (size=0; _grouped_size=0)
++6) So a _heap foi alocada em _free (em duas etapas)
++7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
++8) Tamanho inicial de _free=134201064
++9) sizeof(Page) = 1 e pages(x) = x  
++
++Desafios:
++Aglutinacao e insert na lista?
++
++Multiheap:
++Application::_heap tem 16Mb enquanto System::_heap tem 272Kb
++
++Matheus:
++explicar sequencia de inicializacao
++onde esta bootstack?
++onde eh inicializada a _free?
++quantos elementos tem _free antes de construir a heap de sistema?
++onde foram construidos?
++qnt retorna pages? (sizeof no gdb)
++algo foi alocado ah mais na MMU antes de criar a Heap?
++
++Teste:
++So precisa mostrar o algoritmo skippando um bloco que cabe?
+\ No newline at end of file
+diff --git a/notes/notes_mmu.txt b/notes/notes_mmu.txt
+new file mode 100644
+index 0000000..1239a86
+--- /dev/null
++++ b/notes/notes_mmu.txt
+@@ -0,0 +1,3 @@
++Desafios:
++Em que momento liga paginacao na intel?
++Como que liga paginacao no rv32?
+diff --git a/src/api/alarm.cc b/src/api/alarm.cc
+index 3352a3a..0340657 100644
+--- a/src/api/alarm.cc
++++ b/src/api/alarm.cc
+@@ -120,9 +120,10 @@ void Alarm::handler(IC::Interrupt_Id i)
+     }
+ 
+     unlock();
++    // kout << "*";
+ 
+     if(alarm) {
+-        db<Alarm>(TRC) << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
++        kout << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
+         (*alarm->_handler)();
+     }
+ }
+diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
+new file mode 100644
+index 0000000..751633d
+--- /dev/null
++++ b/src/api/scheduler.cc
+@@ -0,0 +1,14 @@
++// EPOS CPU Scheduler Component Implementation
++
++#include <process.h>
++#include <time.h>
++
++__BEGIN_SYS
++
++// The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
++template <typename ... Tn>
++FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
++
++template FCFS::FCFS<>(int p);
++
++__END_SYS
+diff --git a/src/api/segment.cc b/src/api/segment.cc
+index 9ae9b96..7c7634b 100644
+--- a/src/api/segment.cc
++++ b/src/api/segment.cc
+@@ -5,9 +5,9 @@
+ __BEGIN_SYS
+ 
+ // Methods
+-Segment::Segment(unsigned int bytes, const Color & color, const Flags & flags): Chunk(bytes, flags, color)
++Segment::Segment(unsigned int bytes, const Flags & flags): Chunk(bytes, flags)
+ {
+-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",color=" << color << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
++    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+ }
+ 
+ 
+diff --git a/src/api/thread.cc b/src/api/thread.cc
+index fdd0583..3d5e6f5 100644
+--- a/src/api/thread.cc
++++ b/src/api/thread.cc
+@@ -11,20 +11,17 @@ __END_UTIL
+ 
+ __BEGIN_SYS
+ 
+-extern "C" { void __epos_app_entry(); }
+-
+ volatile unsigned int Thread::_thread_count;
+ Scheduler_Timer * Thread::_timer;
++Scheduler<Thread> Thread::_scheduler;
+ 
+-Thread* volatile Thread::_running;
+-Thread::Queue Thread::_ready;
+-Thread::Queue Thread::_suspended;
+ 
+ void Thread::constructor_prologue(unsigned int stack_size)
+ {
+     lock();
+ 
+     _thread_count++;
++    _scheduler.insert(this);
+ 
+     _stack = new (SYSTEM) char[stack_size];
+ }
+@@ -42,13 +39,8 @@ void Thread::constructor_epilogue(const Log_Addr & entry, unsigned int stack_siz
+ 
+     assert((_state != WAITING) && (_state != FINISHING)); // Invalid states
+ 
+-    switch(_state) {
+-        case RUNNING: assert(entry == __epos_app_entry); break;
+-        case READY: _ready.insert(&_link); break;
+-        case SUSPENDED: _suspended.insert(&_link); break;
+-        case WAITING: break;   // invalid state, for switch completion only
+-        case FINISHING: break; // invalid state, for switch completion only
+-    }
++    if((_state != READY) && (_state != RUNNING))
++        _scheduler.suspend(this);
+ 
+     if(preemptive && (_state == READY) && (_link.rank() != IDLE))
+         reschedule();
+@@ -76,15 +68,18 @@ Thread::~Thread()
+         exit(-1);
+         break;
+     case READY:
+-        _ready.remove(this);
++        _scheduler.remove(this);
+         _thread_count--;
+         break;
+     case SUSPENDED:
+-        _suspended.remove(this);
++        _scheduler.resume(this);
++        _scheduler.remove(this);
+         _thread_count--;
+         break;
+     case WAITING:
+         _waiting->remove(this);
++        _scheduler.resume(this);
++        _scheduler.remove(this);
+         _thread_count--;
+         break;
+     case FINISHING: // Already called exit()
+@@ -100,6 +95,26 @@ Thread::~Thread()
+ }
+ 
+ 
++void Thread::priority(const Priority & c)
++{
++    lock();
++
++    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
++
++    _link.rank(Criterion(c));
++
++    if(_state != RUNNING) { // reorder the scheduling queue
++        _scheduler.remove(this);
++        _scheduler.insert(this);
++    }
++
++    if(preemptive)
++        reschedule();
++
++    unlock();
++}
++
++
+ int Thread::join()
+ {
+     lock();
+@@ -113,10 +128,18 @@ int Thread::join()
+     assert(!_joining);
+ 
+     if(_state != FINISHING) {
+-        _joining = running();
+-        _joining->suspend(true);
+-    } else
+-        unlock();
++        Thread * prev = running();
++
++        _joining = prev;
++        prev->_state = SUSPENDED;
++        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
++
++        Thread * next = _scheduler.chosen();
++
++        dispatch(prev, next);
++    }
++
++    unlock();
+ 
+     return *reinterpret_cast<int *>(_stack);
+ }
+@@ -128,56 +151,48 @@ void Thread::pass()
+ 
+     db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
+ 
+-    Thread * prev = _running;
+-    prev->_state = READY;
+-    _ready.insert(&prev->_link);
+-
+-    _ready.remove(this);
+-    _state = RUNNING;
+-    _running = this;
++    Thread * prev = running();
++    Thread * next = _scheduler.choose(this);
+ 
+-    dispatch(prev, this);
++    if(next)
++        dispatch(prev, next, false);
++    else
++        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
+ 
+     unlock();
+ }
+ 
+ 
+-void Thread::suspend(bool locked)
++void Thread::suspend()
+ {
+-    if(!locked)
+-        lock();
++    lock();
+ 
+     db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
+ 
+-    if(_running != this)
+-        _ready.remove(this);
++    Thread * prev = running();
+ 
+     _state = SUSPENDED;
+-    _suspended.insert(&_link);
++    _scheduler.suspend(this);
+ 
+-    if(_running == this) {
+-        _running = _ready.remove()->object();
+-        _running->_state = RUNNING;
++    Thread * next = _scheduler.chosen();
+ 
+-        dispatch(this, _running);
+-    }
++    dispatch(prev, next);
+ 
+     unlock();
+ }
+ 
+ 
+-void Thread::resume(bool unpreemptive)
++void Thread::resume()
+ {
+     lock();
+ 
+     db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
+ 
+     if(_state == SUSPENDED) {
+-        _suspended.remove(this);
+         _state = READY;
+-        _ready.insert(&_link);
++        _scheduler.resume(this);
+ 
+-        if(preemptive && !unpreemptive)
++        if(preemptive)
+             reschedule();
+     } else
+         db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
+@@ -191,16 +206,12 @@ void Thread::yield()
+ {
+     lock();
+ 
+-    db<Thread>(TRC) << "Thread::yield(running=" << _running << ")" << endl;
+-
+-    Thread * prev = _running;
+-    prev->_state = READY;
+-    _ready.insert(&prev->_link);
++    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
+ 
+-    _running = _ready.remove()->object();
+-    _running->_state = RUNNING;
++    Thread * prev = running();
++    Thread * next = _scheduler.choose_another();
+ 
+-    dispatch(prev, _running);
++    dispatch(prev, next);
+ 
+     unlock();
+ }
+@@ -212,23 +223,22 @@ void Thread::exit(int status)
+ 
+     db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
+ 
+-    Thread * prev = _running;
++    Thread * prev = running();
++    _scheduler.remove(prev);
+     prev->_state = FINISHING;
+     *reinterpret_cast<int *>(prev->_stack) = status;
+ 
+     _thread_count--;
+ 
+     if(prev->_joining) {
+-        Thread * joining = prev->_joining;
++        prev->_joining->_state = READY;
++        _scheduler.resume(prev->_joining);
+         prev->_joining = 0;
+-        joining->resume(true);
+-        lock();
+     }
+ 
+-    _running = _ready.remove()->object();
+-    _running->_state = RUNNING;
++    Thread * next = _scheduler.choose(); // at least idle will always be there
+ 
+-    dispatch(prev, _running);
++    dispatch(prev, next);
+ 
+     unlock();
+ }
+@@ -241,14 +251,14 @@ void Thread::sleep(Queue * q)
+     assert(locked()); // locking handled by caller
+ 
+     Thread * prev = running();
++    _scheduler.suspend(prev);
+     prev->_state = WAITING;
+     prev->_waiting = q;
+     q->insert(&prev->_link);
+ 
+-    _running = _ready.remove()->object();
+-    _running->_state = RUNNING;
++    Thread * next = _scheduler.chosen();
+ 
+-    dispatch(prev, _running);
++    dispatch(prev, next);
+ }
+ 
+ 
+@@ -262,7 +272,7 @@ void Thread::wakeup(Queue * q)
+         Thread * t = q->remove()->object();
+         t->_state = READY;
+         t->_waiting = 0;
+-        _ready.insert(&t->_link);
++        _scheduler.resume(t);
+ 
+         if(preemptive)
+             reschedule();
+@@ -281,7 +291,7 @@ void Thread::wakeup_all(Queue * q)
+             Thread * t = q->remove()->object();
+             t->_state = READY;
+             t->_waiting = 0;
+-            _ready.insert(&t->_link);
++            _scheduler.resume(t);
+         }
+ 
+         if(preemptive)
+@@ -292,21 +302,38 @@ void Thread::wakeup_all(Queue * q)
+ 
+ void Thread::reschedule()
+ {
+-    yield();
+-}
++    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
++        db<Thread>(TRC) << "Thread::reschedule()" << endl;
+ 
++    assert(locked()); // locking handled by caller
++
++    Thread * prev = running();
++    Thread * next = _scheduler.choose();
++
++    dispatch(prev, next);
++}
+ 
+ void Thread::time_slicer(IC::Interrupt_Id i)
+ {
++    lock();
+     reschedule();
++    unlock();
+ }
+ 
+ 
+-void Thread::dispatch(Thread * prev, Thread * next)
++void Thread::dispatch(Thread * prev, Thread * next, bool charge)
+ {
++    // "next" is not in the scheduler's queue anymore. It's already "chosen"
++
++    if(charge) {
++        if(Criterion::timed)
++            _timer->restart();
++    }
++
+     if(prev != next) {
+-        assert(prev->_state != RUNNING);
+-        assert(next->_state == RUNNING);
++        if(prev->_state == RUNNING)
++            prev->_state = READY;
++        next->_state = RUNNING;
+ 
+         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
+         db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
+diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
+index db05478..f36c3af 100644
+--- a/src/api/thread_init.cc
++++ b/src/api/thread_init.cc
+@@ -13,10 +13,20 @@ void Thread::init()
+ {
+     db<Init, Thread>(TRC) << "Thread::init()" << endl;
+ 
+-    // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
+-    // which will directly call main(). In this case, _init will have already been called,
+-    // before Init_Application to construct MAIN's global objects.
+-    Thread::_running = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
++    typedef int (Main)();
++
++    System_Info * si = System::info();
++    Main * main;
++
++    if(Traits<System>::multitask)
++        main = reinterpret_cast<Main *>(si->lm.app_entry);
++    else
++        // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
++        // which will directly call main(). In this case, _init will have already been called,
++        // before Init_Application to construct MAIN's global objects.
++        main = reinterpret_cast<Main *>(__epos_app_entry);
++
++    new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
+ 
+     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
+     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+@@ -27,7 +37,7 @@ void Thread::init()
+     // Letting reschedule() happen during thread creation is also harmless, since MAIN is
+     // created first and dispatch won't replace it nor by itself neither by IDLE (which
+     // has a lower priority)
+-    if(preemptive)
++    if(Criterion::timed)
+         _timer = new (SYSTEM) Scheduler_Timer(QUANTUM, time_slicer);
+ 
+     // No more interrupts until we reach init_first
+diff --git a/src/architecture/armv7/armv7_crtend.c b/src/architecture/armv7/armv7_crtend.c
+index 84ae9b3..78a6b11 100644
+--- a/src/architecture/armv7/armv7_crtend.c
++++ b/src/architecture/armv7/armv7_crtend.c
+@@ -16,5 +16,3 @@ void _init()
+ {
+     __do_global_ctors_aux();
+ }
+-
+-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
+diff --git a/src/architecture/ia32/ia32_crtend.c b/src/architecture/ia32/ia32_crtend.c
+index 8aa31da..b7897e9 100644
+--- a/src/architecture/ia32/ia32_crtend.c
++++ b/src/architecture/ia32/ia32_crtend.c
+@@ -17,5 +17,3 @@ void _init()
+ {
+     __do_global_ctors_aux();
+ }
+-
+-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
+diff --git a/src/architecture/rv32/rv32_crtend.c b/src/architecture/rv32/rv32_crtend.c
+index 8aa31da..b7897e9 100644
+--- a/src/architecture/rv32/rv32_crtend.c
++++ b/src/architecture/rv32/rv32_crtend.c
+@@ -17,5 +17,3 @@ void _init()
+ {
+     __do_global_ctors_aux();
+ }
+-
+-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
+diff --git a/src/architecture/rv64/rv64_crtend.c b/src/architecture/rv64/rv64_crtend.c
+index 8aa31da..b7897e9 100644
+--- a/src/architecture/rv64/rv64_crtend.c
++++ b/src/architecture/rv64/rv64_crtend.c
+@@ -17,5 +17,3 @@ void _init()
+ {
+     __do_global_ctors_aux();
+ }
+-
+-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
+diff --git a/src/init/init_first.cc b/src/init/init_first.cc
+index cef9299..73faf01 100644
+--- a/src/init/init_first.cc
++++ b/src/init/init_first.cc
+@@ -18,13 +18,17 @@ public:
+ 
+         db<Init>(INF) << "INIT ends here!" << endl;
+ 
+-        db<Init, Thread>(INF) << "Dispatching the first thread: " << Thread::running() << endl;
++        // Thread::self() and Task::self() can be safely called after the construction of MAIN
++        // even if no reschedule() was called (running is set by the Scheduler at each insert())
++        Thread * first = Thread::self();
++
++        db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
+ 
+         // Interrupts have been disable at Thread::init() and will be reenabled by CPU::Context::load()
+         // but we first reset the timer to avoid getting a time interrupt during load()
+         Timer::reset();
+         CPU::int_enable();
+-        Thread::running()->_context->load();
++        first->_context->load();
+     }
+ };
+ 
+diff --git a/src/init/init_system.cc b/src/init/init_system.cc
+index d3c373f..c9311cf 100644
+--- a/src/init/init_system.cc
++++ b/src/init/init_system.cc
+@@ -25,9 +25,11 @@ public:
+         // Initialize System's heap
+         db<Init>(INF) << "Initializing system's heap: " << endl;
+         if(Traits<System>::multiheap) {
+-            Segment * tmp = reinterpret_cast<Segment *>(&System::_preheap[0]);
+-            System::_heap_segment = new (tmp) Segment(HEAP_SIZE, WHITE, Segment::Flags::SYS);
+-            System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
++            System::_heap_segment = new (&System::_preheap[0]) Segment(HEAP_SIZE, Segment::Flags::SYS);
++            if(Memory_Map::SYS_HEAP == Traits<Machine>::NOT_USED)
++            	System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment), System::_heap_segment->size());
++            else
++                System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
+         } else
+             System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+         db<Init>(INF) << "done!" << endl;
+diff --git a/tests/active_test/active_test.cc b/tests/active_test/active_test.cc
+new file mode 100644
+index 0000000..a7bd4cc
+--- /dev/null
++++ b/tests/active_test/active_test.cc
+@@ -0,0 +1,63 @@
++// EPOS Active Object Component Test Program
++
++#include <process.h>
++
++using namespace EPOS;
++
++const int iterations = 100;
++
++OStream cout;
++
++class A: public Active
++{
++public:
++    int run() {
++        for(int i = iterations; i > 0; i--) {
++            for(int i = 0; i < 79; i++)
++        	cout << "a";
++            cout << endl;
++        }
++
++        return 'A';
++    }
++};
++
++class B: public Active
++{
++public:
++    int run() {
++        for(int i = iterations; i > 0; i--) {
++            for(int i = 0; i < 79; i++)
++        	cout << "b";
++            cout << endl;
++        }
++
++        return 'B';
++    }
++};
++
++int main()
++{
++    cout << "Active Object Test" << endl;
++
++    A * a = new A;
++    B * b = new B;
++
++    a->start();
++    b->start();
++
++    cout << "Both threads are now done and have suspended themselves. I'll now wake them up so they can exit ..." << endl;
++
++    int status_a = a->join();
++    int status_b = b->join();
++
++    cout << "Thread A exited with status " << status_a
++ 	 << " and thread B exited with status " << status_b << endl;
++
++    delete a;
++    delete b;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
+diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
+new file mode 100644
+index 0000000..4642f73
+--- /dev/null
++++ b/tests/active_test/active_test_traits.h
+@@ -0,0 +1,154 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = IA32;
++    static const unsigned int MACHINE = PC;
++    static const unsigned int MODEL = Legacy_PC;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = true;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef RR Criterion;
++    static const unsigned int QUANTUM = 1000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+diff --git a/tests/active_test/makefile b/tests/active_test/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/tests/active_test/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
+index 609d140..0f9a2d0 100644
+--- a/tests/alarm_test/alarm_test_traits.h
++++ b/tests/alarm_test/alarm_test_traits.h
+@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
+ {
+     // Basic configuration
+     static const unsigned int MODE = LIBRARY;
+-    static const unsigned int ARCHITECTURE = IA32;
+-    static const unsigned int MACHINE = PC;
+-    static const unsigned int MODEL = Legacy_PC;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
+     static const unsigned int CPUS = 1;
+     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
+     static const bool trace_idle = hysterically_debugged;
+     static const bool simulate_capacity = false;
+ 
+-    static const bool preemptive = true;
++    typedef RR Criterion;
+     static const unsigned int QUANTUM = 10000; // us
+ };
+ 
+diff --git a/tests/segment_test/makefile b/tests/segment_test/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/tests/segment_test/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
+new file mode 100644
+index 0000000..67c0759
+--- /dev/null
++++ b/tests/segment_test/segment_test.cc
+@@ -0,0 +1,50 @@
++// EPOS Segment Test Program
++
++#include <memory.h>
++
++using namespace EPOS;
++
++const unsigned ES1_SIZE = 10000;
++const unsigned ES2_SIZE = 100000;
++
++int main()
++{
++    OStream cout;
++
++    cout << "Segment test" << endl;
++
++    cout << "My address space's page directory is located at "
++         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
++    Address_Space self(MMU::current());
++
++    cout << "Creating two extra data segments:" << endl;
++    Segment * es1 = new (SYSTEM) Segment(ES1_SIZE);
++    Segment * es2 = new (SYSTEM) Segment(ES2_SIZE);
++    cout << "  extra segment 1 => " << ES1_SIZE << " bytes, done!" << endl;
++    cout << "  extra segment 2 => " << ES2_SIZE << " bytes, done!" << endl;
++
++    cout << "Attaching segments:" << endl;
++    CPU::Log_Addr * extra1 = self.attach(es1);
++    CPU::Log_Addr * extra2 = self.attach(es2);
++    cout << "  extra segment 1 => " << extra1 << " done!" << endl;
++    cout << "  extra segment 2 => " << extra2 << " done!" << endl;
++
++    cout << "Clearing segments:";
++    memset(extra1, 0, ES1_SIZE);
++    memset(extra2, 0, ES2_SIZE);
++    cout << "  done!" << endl;
++
++    cout << "Detaching segments:";
++    self.detach(es1);
++    self.detach(es2);
++    cout << "  done!" << endl;
++
++    cout << "Deleting segments:";
++    delete es1;
++    delete es2;
++    cout << "  done!" << endl;
++
++    cout << "I'm done, bye!" << endl;
++
++    return 0;
++}
+diff --git a/tests/segment_test/segment_test_traits.h b/tests/segment_test/segment_test_traits.h
+new file mode 100644
+index 0000000..d1ca6d5
+--- /dev/null
++++ b/tests/segment_test/segment_test_traits.h
+@@ -0,0 +1,154 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    typedef RR Criterion;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++__END_SYS
++
++#endif
+diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
+index c54f943..fb06a1b 100755
+--- a/tools/eposctors/eposctors
++++ b/tools/eposctors/eposctors
+@@ -13,11 +13,13 @@ FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '
+ 
+ echo "CTOR_LIST:"
+ if [ "$GDB" = "" ] ; then
+-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
++    LIST=`hexdump -s $INIT_ARRAY_OFFSET -n $INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
++
+     for item in $LIST; do
++        # echo $item
+         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
+         echo 0x$item $sym
+-    done   
++    done
+ else
+     hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "break *0x%08x\n"' $ELF
+ fi
diff --git a/docs/diff_real_time.diff b/docs/diff_real_time.diff
new file mode 100644
index 0000000..17db226
--- /dev/null
+++ b/docs/diff_real_time.diff
@@ -0,0 +1,24 @@
+diff --git a/include/scheduler.h b/include/scheduler.h
+index 99bfd36..ff6251e 100644
+--- a/include/scheduler.h
++++ b/include/scheduler.h
+@@ -145,6 +145,23 @@ public:
+     FCFS(int p = NORMAL, Tn & ... an);
+ };
+ 
++// !@#
++// Rate Monotonic
++class RM: public Priority
++{
++public:
++    static const bool preemptive = true;
++    static const bool timed = true;
++
++public:
++    // used for aperiodic threads
++    RM(int priority): Priority(priority) {}
++
++    // used for periodic threads
++    template <typename ... Tn>
++    RM(const Microsecond & period, int priority, Tn & ... an);
++};
diff --git a/docs/diff_scheduler.diff b/docs/diff_scheduler.diff
new file mode 100644
index 0000000..1220583
--- /dev/null
+++ b/docs/diff_scheduler.diff
@@ -0,0 +1,21 @@
+diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
+index 88375cc..2417106 100644
+--- a/src/api/scheduler.cc
++++ b/src/api/scheduler.cc
+@@ -19,4 +19,18 @@ FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed())
+ // Since the definition of FCFS above is only known to this unit, forcing its instantiation here so it gets emitted in scheduler.o for subsequent linking with other units is necessary.
+ template FCFS::FCFS<>(int p);
+ 
++// !@#
++template <typename ... Tn>
++RM::RM(const Microsecond & period, int priority, Tn & ... an) {
++    if(priority == HIGH) {
++        _priority = HIGH + Alarm::ticks(period);
++    }else {
++        _priority = priority;
++    }
++
++     db<Init>(TRC) << "_priority=" << _priority << endl;
++}
++
++template RM::RM<>(const Microsecond & period, int priority);
diff --git a/docs/diff_wf.txt b/docs/diff_wf.txt
new file mode 100644
index 0000000..71c8f8d
--- /dev/null
+++ b/docs/diff_wf.txt
@@ -0,0 +1,510 @@
+diff --git a/app/test/makefile b/app/test/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/test/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/test/notes_heap.txt b/app/test/notes_heap.txt
+new file mode 100644
+index 0000000..a11a5a3
+--- /dev/null
++++ b/app/test/notes_heap.txt
+@@ -0,0 +1,62 @@
++Machine:
++0x00020000k -> 128mb? (tah 128MB no traits)
++
++Heap:
++tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
++Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
++- Alarm_Timer (20 bytes)
++% Idle
++- Thread (36 bytes)
++- Stack (STACK_SIZE)
++% Main
++- Thread (36 bytes)
++- Stack (STACK_SIZE)
++- Scheduler_Timer(20 bytes)
++Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
++
++Allocs:
++MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
++MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
++MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
++Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
++Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
++% Idle
++Heap::alloc(this=0x80004064,bytes=36 (Thread)
++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
++% Main
++Heap::alloc(this=0x80004064,bytes=36 (Thread)
++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
++Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
++MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
++Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
++MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
++Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
++
++Conclusoes:
++Quando chegamos na main(),
++
++1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
++2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
++3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
++4) A BOOT_STACK foi absorvida pela _heap
++5) A _free esta vazia (size=0; _grouped_size=0)
++6) So a _heap foi alocada em _free (em duas etapas)
++7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
++8) Tamanho inicial de _free=134201064
++9) sizeof(Page) = 1 e pages(x) = x  
++
++Desafios:
++A busca comeca em head e a insercao em tail?
++Aglutinacao e insert na lista?
++
++Matheus:
++explicar sequencia de inicializacao
++onde esta bootstack?
++onde eh inicializada a _free?
++quantos elementos tem _free antes de construir a heap de sistema?
++onde foram construidos?
++qnt retorna pages? (sizeof no gdb)
++algo foi alocado ah mais na MMU antes de criar a Heap?
++
++Teste:
++So precisa mostrar o algoritmo skippando um bloco que cabe?
+\ No newline at end of file
+diff --git a/app/test/notes_mmu.txt b/app/test/notes_mmu.txt
+new file mode 100644
+index 0000000..1239a86
+--- /dev/null
++++ b/app/test/notes_mmu.txt
+@@ -0,0 +1,3 @@
++Desafios:
++Em que momento liga paginacao na intel?
++Como que liga paginacao no rv32?
+diff --git a/app/test/test.cc b/app/test/test.cc
+new file mode 100644
+index 0000000..4a473a9
+--- /dev/null
++++ b/app/test/test.cc
+@@ -0,0 +1,34 @@
++// Description:
++// The Heap reaches main() containing two elements: E1 and E2.
++//    E1 begun from &_end to BOOT_STACK, but now has 32904 less bytes due to the allocations
++//  of System::init().
++//    E2 is still untouched and ranges from MEM_TOP to MEM_TOP-STACK_SIZE.
++// E1 is way larger than E2.
++//    In this test program, we allocate almost all of E1 so that Worst-Fit has to reach for E2
++//  in its second allocation (line 30).
++// For comparision purposes, we print how First Fit would have handled each allocation.
++
++#include <utility/ostream.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++static const int SIZE_OF_E1 = 134201064 - 32904 - 16*1024;
++
++char * alloc(int bytes) {
++    return new char[bytes];
++}
++
++int main()
++{
++    // terminal output is important after the following line
++    cout << "Testing Worst-Fit..." << endl;
++
++    // leave less than a stack worth of memory on E1
++    alloc(SIZE_OF_E1 - 8*1024);
++    // this should go to E2
++    alloc(16); // will alloc 16+4 due to size
++
++    return 0;
++}
+diff --git a/app/test/test_traits.h b/app/test/test_traits.h
+new file mode 100644
+index 0000000..008c06f
+--- /dev/null
++++ b/app/test/test_traits.h
+@@ -0,0 +1,155 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    static const bool preemptive = true;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++
++__END_SYS
++
++#endif
+diff --git a/img/makefile b/img/makefile
+index f048773..0799121 100644
+--- a/img/makefile
++++ b/img/makefile
+@@ -83,7 +83,7 @@ endif
+ 
+ debug:		$(IMAGE)
+ ifeq ($(NODES),1)
+-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
++		$(EMULATOR)$(IMAGE) &
+ 		$(DEBUGGER)
+ else
+ 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
+@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
+ 		@echo "Running $(APPLICATION) ..."
+ posrun_$(APPLICATION):
+ 		@echo "done!"
+-		
++
+ FORCE:
+diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
+index 1c809b2..59fe619 100644
+--- a/include/architecture/rv32/rv32_mmu.h
++++ b/include/architecture/rv32/rv32_mmu.h
+@@ -105,6 +105,7 @@ public:
+                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
+         }
+         db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
++        kout << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+ 
+         return phy;
+     };
+@@ -117,7 +118,7 @@ public:
+ 
+     static void free(Phy_Addr addr, unsigned int n = 1) {
+         db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
+-
++        kout << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
+         // No unaligned addresses if the CPU doesn't support it
+         assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
+ 
+diff --git a/include/utility/heap.h b/include/utility/heap.h
+index f377454..0235644 100644
+--- a/include/utility/heap.h
++++ b/include/utility/heap.h
+@@ -18,6 +18,9 @@ protected:
+ public:
+     using Grouping_List<char>::empty;
+     using Grouping_List<char>::size;
++    using Grouping_List<char>::search_decrementing;
++    using Grouping_List<char>::find_first;
++    using Grouping_List<char>::find_worst;
+ 
+     Heap() {
+         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
+@@ -30,8 +33,8 @@ public:
+     }
+ 
+     void * alloc(unsigned int bytes) {
+-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
+-
++        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
++        kout << "Heap::alloc(this=" << this << ",bytes=" << bytes  << ")" << endl;
+         if(!bytes)
+             return 0;
+ 
+@@ -45,6 +48,8 @@ public:
+         if(bytes < sizeof(Element))
+             bytes = sizeof(Element);
+ 
++        kout << "First Fit: " << find_first(bytes) << endl;
++        kout << "Worst Fit: " << find_worst(bytes) << endl;
+         Element * e = search_decrementing(bytes);
+         if(!e) {
+             out_of_memory();
+@@ -65,11 +70,12 @@ public:
+     void free(void * ptr, unsigned int bytes) {
+         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
+ 
+-        if(ptr && (bytes >= sizeof(Element))) {
++        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
+             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
+             Element * m1, * m2;
+             insert_merging(e, &m1, &m2);
+         }
++        kout << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
+     }
+ 
+     static void typed_free(void * ptr) {
+diff --git a/include/utility/list.h b/include/utility/list.h
+index ccc8954..eca1174 100644
+--- a/include/utility/list.h
++++ b/include/utility/list.h
+@@ -1348,7 +1348,7 @@ public:
+ 
+     Element * search_size(unsigned int s) {
+         Element * e = head();
+-        if(sizeof(Object_Type) < sizeof(Element))
++        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
+             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
+         else
+             for(; e && (e->size() < s); e = e->next());
+@@ -1381,7 +1381,7 @@ public:
+         print_head();
+         print_tail();
+ 
+-        Element * e = search_size(s);
++        Element * e = find_worst(s);
+         if(e) {
+             e->shrink(s);
+             _grouped_size -= s;
+@@ -1392,6 +1392,33 @@ public:
+         return e;
+     }
+ 
++    // Used by Heap/Worst-Fit
++    // for empty lists, return 0
++    // for nonempty lists,
++    //      return 0 if there is no element big enough to fit s
++    //      return the element with biggest size otherwise
++    // precons:
++    //  1. s >= sizeof(Element) [s >= 16]
++    Element * find_worst(unsigned int s) {
++        Element * max = 0;
++        unsigned max_size = 0;
++        for(Element * e = head(); e; e = e->next()) {
++            if (e->size() > max_size) {
++                max_size = e->size();
++                max = e;
++            }
++        }
++
++        if (max_size < s)
++            return 0;
++
++        return max;
++    }
++
++    Element * find_first(unsigned int s) {
++        return search_size(s);
++    }
++
+ private:
+     Element * search_left(const Object_Type * obj) {
+         Element * e = head();
+diff --git a/makedefs b/makedefs
+index 21674d9..9275107 100644
+--- a/makedefs
++++ b/makedefs
+@@ -103,7 +103,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
+ pc_AS_FLAGS		:= --32
+ pc_LD_FLAGS		:= -m elf_i386
+ pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
+-pc_DEBUGGER		:= gdb
++pc_DEBUGGER		:= gdb -tui
+ pc_FLASHER		:=
+ pc_MAGIC		:= --nmagic
+ pc_CODE_NAME		:= .init
+@@ -254,7 +254,7 @@ TLDFLAGS	:= -m32
+ ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
+ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
++ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
+ ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
+ 
+ # Tools and flags to compile the system
+@@ -315,7 +315,7 @@ TEE		:= tee
+ ifndef DISPLAY
+ TERM        := sh -c
+ else
+-TERM        := xterm -e
++TERM        := konsole -e
+ endif
+ 
+ TOUCH		:= touch
+diff --git a/src/api/thread.cc b/src/api/thread.cc
+index fdd0583..12cb8e7 100644
+--- a/src/api/thread.cc
++++ b/src/api/thread.cc
+@@ -295,7 +295,6 @@ void Thread::reschedule()
+     yield();
+ }
+ 
+-
+ void Thread::time_slicer(IC::Interrupt_Id i)
+ {
+     reschedule();
+diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
+index c54f943..fb06a1b 100755
+--- a/tools/eposctors/eposctors
++++ b/tools/eposctors/eposctors
+@@ -13,11 +13,13 @@ FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '
+ 
+ echo "CTOR_LIST:"
+ if [ "$GDB" = "" ] ; then
+-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
++    LIST=`hexdump -s $INIT_ARRAY_OFFSET -n $INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
++
+     for item in $LIST; do
++        # echo $item
+         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
+         echo 0x$item $sym
+-    done   
++    done
+ else
+     hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "break *0x%08x\n"' $ELF
+ fi
diff --git a/docs/makefile b/docs/makefile
new file mode 100644
index 0000000..cd5a6b6
--- /dev/null
+++ b/docs/makefile
@@ -0,0 +1,7 @@
+
+
+all:
+	@echo $(word 1, $(APPS))
+	@echo $(APPS)
+	@echo $(words $(APPS))
+	$(foreach app,$(APPS), touch $(app))
\ No newline at end of file
diff --git a/docs/nicolas_13_04.txt b/docs/nicolas_13_04.txt
new file mode 100644
index 0000000..e3b0212
--- /dev/null
+++ b/docs/nicolas_13_04.txt
@@ -0,0 +1,35 @@
+1. Consertei start address do setup (ld espera o simbolo _start; renomeei _setup pra _start)
+2. Stripei os simbolos de debug do setup
+3. Desabilitei M-mode interrupts
+4. Consertei eposctors
+5. Alterei MMU:init, agora da free no setup e no init e usa sys_info ao inves de _end.
+6. Ignorando os global ctors, MMU::_free e System::_heap parecem ok
+7. Chega no ctor_epilogue da thread e quebra no unlock.
+
+ToDo:
+1. Chamar global ctors do setup (n foi ligado com crts)
+    0x80001214 _print
+    0x8000123c EPOS::S::Serial_Display::_engine
+    0x80001390 EPOS::S::MMU::_free
+2. System parece ter sido ligado na ordem errada;
+    0xffffffff
+    0x80300060 EPOS::S::__entry (ja estamos iniciando no setup, mas teremos que mudar pcausa do stvec)
+    0x00000000
+    0x803031dc EPOS::S::Alarm::_timer (eh ptr, pq ta aqui?)
+    0x8030a334 EPOS::S::U::This_Thread::_not_booting (eh bool, pq ta aqui?)
+    0x8030a4f4 EPOS::S::Serial_Display::_engine (ctor ja eh chamado pelo Display::init)
+    0x8030a648 EPOS::S::Serial_Keyboard::_observed (aparentemente tem uma list; nao usamos, dont care)
+    0x8030afe8 EPOS::S::MMU::_free (ctor nao faz nada)
+Seus construtores nao sao chamados pelo init:
+    0xffffffff
+    0x80200100 EPOS::S::init_first
+    0x80201260 EPOS::S::init_system
+    0x00000000
+3. quem tem .data?
+4. _init da App ta errado (aponta pra SYS_CODE); precisamos do Init_Application
+
+Colocar um print no mmode_forward quebra o codigo; wtf?
+
+Shortcuts:
+    Pra printar MMU::_free tem que castar o endereco que ta no system
+    p (*((EPOS::S::MMU::List *) 0x80400124))
\ No newline at end of file
diff --git a/docs/nicolas_14_04.txt b/docs/nicolas_14_04.txt
new file mode 100644
index 0000000..fbae49e
--- /dev/null
+++ b/docs/nicolas_14_04.txt
@@ -0,0 +1,16 @@
+1. objcopy -O binary fez o setup funcionar (sozinho)
+2. build_lm deve ficar igual, so vamos setar has_stp=0
+3. Troquei WRN de sizeof(System_Info) > Page pra ERR (nao temos memoria reservada pra isso)
+4. IC::init e stvec agora sao chamados em Init_System atraves do Machine::pre_init; stvec aponta pro IC::entry do SYS e _int_vector parece OK
+5. Precisamos reservar espaco no .img pra .bss (colocamos algumas pags, por precaucao)
+6. Display::init esta sendo chamado antes para podermos printar no clean_bss
+7. o free no MMU::init estava corrompendo o _mmode_forward
+8. Como _start (da App) aponta pra fora da RAM fisica, precisamos fazer a Main Task
+9. Movi load_app() pra Thread::init(); estou reapropriando MMU::_master (como so copiamos ate 544, nao deve ter problema)
+
+ta sem _start no setup
+
+mesmo ligando --nmagic, App esta sem .data (.code esta RWE)
+https://qemu.readthedocs.io/en/latest/system/gdb.html#advanced-debugging-options
+
+limpar bss dos outros programas
\ No newline at end of file
diff --git a/docs/nicolas_15_04.txt b/docs/nicolas_15_04.txt
new file mode 100644
index 0000000..68ae977
--- /dev/null
+++ b/docs/nicolas_15_04.txt
@@ -0,0 +1,2 @@
+1. chamar os ctors da APP
+2. consertar MMU_init dps de relocar _mmode_forward (e lembrar de descomentar o free do mmu_init)
\ No newline at end of file
diff --git a/docs/nicolas_17_04.txt b/docs/nicolas_17_04.txt
new file mode 100644
index 0000000..111e8ed
--- /dev/null
+++ b/docs/nicolas_17_04.txt
@@ -0,0 +1 @@
+1) chamada de img deve so limpar alguns simbolos da imagem da app
\ No newline at end of file
diff --git a/docs/nicolas_diff.diff b/docs/nicolas_diff.diff
new file mode 100644
index 0000000..cbe133a
--- /dev/null
+++ b/docs/nicolas_diff.diff
@@ -0,0 +1,520 @@
+diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
+index 4e522fb..33eb36f 100644
+--- a/include/architecture/rv32/rv32_mmu.h
++++ b/include/architecture/rv32/rv32_mmu.h
+@@ -71,25 +71,34 @@ public:
+         // }
+ 
+         void map(const RV32_Flags & flags, int from, int to) {
+-            // Phy_Addr * addr = alloc(to - from);
+-            // if(addr)
+-            //     remap(addr, flags, from , to);
++            Phy_Addr * addr = alloc(to - from);
++            if(addr)
++                remap(addr, flags, from , to);
+             // else
+-            //     for( ; from < to; from++) {
+-            //         Log_Addr * tmp = phy2log(&ptes[from]);
+-            //         *tmp = alloc(1) | flags;
+-            //         unsigned int pte = ((addr - Traits<Machine>::PAGE_TABLES)>>12) - 1;
+-            //         pte = pte << 20;
+-            //         pte += ((from) << 10);
+-            //         pte = pte | flags;
+-            //         ptes[i] = pte;
+-            //     }
++                // for( ; from < to; from++) {
++                //     Log_Addr * tmp = phy2log(&ptes[from]);
++                //     *tmp = alloc(1) | flags;
++                //     unsigned int pte = ((addr - Traits<Machine>::PAGE_TABLES)>>12) - 1;
++                //     pte = pte << 20;
++                //     pte += ((from) << 10);
++                //     pte = pte | flags;
++                //     ptes[i] = pte;
++                // }
+         }
+ 
++        // void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
++        //     for(int i = from; i < to; i++) {
++        //         unsigned int pte = ((this - Traits<Machine>::PAGE_TABLES)>>12) - 1;
++        //         pte = pte << 20;
++        //         pte += ((i) << 10);
++        //         pte = pte | flags;
++        //         ptes[i] = pte;
++        //     }
++        // }
++
+         void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
+             for(int i = from; i < to; i++) {
+-                unsigned int pte = ((phy_addr - Traits<Machine>::PAGE_TABLES)>>12) - 1;
+-                pte = pte << 20;
++                unsigned int pte = phy_addr >> 2;
+                 pte += ((i) << 10);
+                 pte = pte | flags;
+                 ptes[i] = pte;
+@@ -148,7 +157,15 @@ public:
+     class Directory
+     {
+     public:
+-        Directory() {}
++        // Directory() {}
++        Directory() : _pd(calloc(1)) {
++            kout << "Directory" << endl;
++            for(unsigned int i = 0; i < 544; i++){
++                (*_pd)[i] = (*_master)[i];
++                kout << i << endl;
++            }
++
++        }
+         // Directory(Page_Directory * pd) {}
+         Directory(Page_Directory * pd) : _pd(pd) {}
+ 
+@@ -160,9 +177,16 @@ public:
+         // Log_Addr attach(const Chunk & chunk) { return chunk.phy_address(); }
+         // Log_Addr attach(const Chunk & chunk, Log_Addr addr) { return (addr == chunk.phy_address())? addr : Log_Addr(false); }
+ 
++        Log_Addr attach(const Chunk & chunk, unsigned int from = 0) {
++            for(unsigned int i = from; i < PD_ENTRIES; i++)
++                if(attach(i, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
++                    return i << DIRECTORY_SHIFT;
++            return false;
++        }
++
+         Log_Addr attach(const Chunk & chunk, const Log_Addr & addr) {
+             unsigned int from = directory(addr);
+-            if(!attach(from, chunk.pt(), chunk.pts(), chunk.flags()))
++            if(!attach(from, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                 return Log_Addr(false);
+             return from << DIRECTORY_SHIFT;
+         }
+@@ -177,7 +201,7 @@ public:
+                 if((*static_cast<Page_Directory *>(phy2log(_pd)))[i]) //it has already been used
+                     return false;
+             for(unsigned int i = from; i < from + n; i++, pt++)
+-                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = Phy_Addr(pt) | flags;
++                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = Phy_Addr(pt) | flags; // is pt the correct value?
+             return true;
+         }
+ 
+diff --git a/include/process.h b/include/process.h
+index 6beda50..245e11d 100644
+--- a/include/process.h
++++ b/include/process.h
+@@ -178,34 +178,35 @@ private:
+ };
+ 
+ 
+-// class Task
+-// {
+-// private:
+-//     static const bool multitask = Traits<System>::multitask;
+-
+-// public:
+-//     template<typename ... Tn>
+-//     Task(const Thread::Configuration & conf, Segment * cs, Segment * ds, int (* entry)(Tn ...), Tn ... an)
+-//     : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _entry(entry), _code(_as->attach(_cs)), _data(_as->attach(_ds)) {
+-//         db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
++class Task
++{
++private:
++    static const bool multitask = Traits<System>::multitask;
++    typedef CPU::Log_Addr Log_Addr;
+ 
+-//     }
+-//     ~Task();
++public:
++    Task(Segment * cs, Segment * ds)
++    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _code(_as->attach(_cs)), _data(_as->attach(_ds)) {
++        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
++    }
++    ~Task();
+ 
+-//     Address_Space * address_space() const { return _as; }
++    Address_Space * address_space() const { return _as; }
+ 
+-//     Segment * code_segment() const { return _cs; }
+-//     Segment * data_segment() const { return _ds; }
++    Segment * code_segment() const { return _cs; }
++    Segment * data_segment() const { return _ds; }
+ 
+-//     Log_Addr code() const { return _code; }
+-//     Log_Addr data() const { return _data; }
++    Log_Addr code() const { return _code; }
++    Log_Addr data() const { return _data; }
+ 
+ 
+-// private:
+-//     Address_Space * _as;
+-//     Segment * _cs;
+-//     Segment * _ds;
+-// };
++private:
++    Address_Space * _as;
++    Segment * _cs;
++    Segment * _ds;
++    Log_Addr _code;
++    Log_Addr _data;
++};
+ 
+ 
+ // class Task
+diff --git a/src/api/address_space.cc b/src/api/address_space.cc
+index a1bf4f9..95e107f 100644
+--- a/src/api/address_space.cc
++++ b/src/api/address_space.cc
+@@ -12,6 +12,7 @@ Address_Space::Address_Space(MMU::Page_Directory * pd) : MMU::Directory(pd)
+ Address_Space::Address_Space()
+ {
+     db<Address_Space> (TRC) << "Address_Space() [Directory::pd=" << Directory::pd() << "] => " << this << endl;
++    kout << "Address_Space() [Directory::pd=" << Directory::pd() << "] => " << this << endl;
+ }
+ 
+ Address_Space::~Address_Space()
+@@ -19,14 +20,14 @@ Address_Space::~Address_Space()
+     db<Address_Space>(TRC) << "~Address_Space(this=" << this << ") [Directory::pd=" << Directory::pd() << "]" << endl;
+ }
+ 
+-// Address_Space::Log_Addr Address_Space::attach(Segment * seg)
+-// {
+-//     Log_Addr tmp = Directory::attach(*seg);
++Address_Space::Log_Addr Address_Space::attach(Segment * seg)
++{
++    Log_Addr tmp = Directory::attach(*seg);
+ 
+-//     db<Address_Space>(TRC) << "Address_Space::attach(this=" << this << ",seg=" << seg << ") => " << tmp << endl;
++    db<Address_Space>(TRC) << "Address_Space::attach(this=" << this << ",seg=" << seg << ") => " << tmp << endl;
+ 
+-//     return tmp;
+-// }
++    return tmp;
++}
+ 
+ Address_Space::Log_Addr Address_Space::attach(Segment * seg, const Address_Space::Log_Addr & addr)
+ {
+diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
+index 4326a72..8fadffc 100644
+--- a/src/setup/setup_sifive_e.cc
++++ b/src/setup/setup_sifive_e.cc
+@@ -57,25 +57,27 @@ void Setup_SifiveE::build_page_tables()
+     Reg page_tables = Traits<Machine>::PAGE_TABLES;
+     MMU::_master = new ( (void *) page_tables ) Page_Directory();
+ 
+-    int sys_npages = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
++    int sys_entries = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
++
++    MMU::_master->remap(page_tables, MMU::RV32_Flags::VALID, 0, sys_entries);
+ 
+     // Manually build the kernel directory
+-    for(int i = 0; i < sys_npages; i++) {
+-        PT_Entry * pte = (((PT_Entry *)MMU::_master) + i);
+-        * pte = ((page_tables >> 12) << 10);
+-        * pte += ((i+1) << 10);
+-        * pte |= MMU::RV32_Flags::VALID;
+-    }
++    // for(int i = 0; i < sys_entries; i++) {
++    //     PT_Entry * pte = (((PT_Entry *)MMU::_master) + i);
++    //     * pte = ((page_tables >> 12) << 10);
++    //     * pte += ((i+1) << 10);
++    //     * pte |= MMU::RV32_Flags::VALID;
++    // }
+ 
+     // Map logical addrs back to themselves; with this, the kernel may access any
+     // physical RAM address directly (as if paging wasn't there)
+-    for(int i = 0; i < sys_npages; i++)
++    for(unsigned i = 0; i < sys_entries; i++)
+     {
+         Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1)) ) Page_Table();
+-        pt->remap(pt, RV32_Flags::SYS);
++        pt->remap(i * 1024*4096, RV32_Flags::SYS);
+     }
+ 
+-    // for(int i = sys_npages; i < 1024; i++)
++    // for(int i = sys_entries; i < 1024; i++)
+     // {
+     //     Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1))  ) Page_Table();
+     //     pt->remap(pt, RV32_Flags::USR);
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
\ No newline at end of file
diff --git a/docs/notes_edf.txt b/docs/notes_edf.txt
new file mode 100644
index 0000000..5f9391c
--- /dev/null
+++ b/docs/notes_edf.txt
@@ -0,0 +1,150 @@
+Preemptive:
+Coisas que fazem reescalonar
+    1. Criacao de Thread READY com PRIO > IDLE
+    2. Thread::priority
+    3. Thread::resume
+    4. Thread::wakeup/wakeup_all (~resume)
+
+Periodic_Thread
+    wait_next() faz esperar no semaforo
+
+
+QUANTUM = 10000 us 
+FREQUENCY = 1000 Ticks/s
+PERIOD = 0.001 s => 1000 us => 1ms
+1 Quantum = 10 Ticks
+
+End: A, Prio=2000 [952]
+Begin: B, Prio=3000 [952]
+Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)
+End: B, Prio=3000 [2402]
+Begin: A, Prio=4000 [2402]
+Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)
+End: A, Prio=4000 [3352]
+Begin: B, Prio=6000 [3352]
+Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)
+Begin: A, Prio=6000 [4000]
+End: A, Prio=6000 [4950]
+End: B, Prio=6000 [5753]
+Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)
+Begin: B, Prio=3000 [6000]
+Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)
+Begin: A, Prio=2000 [6001]
+End: A, Prio=2000 [6951]
+Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)
+End: B, Prio=3000 [8401]
+Begin: A, Prio=4000 [8401]
+Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
+End: A, Prio=4000 [9351]
+Begin: B, Prio=6000 [9351]
+Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
+Begin: A, Prio=6000 [10001]
+End: A, Prio=6000 [10951]
+End: B, Prio=6000 [11752]
+Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
+Begin: B, Prio=3000 [12000]
+Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
+Begin: A, Prio=2000 [12001]
+End: A, Prio=2000 [12951]
+Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
+End: B, Prio=3000 [14401]
+Begin: A, Prio=4000 [14401]
+Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
+End: A, Prio=4000 [15351]
+Begin: B, Prio=6000 [15351]
+Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
+Begin: A, Prio=6000 [16001]
+The last thread has exited!
+
+2)
+End: A, Prio=2000 [952]                                                       
+Begin: B, Prio=3000 [952]
+Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)                           
+End: B, Prio=3000 [2402]
+Begin: A, Prio=4000 [2402]                                                    
+Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)                           
+End: A, Prio=4000 [3352]                                                      
+Begin: B, Prio=6000 [3352]
+Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)                           
+Begin: A, Prio=6000 [4000]
+End: A, Prio=6000 [4950]                                                      
+End: B, Prio=6000 [5753]                                                      
+Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)                           A
+Begin: B, Prio=3000 [6000]
+Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)                           
+Begin: A, Prio=2000 [6001]                                                    
+End: A, Prio=2000 [6951]
+Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)                           
+End: B, Prio=3000 [8401]
+Begin: A, Prio=4000 [8401]
+Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
+End: A, Prio=4000 [9351]
+Begin: B, Prio=6000 [9351]
+Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
+Begin: A, Prio=6000 [10001]
+End: A, Prio=6000 [10951]
+End: B, Prio=6000 [11752]
+Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
+Begin: B, Prio=3000 [12000]
+Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
+Begin: A, Prio=2000 [12001]
+End: A, Prio=2000 [12951]
+Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
+End: B, Prio=3000 [14401]
+Begin: A, Prio=4000 [14401]
+Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
+End: A, Prio=4000 [15351]
+Begin: B, Prio=6000 [15351]
+Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
+Begin: A, Prio=6000 [16001]
+
+Comparing resets:
+
+1)
+
+End: A, Prio=2000 [952]                                                       
+Begin: B, Prio=3000 [952]
+Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)                           
+End: B, Prio=3000 [2402]
+Begin: A, Prio=4000 [2402]                                                    
+Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)                           
+End: A, Prio=4000 [3352]                                                      
+Begin: B, Prio=6000 [3352]
+Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)                           
+Begin: A, Prio=6000 [4000]
+End: A, Prio=6000 [4950]                                                      
+End: B, Prio=6000 [5753]     
+
+2)
+
+Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)                           A
+Begin: B, Prio=3000 [6000]
+Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)                           
+Begin: A, Prio=2000 [6001]                                                    
+End: A, Prio=2000 [6951]
+Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)                           
+End: B, Prio=3000 [8401]
+Begin: A, Prio=4000 [8401]
+Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
+End: A, Prio=4000 [9351]
+Begin: B, Prio=6000 [9351]
+Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
+Begin: A, Prio=6000 [10001]
+End: A, Prio=6000 [10951]
+End: B, Prio=6000 [11752]
+
+3)
+
+Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
+Begin: B, Prio=3000 [12000]
+Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
+Begin: A, Prio=2000 [12001]
+End: A, Prio=2000 [12951]
+Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
+End: B, Prio=3000 [14401]
+Begin: A, Prio=4000 [14401]
+Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
+End: A, Prio=4000 [15351]
+Begin: B, Prio=6000 [15351]
+Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
+Begin: A, Prio=6000 [16001]
\ No newline at end of file
diff --git a/docs/notes_heap.txt b/docs/notes_heap.txt
new file mode 100644
index 0000000..315169d
--- /dev/null
+++ b/docs/notes_heap.txt
@@ -0,0 +1,64 @@
+Machine:
+0x00020000k -> 128mb? (tah 128MB no traits)
+
+Heap:
+tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
+Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
+- Alarm_Timer (20 bytes)
+% Idle
+- Thread (36 bytes)
+- Stack (STACK_SIZE)
+% Main
+- Thread (36 bytes)
+- Stack (STACK_SIZE)
+- Scheduler_Timer(20 bytes)
+Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
+
+Allocs:
+MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
+MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
+MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
+Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
+Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
+% Idle
+Heap::alloc(this=0x80004064,bytes=36 (Thread)
+Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+% Main
+Heap::alloc(this=0x80004064,bytes=36 (Thread)
+Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
+MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
+Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
+MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
+Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
+
+Conclusoes:
+Quando chegamos na main(),
+
+1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
+2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
+3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
+4) A BOOT_STACK foi absorvida pela _heap
+5) A _free esta vazia (size=0; _grouped_size=0)
+6) So a _heap foi alocada em _free (em duas etapas)
+7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
+8) Tamanho inicial de _free=134201064
+9) sizeof(Page) = 1 e pages(x) = x  
+
+Desafios:
+Aglutinacao e insert na lista?
+
+Multiheap:
+Application::_heap tem 16Mb enquanto System::_heap tem 272Kb
+
+Matheus:
+explicar sequencia de inicializacao
+onde esta bootstack?
+onde eh inicializada a _free?
+quantos elementos tem _free antes de construir a heap de sistema?
+onde foram construidos?
+qnt retorna pages? (sizeof no gdb)
+algo foi alocado ah mais na MMU antes de criar a Heap?
+
+Teste:
+So precisa mostrar o algoritmo skippando um bloco que cabe?
\ No newline at end of file
diff --git a/docs/notes_mmu.txt b/docs/notes_mmu.txt
new file mode 100644
index 0000000..37824ea
--- /dev/null
+++ b/docs/notes_mmu.txt
@@ -0,0 +1,24 @@
+O modo S nao controla temporizador e interrupcao de software (eh interrupcao de software msm, guia pratico 114)
+tratamento de interrupcao e mideleg bem explicado no guia pratico mret vs sret pra carregar os mie/mip e sie/sip
+tem tratador separado pro S-mode (stvec?)
+sie e sip sao mie e mip, mas so pode acessar o que foi delegado
+
+Propositos de paginacao:
+protecao
+
+sugere-se satp(0) antes de entrar em S-mode
+
+satp.PPN nao deveria ter 20 bits?
+
+PHY_MAP:
+BOOT_STACK
+PAGE_TABLES
+.
+.
+.
+SETUP
+KERNEL
+APP1
+APP2
+...
+APPn
\ No newline at end of file
diff --git a/docs/supervisor b/docs/supervisor
new file mode 100644
index 0000000..0641253
--- /dev/null
+++ b/docs/supervisor
@@ -0,0 +1,10 @@
+% Multiheap turned off
+Heap is 1 page bellow were it should be
+
+Where is interrupt being enabled/disabled?
+
+Timer::init starts w/ ints off and doesnt enable them
+
+% Multicore
+smp_barrier_init happens at Machine::pre_init
+smp_barrier at Init_System
\ No newline at end of file
diff --git a/docs/teste.patch b/docs/teste.patch
new file mode 100644
index 0000000..ab6ed58
--- /dev/null
+++ b/docs/teste.patch
@@ -0,0 +1,846 @@
+diff --git a/app/hello/hello.cc b/app/hello/hello.cc
+index 567f515..b275f8d 100644
+--- a/app/hello/hello.cc
++++ b/app/hello/hello.cc
+@@ -5,17 +5,17 @@ using namespace EPOS;
+ 
+ OStream cout;
+ 
+-int __attribute__((optimize("O0"))) dummy(int n) {
+-    long long int a = 0;
+-    for (int i = 0; i < n; i++) {
+-        for (int j = 0; j < n; j++) {
+-            a += i*j;
+-        }
+-    }
+-    return a;
+-}
++// int __attribute__((optimize("O0"))) dummy(int n) {
++//     long long int a = 0;
++//     for (int i = 0; i < n; i++) {
++//         for (int j = 0; j < n; j++) {
++//             a += i*j;
++//         }
++//     }
++//     return a;
++// }
+ 
+-static unsigned ITERATIONS = 1000;
++// static unsigned ITERATIONS = 1000;
+ int main()
+ {
+     // Chronometer chron;
+@@ -31,7 +31,7 @@ int main()
+     // }
+     // chron.stop();
+     // unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
+-    // cout << "T=" << avg << endl; 
++    // cout << "T=" << avg << endl;
+     cout << "Hello world!" << endl;
+     return 0;
+ }
+diff --git a/img/makefile b/img/makefile
+index 9b1b14f..d47e93b 100644
+--- a/img/makefile
++++ b/img/makefile
+@@ -31,7 +31,7 @@ ifeq ($(DEBUG),1)
+ # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
+ # endif
+ # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
+-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000000"
++DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000080"
+ PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
+ endif
+ 
+@@ -85,6 +85,7 @@ endif
+ 
+ debug:		$(IMAGE)
+ ifeq ($(NODES),1)
++		echo "HELLO!!!!!!!!!!!!!!!!!"
+ 		$(EMULATOR)$(IMAGE) &
+ 		$(DEBUGGER)
+ else
+diff --git a/include/machine/display.h b/include/machine/display.h
+index 03a873c..f3599c7 100644
+--- a/include/machine/display.h
++++ b/include/machine/display.h
+@@ -34,6 +34,7 @@ public:
+ class Serial_Display: public Display_Common
+ {
+     friend class PC_Setup;
++    friend class Setup_SifiveE;
+     friend class Serial_Keyboard;
+     friend class Machine;
+ 
+diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
+index 865e083..aefc3ef 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_info.h
++++ b/include/machine/riscv/sifive_e/sifive_e_info.h
+@@ -37,10 +37,50 @@ public:
+         Size extras_offset;
+     };
+ 
++    // !P2:
+     // Load Map (not used in this machine, but kept for architectural transparency)
++    // struct Load_Map
++    // {
++    //     bool  has_ext;
++    //     LAddr app_entry;
++    //     Size  app_segments;
++    //     LAddr app_code;
++    //     Size  app_code_size;
++    //     LAddr app_data;
++    //     LAddr app_stack;
++    //     LAddr app_heap;
++    //     Size  app_data_size;
++    //     LAddr app_extra;
++    //     Size  app_extra_size;
++    // };
++
+     struct Load_Map
+     {
++        bool  has_stp;
++        bool  has_ini;
++        bool  has_sys;
++        bool  has_app;
+         bool  has_ext;
++        LAddr stp_entry;
++        Size  stp_segments;
++        LAddr stp_code;
++        Size  stp_code_size;
++        LAddr stp_data;
++        Size  stp_data_size;
++        LAddr ini_entry;
++        Size  ini_segments;
++        LAddr ini_code;
++        Size  ini_code_size;
++        LAddr ini_data;
++        Size  ini_data_size;
++        LAddr sys_entry;
++        Size  sys_segments;
++        LAddr sys_code;
++        Size  sys_code_size;
++        LAddr sys_data;
++        Size  sys_data_size;
++        LAddr sys_stack;
++        Size  sys_stack_size;
+         LAddr app_entry;
+         Size  app_segments;
+         LAddr app_code;
+@@ -49,7 +89,7 @@ public:
+         LAddr app_stack;
+         LAddr app_heap;
+         Size  app_data_size;
+-        LAddr app_extra;
++        PAddr app_extra;
+         Size  app_extra_size;
+     };
+ 
+diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
+index 2acbf80..0fa18a3 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
++++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
+@@ -34,7 +34,7 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
+     // Logical Memory Map
+     static const unsigned int BOOT              = NOT_USED;
+     static const unsigned int IMAGE             = NOT_USED;
+-    static const unsigned int SETUP             = 0x80000000; // This controls whether an ELF file is generated for setup
++    static const unsigned int SETUP             = 0x80000000 + 0x78; // This controls whether an ELF file is generated for setup; boot + elf header
+     // static const unsigned int SETUP             = NOT_USED;
+     static const unsigned int INIT              = 0x80010000; // 16 pages for setup
+ 
+diff --git a/include/system/config.h b/include/system/config.h
+index d2d607d..4b24ad1 100644
+--- a/include/system/config.h
++++ b/include/system/config.h
+@@ -7,15 +7,15 @@
+ // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
+ // This section is generated automatically from makedefs by $EPOS/etc/makefile
+ //============================================================================
+-#define SMOD xxx
+-#define ARCH xxx
+-#define MACH xxx
+-#define MMOD xxx
+-#define APPL xxx
+-#define __mode_xxx__
+-#define __arch_xxx__
+-#define __mach_xxx__
+-#define __mmod_xxx__
++#define SMOD builtin
++#define ARCH rv32
++#define MACH riscv
++#define MMOD sifive_e
++#define APPL hello_usr
++#define __mode_builtin__
++#define __arch_rv32__
++#define __mach_riscv__
++#define __mmod_sifive_e__
+ 
+ //============================================================================
+ // NAMESPACES AND DEFINITIONS
+diff --git a/include/utility/elf.h b/include/utility/elf.h
+index 0ef4158..0c47657 100644
+--- a/include/utility/elf.h
++++ b/include/utility/elf.h
+@@ -31,7 +31,8 @@ public:
+         : seg(i)->p_align ? seg(i)->p_vaddr
+         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
+     }
+-
++    
++    // !P2: is this correct?
+     int segment_size(int i) {
+         return (i > segments()) ? -1 : (int)(
+             ((seg(i)->p_offset % seg(i)->p_align)
+diff --git a/makedefs b/makedefs
+index 5e654fb..e0f4ef7 100644
+--- a/makedefs
++++ b/makedefs
+@@ -114,7 +114,7 @@ ifeq ($(MMOD),realview_pbx)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a9
+ cortex_AS_FLAGS		:= -mcpu=cortex-a9
+ cortex_LD_FLAGS		:=
+-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
+ cortex_DEBUGGER		:= arm-none-eabi-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+@@ -126,7 +126,7 @@ endif
+ ifeq ($(MMOD),zynq)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a9
+ cortex_AS_FLAGS		:= -mcpu=cortex-a9
+-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
+ cortex_DEBUGGER		:= arm-none-eabi-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+@@ -139,7 +139,7 @@ ifeq ($(MMOD),raspberry_pi3)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
+ cortex_AS_FLAGS		:= -mcpu=cortex-a53
+ cortex_LD_FLAGS		:=
+-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
+ cortex_DEBUGGER		:= arm-none-eabi-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+@@ -149,7 +149,7 @@ cortex_IMG_SUFFIX	:= .bin
+ endif
+ 
+ ifeq ($(MMOD),lm3s811)
+-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
+ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
+ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
+ cortex_LD_FLAGS		:=
+@@ -162,7 +162,7 @@ cortex_IMG_SUFFIX	:= .img
+ endif
+ 
+ ifeq ($(MMOD),emote3)
+-cortex_EMULATOR		= 
++cortex_EMULATOR		=
+ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
+ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
+ cortex_LD_FLAGS		:=
+@@ -176,11 +176,12 @@ endif
+ 
+ ifeq ($(MMOD),sifive_e)
+ riscv_CC_FLAGS          := -Wl, -mno-relax
+-riscv_AS_FLAGS          := 
++riscv_AS_FLAGS          :=
+ riscv_LD_FLAGS          := --no-relax
+-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
++# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
++riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
+ riscv_DEBUGGER          := $(COMP_PREFIX)gdb
+-riscv_FLASHER           := 
++riscv_FLASHER           :=
+ riscv_MAGIC             := --nmagic
+ riscv_CODE_NAME 		:= .init
+ riscv_DATA_NAME 		:= .sdata
+@@ -189,11 +190,11 @@ endif
+ 
+ ifeq ($(MMOD),sifive_u)
+ riscv_CC_FLAGS          := -mcmodel=medany
+-riscv_AS_FLAGS          := 
+-riscv_LD_FLAGS          := 
+-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
++riscv_AS_FLAGS          :=
++riscv_LD_FLAGS          :=
++riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
+ riscv_DEBUGGER          := $(COMP_PREFIX)gdb
+-riscv_FLASHER           := 
++riscv_FLASHER           :=
+ riscv_MAGIC             := --omagic
+ riscv_CODE_NAME := .init
+ riscv_DATA_NAME :=
+@@ -254,7 +255,7 @@ TLDFLAGS	:= -m32
+ ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
+ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
+ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+-ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
++ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
+ ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
+ 
+ # Tools and flags to compile the system
+diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
+index 194e2e5..806249d 100644
+--- a/src/setup/setup_sifive_e.cc
++++ b/src/setup/setup_sifive_e.cc
+@@ -2,6 +2,8 @@
+ 
+ #include <utility/ostream.h>
+ 
++#include <utility/elf.h>
++#include <utility/debug.h>
+ #include <system/info.h>
+ #include <architecture.h>
+ #include <machine.h>
+@@ -24,11 +26,13 @@ extern "C"
+         // _start();
+     }
+     void _print(const char * s) { Display::puts(s); }
++    void _panic() { Machine::panic(); }
++
+ }
+ 
+-char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________";
++// char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
++char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________________________________________________________________________________________________________________________________________";
+ System_Info * si;
+-EPOS::S::U::OStream kout, kerr;
+ 
+ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+     Reg id = CPU::mcause();
+@@ -42,6 +46,7 @@ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+ }
+ 
+ __BEGIN_SYS
++EPOS::S::U::OStream kout, kerr;
+ 
+ class Setup_SifiveE {
+ private:
+@@ -57,8 +62,176 @@ public:
+     static void setup_supervisor_environment();
+     static void build_page_tables();
+     static void clean_bss();
++    static void build_lm();
+ };
+ 
++// !P2:
++void Setup_SifiveE::build_lm()
++{
++    // Get boot image structure
++    si->lm.has_stp = (si->bm.setup_offset != -1u);
++    si->lm.has_ini = (si->bm.init_offset != -1u);
++    si->lm.has_sys = (si->bm.system_offset != -1u);
++    si->lm.has_app = (si->bm.application_offset != -1u);
++    si->lm.has_ext = (si->bm.extras_offset != -1u);
++
++    // Check SETUP integrity and get the size of its segments
++    si->lm.stp_entry = 0;
++    si->lm.stp_segments = 0;
++    si->lm.stp_code = ~0U;
++    si->lm.stp_code_size = 0;
++    si->lm.stp_data = ~0U;
++    si->lm.stp_data_size = 0;
++
++    db<Spin>(ERR) << "SETUP ELF image is corrupted!" << endl;
++    EPOS::S::kout << "oioioioioio" << endl;
++    char * bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE);
++    if(si->lm.has_stp) {
++        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
++        if(!stp_elf->valid()) {
++            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
++            _panic();
++        }
++
++        si->lm.stp_entry = stp_elf->entry();
++        si->lm.stp_segments = stp_elf->segments();
++        si->lm.stp_code = stp_elf->segment_address(0);
++        si->lm.stp_code_size = stp_elf->segment_size(0);
++        if(stp_elf->segments() > 1) {
++            for(int i = 1; i < stp_elf->segments(); i++) {
++                if(stp_elf->segment_type(i) != PT_LOAD)
++                    continue;
++                if(stp_elf->segment_address(i) < si->lm.stp_data)
++                    si->lm.stp_data = stp_elf->segment_address(i);
++                si->lm.stp_data_size += stp_elf->segment_size(i);
++            }
++        }
++    }
++
++
++    // // Check INIT integrity and get the size of its segments
++    // si->lm.ini_entry = 0;
++    // si->lm.ini_segments = 0;
++    // si->lm.ini_code = ~0U;
++    // si->lm.ini_code_size = 0;
++    // si->lm.ini_data = ~0U;
++    // si->lm.ini_data_size = 0;
++    // if(si->lm.has_ini) {
++    //     ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
++    //     if(!ini_elf->valid()) {
++    //         db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
++    //         panic();
++    //     }
++
++    //     si->lm.ini_entry = ini_elf->entry();
++    //     si->lm.ini_segments = ini_elf->segments();
++    //     si->lm.ini_code = ini_elf->segment_address(0);
++    //     si->lm.ini_code_size = ini_elf->segment_size(0);
++    //     if(ini_elf->segments() > 1) {
++    //         for(int i = 1; i < ini_elf->segments(); i++) {
++    //             if(ini_elf->segment_type(i) != PT_LOAD)
++    //                 continue;
++    //             if(ini_elf->segment_address(i) < si->lm.ini_data)
++    //                 si->lm.ini_data = ini_elf->segment_address(i);
++    //             si->lm.ini_data_size += ini_elf->segment_size(i);
++    //         }
++    //     }
++    // }
++
++    // // Check SYSTEM integrity and get the size of its segments
++    // si->lm.sys_entry = 0;
++    // si->lm.sys_segments = 0;
++    // si->lm.sys_code = ~0U;
++    // si->lm.sys_code_size = 0;
++    // si->lm.sys_data = ~0U;
++    // si->lm.sys_data_size = 0;
++    // si->lm.sys_stack = SYS_STACK;
++    // si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
++    // if(si->lm.has_sys) {
++    //     ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
++    //     if(!sys_elf->valid()) {
++    //         db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
++    //         panic();
++    //     }
++
++    //     si->lm.sys_entry = sys_elf->entry();
++    //     si->lm.sys_segments = sys_elf->segments();
++    //     si->lm.sys_code = sys_elf->segment_address(0);
++    //     si->lm.sys_code_size = sys_elf->segment_size(0);
++    //     if(sys_elf->segments() > 1) {
++    //         for(int i = 1; i < sys_elf->segments(); i++) {
++    //             if(sys_elf->segment_type(i) != PT_LOAD)
++    //                 continue;
++    //             if(sys_elf->segment_address(i) < si->lm.sys_data)
++    //                 si->lm.sys_data = sys_elf->segment_address(i);
++    //             si->lm.sys_data_size += sys_elf->segment_size(i);
++    //         }
++    //     }
++
++    //     if(si->lm.sys_code != SYS_CODE) {
++    //         db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
++    //         panic();
++    //     }
++    //     if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
++    //         db<Setup>(ERR) << "OS code segment is too large!" << endl;
++    //         panic();
++    //     }
++    //     if(si->lm.sys_data != SYS_DATA) {
++    //         db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
++    //         panic();
++    //     }
++    //     if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack) {
++    //         db<Setup>(ERR) << "OS data segment is too large!" << endl;
++    //         panic();
++    //     }
++    //     if(MMU::page_tables(MMU::pages(si->lm.sys_stack - SYS + si->lm.sys_stack_size)) > 1) {
++    //         db<Setup>(ERR) << "OS stack segment is too large!" << endl;
++    //         panic();
++    //     }
++    // }
++
++    // // Check APPLICATION integrity and get the size of its segments
++    // si->lm.app_entry = 0;
++    // si->lm.app_segments = 0;
++    // si->lm.app_code = ~0U;
++    // si->lm.app_code_size = 0;
++    // si->lm.app_data = ~0U;
++    // si->lm.app_data_size = 0;
++    // if(si->lm.has_app) {
++    //     ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
++    //     if(!app_elf->valid()) {
++    //         db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
++    //         panic();
++    //     }
++    //     si->lm.app_entry = app_elf->entry();
++    //     si->lm.app_code = app_elf->segment_address(0);
++    //     si->lm.app_code_size = app_elf->segment_size(0);
++    //     if(app_elf->segments() > 1) {
++    //         for(int i = 1; i < app_elf->segments(); i++) {
++    //             if(app_elf->segment_type(i) != PT_LOAD)
++    //                 continue;
++    //             if(app_elf->segment_address(i) < si->lm.app_data)
++    //                 si->lm.app_data = app_elf->segment_address(i);
++    //             si->lm.app_data_size += app_elf->segment_size(i);
++    //         }
++    //     }
++    //     if(Traits<System>::multiheap) { // Application heap in data segment
++    //         si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
++    //         si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
++    //         si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
++    //         si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
++    //         si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
++    //     }
++    //     if(si->lm.has_ext) { // Check for EXTRA data in the boot image
++    //         si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
++    //         si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
++    //         if(Traits<System>::multiheap)
++    //             si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
++    //         si->lm.app_data_size += si->lm.app_extra_size;
++    //     }
++    // }
++}
++
+ void Setup_SifiveE::build_page_tables()
+ {
+     // Address of the Directory
+@@ -103,8 +276,11 @@ void Setup_SifiveE::setup_supervisor_environment()
+     build_page_tables();
+ 
+     //!P2: How could machine pre_init run before Init_System if it was linked w/ SYS?
+-    // if(CPU::id() == 0)
+-    //     Display::init();
++    if(CPU::id() == 0)
++        Display::init();
++
++    si = reinterpret_cast<System_Info*>(placeholder);
++    build_lm();
+ 
+     // db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
+ 
+@@ -128,7 +304,6 @@ void Setup_SifiveE::setup_supervisor_environment()
+ 
+ void Setup_SifiveE::setup_machine_environment()
+ {
+-    si = reinterpret_cast<System_Info*>(placeholder);
+     // We first configure the M-mode CSRs and then switch to S-mode
+     // configure paging. After that, we won't return to M-mode; an exception
+     // is the forwarding of ints and excps to S-mode.
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
+index 75a2801..bcb452f 100644
+--- a/tools/eposmkbi/eposmkbi.cc
++++ b/tools/eposmkbi/eposmkbi.cc
+@@ -166,6 +166,11 @@ int main(int argc, char **argv)
+     unsigned int image_size = 0;
+     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
+ 
++    // !P2:
++    // riscv boot jump: jal 0x74
++    unsigned int boot_jump = 0b111100000000000000001101111; 
++    image_size += put_number(fd_img, boot_jump);
++    
+     // Add BOOT
+     if(CONFIG.boot_length_max > 0) {
+         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
+@@ -181,6 +186,8 @@ int main(int argc, char **argv)
+         }
+     }
+     unsigned int boot_size = image_size;
++    // !P2:
++    // boot_size = 0;
+ 
+     // Determine if System_Info is needed and how it must be handled
+     bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
+@@ -210,10 +217,10 @@ int main(int argc, char **argv)
+     si.bm.space_z  = CONFIG.space_z;
+ 
+     fprintf(out, "\nsi.bm.n_cpus %u", si.bm.n_cpus);
+-    fprintf(out, "\nsi.bm.mem_base %u", si.bm.mem_base);
+-    fprintf(out, "\nsi.bm.mem_top %u", si.bm.mem_top);
+-    fprintf(out, "\nsi.bm.mio_base %u", si.bm.mio_base);
+-    fprintf(out, "\nsi.bm.mio_top %u", si.bm.mio_top);
++    fprintf(out, "\nsi.bm.mem_base %08x", si.bm.mem_base);
++    fprintf(out, "\nsi.bm.mem_top %08x", si.bm.mem_top);
++    fprintf(out, "\nsi.bm.mio_base %08x", si.bm.mio_base);
++    fprintf(out, "\nsi.bm.mio_top %08x", si.bm.mio_top);
+     fprintf(out, "\nsi.bm.node_id %u", si.bm.node_id);
+     fprintf(out, "\nsi.bm.space_x %u", si.bm.space_x);
+     fprintf(out, "\nsi.bm.space_y %u", si.bm.space_y);
diff --git a/docs/tmp/DIFF.patch b/docs/tmp/DIFF.patch
new file mode 100644
index 0000000..f6bc3c4
--- /dev/null
+++ b/docs/tmp/DIFF.patch
@@ -0,0 +1,1441 @@
+diff --git a/app/hello/hello.cc b/app/hello/hello.cc
+index 567f515..b275f8d 100644
+--- a/app/hello/hello.cc
++++ b/app/hello/hello.cc
+@@ -5,17 +5,17 @@ using namespace EPOS;
+ 
+ OStream cout;
+ 
+-int __attribute__((optimize("O0"))) dummy(int n) {
+-    long long int a = 0;
+-    for (int i = 0; i < n; i++) {
+-        for (int j = 0; j < n; j++) {
+-            a += i*j;
+-        }
+-    }
+-    return a;
+-}
++// int __attribute__((optimize("O0"))) dummy(int n) {
++//     long long int a = 0;
++//     for (int i = 0; i < n; i++) {
++//         for (int j = 0; j < n; j++) {
++//             a += i*j;
++//         }
++//     }
++//     return a;
++// }
+ 
+-static unsigned ITERATIONS = 1000;
++// static unsigned ITERATIONS = 1000;
+ int main()
+ {
+     // Chronometer chron;
+@@ -31,7 +31,7 @@ int main()
+     // }
+     // chron.stop();
+     // unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
+-    // cout << "T=" << avg << endl; 
++    // cout << "T=" << avg << endl;
+     cout << "Hello world!" << endl;
+     return 0;
+ }
+diff --git a/img/makefile b/img/makefile
+index 9b1b14f..b25502a 100644
+--- a/img/makefile
++++ b/img/makefile
+@@ -31,7 +31,7 @@ ifeq ($(DEBUG),1)
+ # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
+ # endif
+ # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
+-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000000"
++DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000080"
+ PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
+ endif
+ 
+diff --git a/include/machine/display.h b/include/machine/display.h
+index 03a873c..f3599c7 100644
+--- a/include/machine/display.h
++++ b/include/machine/display.h
+@@ -34,6 +34,7 @@ public:
+ class Serial_Display: public Display_Common
+ {
+     friend class PC_Setup;
++    friend class Setup_SifiveE;
+     friend class Serial_Keyboard;
+     friend class Machine;
+ 
+diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
+index 865e083..aefc3ef 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_info.h
++++ b/include/machine/riscv/sifive_e/sifive_e_info.h
+@@ -37,10 +37,50 @@ public:
+         Size extras_offset;
+     };
+ 
++    // !P2:
+     // Load Map (not used in this machine, but kept for architectural transparency)
++    // struct Load_Map
++    // {
++    //     bool  has_ext;
++    //     LAddr app_entry;
++    //     Size  app_segments;
++    //     LAddr app_code;
++    //     Size  app_code_size;
++    //     LAddr app_data;
++    //     LAddr app_stack;
++    //     LAddr app_heap;
++    //     Size  app_data_size;
++    //     LAddr app_extra;
++    //     Size  app_extra_size;
++    // };
++
+     struct Load_Map
+     {
++        bool  has_stp;
++        bool  has_ini;
++        bool  has_sys;
++        bool  has_app;
+         bool  has_ext;
++        LAddr stp_entry;
++        Size  stp_segments;
++        LAddr stp_code;
++        Size  stp_code_size;
++        LAddr stp_data;
++        Size  stp_data_size;
++        LAddr ini_entry;
++        Size  ini_segments;
++        LAddr ini_code;
++        Size  ini_code_size;
++        LAddr ini_data;
++        Size  ini_data_size;
++        LAddr sys_entry;
++        Size  sys_segments;
++        LAddr sys_code;
++        Size  sys_code_size;
++        LAddr sys_data;
++        Size  sys_data_size;
++        LAddr sys_stack;
++        Size  sys_stack_size;
+         LAddr app_entry;
+         Size  app_segments;
+         LAddr app_code;
+@@ -49,7 +89,7 @@ public:
+         LAddr app_stack;
+         LAddr app_heap;
+         Size  app_data_size;
+-        LAddr app_extra;
++        PAddr app_extra;
+         Size  app_extra_size;
+     };
+ 
+diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+index cb8beac..28e9ce5 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
++++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+@@ -49,7 +49,7 @@ struct Memory_Map
+         IO              = Traits<Machine>::IO_BASE,
+ 
+         SYS             = Traits<Machine>::SYS,
+-        SYS_INFO        = unsigned(-1),                 // Dynamically built during initialization.
++        SYS_INFO        = Traits<Machine>::SYS_INFO,
+         SYS_CODE        = Traits<Machine>::SYS_CODE,
+         SYS_DATA        = Traits<Machine>::SYS_DATA,
+         SYS_HEAP        = Traits<Machine>::NOT_USED,
+diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
+index 2acbf80..25cb11a 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
++++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
+@@ -30,13 +30,14 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
+ 
+     static const unsigned int VECTOR_TABLE      = NOT_USED;
+     static const unsigned int PAGE_TABLES       = 0x87ffffff + 1 - 16*1024 - ((1024+1)*4*1024); // 0x87BFB000
++    static const unsigned int SYS_INFO          = PAGE_TABLES - 4096; 
+ 
+     // Logical Memory Map
+     static const unsigned int BOOT              = NOT_USED;
+     static const unsigned int IMAGE             = NOT_USED;
+-    static const unsigned int SETUP             = 0x80000000; // This controls whether an ELF file is generated for setup
++    static const unsigned int SETUP             = 0x80000000 + 0x78; // This controls whether an ELF file is generated for setup; boot + elf header
+     // static const unsigned int SETUP             = NOT_USED;
+-    static const unsigned int INIT              = 0x80010000; // 16 pages for setup
++    static const unsigned int INIT              = 0x80200000;
+ 
+     static const unsigned int APP_LOW           = 0x88000000;
+     static const unsigned int APP_CODE          = 0x88000000;
+@@ -51,8 +52,8 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
+     //!P2: Is SYS_HEAP necessary?
+     //!P2: we can let the BOOT_STACK be the kernel stack
+     static const unsigned int SYS               = NOT_USED;
+-    static const unsigned int SYS_CODE          = 0x80020000;
+-    static const unsigned int SYS_DATA          = 0x80040000;
++    static const unsigned int SYS_CODE          = 0x80300000;
++    static const unsigned int SYS_DATA          = 0x80400000;
+     static const unsigned int SYS_HEAP          = NOT_USED;
+     static const unsigned int SYS_STACK         = NOT_USED;
+ 
+diff --git a/include/utility/elf.h b/include/utility/elf.h
+index 0ef4158..0c47657 100644
+--- a/include/utility/elf.h
++++ b/include/utility/elf.h
+@@ -31,7 +31,8 @@ public:
+         : seg(i)->p_align ? seg(i)->p_vaddr
+         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
+     }
+-
++    
++    // !P2: is this correct?
+     int segment_size(int i) {
+         return (i > segments()) ? -1 : (int)(
+             ((seg(i)->p_offset % seg(i)->p_align)
+diff --git a/makedefs b/makedefs
+index 5e654fb..fd2fd15 100644
+--- a/makedefs
++++ b/makedefs
+@@ -114,7 +114,7 @@ ifeq ($(MMOD),realview_pbx)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a9
+ cortex_AS_FLAGS		:= -mcpu=cortex-a9
+ cortex_LD_FLAGS		:=
+-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
+ cortex_DEBUGGER		:= arm-none-eabi-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+@@ -126,7 +126,7 @@ endif
+ ifeq ($(MMOD),zynq)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a9
+ cortex_AS_FLAGS		:= -mcpu=cortex-a9
+-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
+ cortex_DEBUGGER		:= arm-none-eabi-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+@@ -139,7 +139,7 @@ ifeq ($(MMOD),raspberry_pi3)
+ cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
+ cortex_AS_FLAGS		:= -mcpu=cortex-a53
+ cortex_LD_FLAGS		:=
+-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
+ cortex_DEBUGGER		:= arm-none-eabi-gdb
+ cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
+ cortex_MAGIC		:= --omagic
+@@ -149,7 +149,7 @@ cortex_IMG_SUFFIX	:= .bin
+ endif
+ 
+ ifeq ($(MMOD),lm3s811)
+-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
++cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
+ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
+ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
+ cortex_LD_FLAGS		:=
+@@ -162,7 +162,7 @@ cortex_IMG_SUFFIX	:= .img
+ endif
+ 
+ ifeq ($(MMOD),emote3)
+-cortex_EMULATOR		= 
++cortex_EMULATOR		=
+ cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
+ cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
+ cortex_LD_FLAGS		:=
+@@ -175,12 +175,13 @@ cortex_IMG_SUFFIX	:= .img
+ endif
+ 
+ ifeq ($(MMOD),sifive_e)
+-riscv_CC_FLAGS          := -Wl, -mno-relax
+-riscv_AS_FLAGS          := 
++riscv_CC_FLAGS          := -Wl, -mno-relax -march='rv32g'
++riscv_AS_FLAGS          :=
+ riscv_LD_FLAGS          := --no-relax
+-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
++# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
++riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
+ riscv_DEBUGGER          := $(COMP_PREFIX)gdb
+-riscv_FLASHER           := 
++riscv_FLASHER           :=
+ riscv_MAGIC             := --nmagic
+ riscv_CODE_NAME 		:= .init
+ riscv_DATA_NAME 		:= .sdata
+@@ -189,11 +190,11 @@ endif
+ 
+ ifeq ($(MMOD),sifive_u)
+ riscv_CC_FLAGS          := -mcmodel=medany
+-riscv_AS_FLAGS          := 
+-riscv_LD_FLAGS          := 
+-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
++riscv_AS_FLAGS          :=
++riscv_LD_FLAGS          :=
++riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
+ riscv_DEBUGGER          := $(COMP_PREFIX)gdb
+-riscv_FLASHER           := 
++riscv_FLASHER           :=
+ riscv_MAGIC             := --omagic
+ riscv_CODE_NAME := .init
+ riscv_DATA_NAME :=
+@@ -254,7 +255,7 @@ TLDFLAGS	:= -m32
+ ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
+ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
+ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+-ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
++ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
+ ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
+ 
+ # Tools and flags to compile the system
+diff --git a/notes/build.txt b/notes/build.txt
+index 25a091f..83bbce6 100644
+--- a/notes/build.txt
++++ b/notes/build.txt
+@@ -132,4 +132,30 @@ usr/local/rv32/bin/riscv32-unknown-linux-gnu-ld --no-relax -nostdlib -L/home/ale
+         --whole-archive \
+         -lsys_sifive_e -lmach_sifive_e -larch_sifive_e \
+         --no-whole-archive \
+-        -lutil_sifive_e -linit_sifive_e -lgcc
+\ No newline at end of file
++        -lutil_sifive_e -linit_sifive_e -lgcc
++
++
++GDB
++=======
++0x81000000 -> 16MB
++0x80100000 -> 1MB
++
++INIT:     0x80200000; 
++SYS_CODE: 0x80300000;
++SYS_DATA: 0x80400000;
++
++find 0x80000000, 0x8fffffff, (char) 0x7F , 'E', 'L', 'F'       
++0x80000004
++0x80019b6c
++0x8006ec00
++0x8013a538
++
++entry_point     setup 0x80000080
++
++init global constructors
++
++app entry 
++
++
++=======
++        
+\ No newline at end of file
+diff --git a/qemu_help b/qemu_help
+new file mode 100644
+index 0000000..5af1707
+--- /dev/null
++++ b/qemu_help
+@@ -0,0 +1,451 @@
++QEMU emulator version 5.0.0 (v5.0.0-dirty)
++Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers
++usage: qemu-system-riscv32 [options] [disk_image]
++
++'disk_image' is a raw hard disk image for IDE hard disk 0
++
++Standard options:
++-h or -help     display this help and exit
++-version        display version information and exit
++-machine [type=]name[,prop[=value][,...]]
++                selects emulated machine ('-machine help' for list)
++                property accel=accel1[:accel2[:...]] selects accelerator
++                supported accelerators are kvm, xen, hax, hvf, whpx or tcg (default: tcg)
++                vmport=on|off|auto controls emulation of vmport (default: auto)
++                dump-guest-core=on|off include guest memory in a core dump (default=on)
++                mem-merge=on|off controls memory merge support (default: on)
++                aes-key-wrap=on|off controls support for AES key wrapping (default=on)
++                dea-key-wrap=on|off controls support for DEA key wrapping (default=on)
++                suppress-vmdesc=on|off disables self-describing migration (default=off)
++                nvdimm=on|off controls NVDIMM support (default=off)
++                enforce-config-section=on|off enforce configuration section migration (default=off)
++                memory-encryption=@var{} memory encryption object to use (default=none)
++                hmat=on|off controls ACPI HMAT support (default=off)
++-cpu cpu        select CPU ('-cpu help' for list)
++-accel [accel=]accelerator[,prop[=value][,...]]
++                select accelerator (kvm, xen, hax, hvf, whpx or tcg; use 'help' for a list)
++                igd-passthru=on|off (enable Xen integrated Intel graphics passthrough, default=off)
++                kernel-irqchip=on|off|split controls accelerated irqchip support (default=on)
++                kvm-shadow-mem=size of KVM shadow MMU in bytes
++                tb-size=n (TCG translation block cache size)
++                thread=single|multi (enable multi-threaded TCG)
++-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,dies=dies][,sockets=sockets]
++                set the number of CPUs to 'n' [default=1]
++                maxcpus= maximum number of total cpus, including
++                offline CPUs for hotplug, etc
++                cores= number of CPU cores on one socket (for PC, it's on one die)
++                threads= number of threads on one CPU core
++                dies= number of CPU dies on one socket (for PC only)
++                sockets= number of discrete sockets in the system
++-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]
++-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]
++-numa dist,src=source,dst=destination,val=distance
++-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]
++-numa hmat-lb,initiator=node,target=node,hierarchy=memory|first-level|second-level|third-level,data-type=access-latency|read-latency|write-latency[,latency=lat][,bandwidth=bw]
++-numa hmat-cache,node-id=node,size=size,level=level[,associativity=none|direct|complex][,policy=none|write-back|write-through][,line=size]
++-add-fd fd=fd,set=set[,opaque=opaque]
++                Add 'fd' to fd 'set'
++-set group.id.arg=value
++                set <arg> parameter for item <id> of type <group>
++                i.e. -set drive.$id.file=/path/to/image
++-global driver.property=value
++-global driver=driver,property=property,value=value
++                set a global default for a driver property
++-boot [order=drives][,once=drives][,menu=on|off]
++      [,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off]
++                'drives': floppy (a), hard disk (c), CD-ROM (d), network (n)
++                'sp_name': the file's name that would be passed to bios as logo picture, if menu=on
++                'sp_time': the period that splash picture last if menu=on, unit is ms
++                'rb_timeout': the timeout before guest reboot when boot failed, unit is ms
++-m [size=]megs[,slots=n,maxmem=size]
++                configure guest RAM
++                size: initial amount of guest memory
++                slots: number of hotplug slots (default: none)
++                maxmem: maximum amount of guest memory (default: none)
++NOTE: Some architectures might enforce a specific granularity
++-mem-path FILE  provide backing storage for guest RAM
++-mem-prealloc   preallocate guest memory (use with -mem-path)
++-k language     use keyboard layout (for example 'fr' for French)
++-audio-help     show -audiodev equivalent of the currently specified audio settings
++-audiodev [driver=]driver,id=id[,prop[=value][,...]]
++                specifies the audio backend to use
++                id= identifier of the backend
++                timer-period= timer period in microseconds
++                in|out.mixing-engine= use mixing engine to mix streams inside QEMU
++                in|out.fixed-settings= use fixed settings for host audio
++                in|out.frequency= frequency to use with fixed settings
++                in|out.channels= number of channels to use with fixed settings
++                in|out.format= sample format to use with fixed settings
++                valid values: s8, s16, s32, u8, u16, u32, f32
++                in|out.voices= number of voices to use
++                in|out.buffer-length= length of buffer in microseconds
++-audiodev none,id=id,[,prop[=value][,...]]
++                dummy driver that discards all output
++-audiodev oss,id=id[,prop[=value][,...]]
++                in|out.dev= path of the audio device to use
++                in|out.buffer-count= number of buffers
++                in|out.try-poll= attempt to use poll mode
++                try-mmap= try using memory mapped access
++                exclusive= open device in exclusive mode
++                dsp-policy= set timing policy (0..10), -1 to use fragment mode
++-audiodev wav,id=id[,prop[=value][,...]]
++                path= path of wav file to record
++-soundhw c1,... enable audio support
++                and only specified sound cards (comma separated list)
++                use '-soundhw help' to get the list of supported cards
++                use '-soundhw all' to enable all of them
++-device driver[,prop[=value][,...]]
++                add device (based on driver)
++                prop=value,... sets driver properties
++                use '-device help' to print all possible drivers
++                use '-device driver,help' to print all possible properties
++-name string1[,process=string2][,debug-threads=on|off]
++                set the name of the guest
++                string1 sets the window title and string2 the process name
++                When debug-threads is enabled, individual threads are given a separate name
++                NOTE: The thread names are for debugging and not a stable API.
++-uuid %08x-%04x-%04x-%04x-%012x
++                specify machine UUID
++
++Block device options:
++-fda/-fdb file  use 'file' as floppy disk 0/1 image
++-hda/-hdb file  use 'file' as IDE hard disk 0/1 image
++-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image
++-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)
++-blockdev [driver=]driver[,node-name=N][,discard=ignore|unmap]
++          [,cache.direct=on|off][,cache.no-flush=on|off]
++          [,read-only=on|off][,auto-read-only=on|off]
++          [,force-share=on|off][,detect-zeroes=on|off|unmap]
++          [,driver specific parameters...]
++                configure a block backend
++-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][,index=i]
++       [,cache=writethrough|writeback|none|directsync|unsafe][,format=f]
++       [,snapshot=on|off][,rerror=ignore|stop|report]
++       [,werror=ignore|stop|report|enospc][,id=name][,aio=threads|native]
++       [,readonly=on|off][,copy-on-read=on|off]
++       [,discard=ignore|unmap][,detect-zeroes=on|off|unmap]
++       [[,bps=b]|[[,bps_rd=r][,bps_wr=w]]]
++       [[,iops=i]|[[,iops_rd=r][,iops_wr=w]]]
++       [[,bps_max=bm]|[[,bps_rd_max=rm][,bps_wr_max=wm]]]
++       [[,iops_max=im]|[[,iops_rd_max=irm][,iops_wr_max=iwm]]]
++       [[,iops_size=is]]
++       [[,group=g]]
++                use 'file' as a drive image
++-mtdblock file  use 'file' as on-board Flash memory image
++-sd file        use 'file' as SecureDigital card image
++-pflash file    use 'file' as a parallel flash image
++-snapshot       write to temporary files instead of disk image files
++-fsdev local,id=id,path=path,security_model=mapped-xattr|mapped-file|passthrough|none
++ [,writeout=immediate][,readonly][,fmode=fmode][,dmode=dmode]
++ [[,throttling.bps-total=b]|[[,throttling.bps-read=r][,throttling.bps-write=w]]]
++ [[,throttling.iops-total=i]|[[,throttling.iops-read=r][,throttling.iops-write=w]]]
++ [[,throttling.bps-total-max=bm]|[[,throttling.bps-read-max=rm][,throttling.bps-write-max=wm]]]
++ [[,throttling.iops-total-max=im]|[[,throttling.iops-read-max=irm][,throttling.iops-write-max=iwm]]]
++ [[,throttling.iops-size=is]]
++-fsdev proxy,id=id,socket=socket[,writeout=immediate][,readonly]
++-fsdev proxy,id=id,sock_fd=sock_fd[,writeout=immediate][,readonly]
++-fsdev synth,id=id
++-virtfs local,path=path,mount_tag=tag,security_model=mapped-xattr|mapped-file|passthrough|none
++        [,id=id][,writeout=immediate][,readonly][,fmode=fmode][,dmode=dmode][,multidevs=remap|forbid|warn]
++-virtfs proxy,mount_tag=tag,socket=socket[,id=id][,writeout=immediate][,readonly]
++-virtfs proxy,mount_tag=tag,sock_fd=sock_fd[,id=id][,writeout=immediate][,readonly]
++-virtfs synth,mount_tag=tag[,id=id][,readonly]
++-iscsi [user=user][,password=password]
++       [,header-digest=CRC32C|CR32C-NONE|NONE-CRC32C|NONE
++       [,initiator-name=initiator-iqn][,id=target-iqn]
++       [,timeout=timeout]
++                iSCSI session parameters
++
++USB options:
++-usb            enable on-board USB host controller (if not enabled by default)
++-usbdevice name add the host or guest USB device 'name'
++
++Display options:
++-display gtk[,grab_on_hover=on|off][,gl=on|off]|
++-display vnc=<display>[,<optargs>]
++-display curses[,charset=<encoding>]
++-display none
++                select display backend type
++                The default display is equivalent to
++                "-display gtk"
++-nographic      disable graphical output and redirect serial I/Os to console
++-curses         shorthand for -display curses
++-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)
++-ctrl-grab      use Right-Ctrl to grab mouse (instead of Ctrl-Alt)
++-no-quit        disable SDL window close capability
++-sdl            shorthand for -display sdl
++-spice [port=port][,tls-port=secured-port][,x509-dir=<dir>]
++       [,x509-key-file=<file>][,x509-key-password=<file>]
++       [,x509-cert-file=<file>][,x509-cacert-file=<file>]
++       [,x509-dh-key-file=<file>][,addr=addr][,ipv4|ipv6|unix]
++       [,tls-ciphers=<list>]
++       [,tls-channel=[main|display|cursor|inputs|record|playback]]
++       [,plaintext-channel=[main|display|cursor|inputs|record|playback]]
++       [,sasl][,password=<secret>][,disable-ticketing]
++       [,image-compression=[auto_glz|auto_lz|quic|glz|lz|off]]
++       [,jpeg-wan-compression=[auto|never|always]]
++       [,zlib-glz-wan-compression=[auto|never|always]]
++       [,streaming-video=[off|all|filter]][,disable-copy-paste]
++       [,disable-agent-file-xfer][,agent-mouse=[on|off]]
++       [,playback-compression=[on|off]][,seamless-migration=[on|off]]
++       [,gl=[on|off]][,rendernode=<file>]
++   enable spice
++   at least one of {port, tls-port} is mandatory
++-portrait       rotate graphical output 90 deg left (only PXA LCD)
++-rotate <deg>   rotate graphical output some deg left (only PXA LCD)
++-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]
++                select video card type
++-full-screen    start in full screen
++-vnc <display>  shorthand for -display vnc=<display>
++
++Network options:
++-netdev user,id=str[,ipv4[=on|off]][,net=addr[/mask]][,host=addr]
++         [,ipv6[=on|off]][,ipv6-net=addr[/int]][,ipv6-host=addr]
++         [,restrict=on|off][,hostname=host][,dhcpstart=addr]
++         [,dns=addr][,ipv6-dns=addr][,dnssearch=domain][,domainname=domain]
++         [,tftp=dir][,tftp-server-name=name][,bootfile=f][,hostfwd=rule][,guestfwd=rule][,smb=dir[,smbserver=addr]]
++                configure a user mode network backend with ID 'str',
++                its DHCP server and optional services
++-netdev tap,id=str[,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile]
++         [,br=bridge][,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off]
++         [,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n]
++         [,poll-us=n]
++                configure a host TAP network backend with ID 'str'
++                connected to a bridge (default=br0)
++                use network scripts 'file' (default=/etc/qemu-ifup)
++                to configure it and 'dfile' (default=/etc/qemu-ifdown)
++                to deconfigure it
++                use '[down]script=no' to disable script execution
++                use network helper 'helper' (default=/usr/local/libexec/qemu-bridge-helper) to
++                configure it
++                use 'fd=h' to connect to an already opened TAP interface
++                use 'fds=x:y:...:z' to connect to already opened multiqueue capable TAP interfaces
++                use 'sndbuf=nbytes' to limit the size of the send buffer (the
++                default is disabled 'sndbuf=0' to enable flow control set 'sndbuf=1048576')
++                use vnet_hdr=off to avoid enabling the IFF_VNET_HDR tap flag
++                use vnet_hdr=on to make the lack of IFF_VNET_HDR support an error condition
++                use vhost=on to enable experimental in kernel accelerator
++                    (only has effect for virtio guests which use MSIX)
++                use vhostforce=on to force vhost on for non-MSIX virtio guests
++                use 'vhostfd=h' to connect to an already opened vhost net device
++                use 'vhostfds=x:y:...:z to connect to multiple already opened vhost net devices
++                use 'queues=n' to specify the number of queues to be created for multiqueue TAP
++                use 'poll-us=n' to speciy the maximum number of microseconds that could be
++                spent on busy polling for vhost net
++-netdev bridge,id=str[,br=bridge][,helper=helper]
++                configure a host TAP network backend with ID 'str' that is
++                connected to a bridge (default=br0)
++                using the program 'helper (default=/usr/local/libexec/qemu-bridge-helper)
++-netdev l2tpv3,id=str,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport]
++         [,rxsession=rxsession],txsession=txsession[,ipv6=on/off][,udp=on/off]
++         [,cookie64=on/off][,counter][,pincounter][,txcookie=txcookie]
++         [,rxcookie=rxcookie][,offset=offset]
++                configure a network backend with ID 'str' connected to
++                an Ethernet over L2TPv3 pseudowire.
++                Linux kernel 3.3+ as well as most routers can talk
++                L2TPv3. This transport allows connecting a VM to a VM,
++                VM to a router and even VM to Host. It is a nearly-universal
++                standard (RFC3931). Note - this implementation uses static
++                pre-configured tunnels (same as the Linux kernel).
++                use 'src=' to specify source address
++                use 'dst=' to specify destination address
++                use 'udp=on' to specify udp encapsulation
++                use 'srcport=' to specify source udp port
++                use 'dstport=' to specify destination udp port
++                use 'ipv6=on' to force v6
++                L2TPv3 uses cookies to prevent misconfiguration as
++                well as a weak security measure
++                use 'rxcookie=0x012345678' to specify a rxcookie
++                use 'txcookie=0x012345678' to specify a txcookie
++                use 'cookie64=on' to set cookie size to 64 bit, otherwise 32
++                use 'counter=off' to force a 'cut-down' L2TPv3 with no counter
++                use 'pincounter=on' to work around broken counter handling in peer
++                use 'offset=X' to add an extra offset between header and data
++-netdev socket,id=str[,fd=h][,listen=[host]:port][,connect=host:port]
++                configure a network backend to connect to another network
++                using a socket connection
++-netdev socket,id=str[,fd=h][,mcast=maddr:port[,localaddr=addr]]
++                configure a network backend to connect to a multicast maddr and port
++                use 'localaddr=addr' to specify the host address to send packets from
++-netdev socket,id=str[,fd=h][,udp=host:port][,localaddr=host:port]
++                configure a network backend to connect to another network
++                using an UDP tunnel
++-netdev vhost-user,id=str,chardev=dev[,vhostforce=on|off]
++                configure a vhost-user network, backed by a chardev 'dev'
++-netdev hubport,id=str,hubid=n[,netdev=nd]
++                configure a hub port on the hub with ID 'n'
++-nic [tap|bridge|user|l2tpv3|vhost-user|socket][,option][,...][mac=macaddr]
++                initialize an on-board / default host NIC (using MAC address
++                macaddr) and connect it to the given host network backend
++-nic none       use it alone to have zero network devices (the default is to
++                provided a 'user' network connection)
++-net nic[,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]
++                configure or create an on-board (or machine default) NIC and
++                connect it to hub 0 (please use -nic unless you need a hub)
++-net [user|tap|bridge|socket][,option][,option][,...]
++                old way to initialize a host network interface
++                (use the -netdev option if possible instead)
++
++Character device options:
++-chardev help
++-chardev null,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev socket,id=id[,host=host],port=port[,to=to][,ipv4][,ipv6][,nodelay][,reconnect=seconds]
++         [,server][,nowait][,telnet][,websocket][,reconnect=seconds][,mux=on|off]
++         [,logfile=PATH][,logappend=on|off][,tls-creds=ID][,tls-authz=ID] (tcp)
++-chardev socket,id=id,path=path[,server][,nowait][,telnet][,websocket][,reconnect=seconds]
++         [,mux=on|off][,logfile=PATH][,logappend=on|off] (unix)
++-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr]
++         [,localport=localport][,ipv4][,ipv6][,mux=on|off]
++         [,logfile=PATH][,logappend=on|off]
++-chardev msmouse,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]
++         [,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev ringbuf,id=id[,size=size][,logfile=PATH][,logappend=on|off]
++-chardev file,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev pipe,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev pty,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev stdio,id=id[,mux=on|off][,signal=on|off][,logfile=PATH][,logappend=on|off]
++-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev tty,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev parallel,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
++-chardev parport,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
++
++TPM device options:
++-tpmdev passthrough,id=id[,path=path][,cancel-path=path]
++                use path to provide path to a character device; default is /dev/tpm0
++                use cancel-path to provide path to TPM's cancel sysfs entry; if
++                not provided it will be searched for in /sys/class/misc/tpm?/device
++-tpmdev emulator,id=id,chardev=dev
++                configure the TPM device using chardev backend
++
++Linux/Multiboot boot specific:
++-kernel bzImage use 'bzImage' as kernel image
++-append cmdline use 'cmdline' as kernel command line
++-initrd file    use 'file' as initial ram disk
++-dtb    file    use 'file' as device tree image
++
++Debug/Expert options:
++-fw_cfg [name=]<name>,file=<file>
++                add named fw_cfg entry with contents from file
++-fw_cfg [name=]<name>,string=<str>
++                add named fw_cfg entry with contents from string
++-serial dev     redirect the serial port to char device 'dev'
++-parallel dev   redirect the parallel port to char device 'dev'
++-monitor dev    redirect the monitor to char device 'dev'
++-qmp dev        like -monitor but opens in 'control' mode
++-qmp-pretty dev like -qmp but uses pretty JSON formatting
++-mon [chardev=]name[,mode=readline|control][,pretty[=on|off]]
++-debugcon dev   redirect the debug console to char device 'dev'
++-pidfile file   write PID to 'file'
++-singlestep     always run in singlestep mode
++--preconfig     pause QEMU before machine is initialized (experimental)
++-S              freeze CPU at startup (use 'c' to start execution)
++-realtime [mlock=on|off]
++                run qemu with realtime features
++                mlock=on|off controls mlock support (default: on)
++-overcommit [mem-lock=on|off][cpu-pm=on|off]
++                run qemu with overcommit hints
++                mem-lock=on|off controls memory lock support (default: off)
++                cpu-pm=on|off controls cpu power management (default: off)
++-gdb dev        accept gdb connection on 'dev'. (QEMU defaults to starting
++                the guest without waiting for gdb to connect; use -S too
++                if you want it to not start execution.)
++-s              shorthand for -gdb tcp::1234
++-d item1,...    enable logging of specified items (use '-d help' for a list of log items)
++-D logfile      output log to logfile (default stderr)
++-dfilter range,..  filter debug output to range of addresses (useful for -d cpu,exec,etc..)
++-seed number       seed the pseudo-random number generator
++-L path         set the directory for the BIOS, VGA BIOS and keymaps
++-bios file      set the filename for the BIOS
++-enable-kvm     enable KVM full virtualization support
++-xen-domid id   specify xen guest domain id
++-xen-attach     attach to existing xen domain
++                libxl will use this when starting QEMU
++-xen-domid-restrict     restrict set of available xen operations
++                        to specified domain id. (Does not affect
++                        xenpv machine type).
++-no-reboot      exit instead of rebooting
++-no-shutdown    stop before shutdown
++-loadvm [tag|id]
++                start right away with a saved state (loadvm in monitor)
++-daemonize      daemonize QEMU after initializing
++-option-rom rom load a file, rom, into the option ROM space
++-rtc [base=utc|localtime|<datetime>][,clock=host|rt|vm][,driftfix=none|slew]
++                set the RTC base and clock, enable drift fix for clock ticks (x86 only)
++-icount [shift=N|auto][,align=on|off][,sleep=on|off,rr=record|replay,rrfile=<filename>,rrsnapshot=<snapshot>]
++                enable virtual instruction counter with 2^N clock ticks per
++                instruction, enable aligning the host and virtual clocks
++                or disable real time cpu sleeping
++-watchdog model
++                enable virtual hardware watchdog [default=none]
++-watchdog-action reset|shutdown|poweroff|inject-nmi|pause|debug|none
++                action when watchdog fires [default=reset]
++-echr chr       set terminal escape character instead of ctrl-a
++-show-cursor    show cursor
++-tb-size n      set TB size
++-incoming tcp:[host]:port[,to=maxport][,ipv4][,ipv6]
++-incoming rdma:host:port[,ipv4][,ipv6]
++-incoming unix:socketpath
++                prepare for incoming migration, listen on
++                specified protocol and socket address
++-incoming fd:fd
++-incoming exec:cmdline
++                accept incoming migration on given file descriptor
++                or from given external command
++-incoming defer
++                wait for the URI to be specified via migrate_incoming
++-only-migratable     allow only migratable devices
++-nodefaults     don't create default devices
++-chroot dir     chroot to dir just before starting the VM
++-runas user     change to user id user just before starting the VM
++                user can be numeric uid:gid instead
++-sandbox on[,obsolete=allow|deny][,elevateprivileges=allow|deny|children]
++          [,spawn=allow|deny][,resourcecontrol=allow|deny]
++                Enable seccomp mode 2 system call filter (default 'off').
++                use 'obsolete' to allow obsolete system calls that are provided
++                    by the kernel, but typically no longer used by modern
++                    C library implementations.
++                use 'elevateprivileges' to allow or deny QEMU process to elevate
++                    its privileges by blacklisting all set*uid|gid system calls.
++                    The value 'children' will deny set*uid|gid system calls for
++                    main QEMU process but will allow forks and execves to run unprivileged
++                use 'spawn' to avoid QEMU to spawn new threads or processes by
++                     blacklisting *fork and execve
++                use 'resourcecontrol' to disable process affinity and schedular priority
++-readconfig <file>
++-writeconfig <file>
++                read/write config file
++-no-user-config
++                do not load default user-provided config files at startup
++-trace [[enable=]<pattern>][,events=<file>][,file=<file>]
++                specify tracing options
++-plugin [file=]<file>[,arg=<string>]
++                load a plugin
++-enable-fips    enable FIPS 140-2 compliance
++-msg timestamp[=on|off]
++                control error message format
++                timestamp=on enables timestamps (default: off)
++-dump-vmstate <file>
++                Output vmstate information in JSON format to file.
++                Use the scripts/vmstate-static-checker.py file to
++                check for possible regressions in migration code
++                by comparing two such vmstate dumps.
++-enable-sync-profile
++                enable synchronization profiling
++
++Generic object creation:
++-object TYPENAME[,PROP1=VALUE1,...]
++                create a new object of type TYPENAME setting properties
++                in the order they are specified.  Note that the 'id'
++                property must be set.  These objects are placed in the
++                '/objects' path.
++
++During emulation, the following keys are useful:
++ctrl-alt-f      toggle full screen
++ctrl-alt-n      switch to virtual console 'n'
++ctrl-alt        toggle mouse and keyboard grab
++
++When using -nographic, press 'ctrl-a h' to get some help.
++
++See <https://qemu.org/contribute/report-a-bug> for how to report bugs.
++More information on the QEMU project at <https://qemu.org>.
+diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
+index 194e2e5..a82e78c 100644
+--- a/src/setup/setup_sifive_e.cc
++++ b/src/setup/setup_sifive_e.cc
+@@ -2,6 +2,8 @@
+ 
+ #include <utility/ostream.h>
+ 
++#include <utility/elf.h>
++#include <utility/debug.h>
+ #include <system/info.h>
+ #include <architecture.h>
+ #include <machine.h>
+@@ -24,11 +26,13 @@ extern "C"
+         // _start();
+     }
+     void _print(const char * s) { Display::puts(s); }
++    void _panic() { Machine::panic(); }
++
+ }
+ 
+-char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________";
++// char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
++char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________________________________________________________________________________________________________________________________________";
+ System_Info * si;
+-EPOS::S::U::OStream kout, kerr;
+ 
+ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+     Reg id = CPU::mcause();
+@@ -42,11 +46,20 @@ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+ }
+ 
+ __BEGIN_SYS
++EPOS::S::U::OStream kout, kerr;
++char * bi;
+ 
+ class Setup_SifiveE {
+ private:
++    // Physical memory map
++    static const unsigned int SYS_INFO = Memory_Map::SYS_INFO;
++    static const unsigned int PAGE_TABLES = Traits<Machine>::PAGE_TABLES;
++    static const unsigned int MEM_BASE = Memory_Map::MEM_BASE;
++    static const unsigned int MEM_TOP = Memory_Map::MEM_TOP;
++    
+     typedef CPU::Reg Reg;
+     typedef MMU::RV32_Flags RV32_Flags;
++    typedef MMU::Page Page;
+     typedef MMU::Page_Table Page_Table;
+     typedef MMU::Page_Directory Page_Directory;
+     typedef MMU::PT_Entry PT_Entry;
+@@ -57,8 +70,254 @@ public:
+     static void setup_supervisor_environment();
+     static void build_page_tables();
+     static void clean_bss();
++    static void build_lm();
++    static void load_parts();
+ };
+ 
++// !P2:
++
++void Setup_SifiveE::load_parts()
++{
++    // Relocate System_Info
++    if(sizeof(System_Info) > sizeof(Page))
++        db<Setup>(WRN) << "System_Info is bigger than a page (" << sizeof(System_Info) << ")!" << endl;
++    memcpy(reinterpret_cast<void *>(SYS_INFO), si, sizeof(System_Info));
++
++    // Load INIT
++    ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
++    ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
++    
++    if(si->lm.has_ini) {
++        db<Setup>(TRC) << "Setup_SifiveE::load_init()" << endl;
++        if(ini_elf->load_segment(0) < 0) {
++            db<Setup>(ERR) << "INIT code segment was corrupted during SETUP!" << endl;
++            _panic();
++        }
++        
++        for(int i = 1; i < ini_elf->segments(); i++)
++            if(ini_elf->load_segment(i) < 0) {
++                db<Setup>(ERR) << "INIT data segment was corrupted during SETUP!" << endl;
++                _panic();
++            }
++    }
++    
++    if((long unsigned int)ini_elf->segment_size(0) > sys_elf->segment_address(0) - ini_elf->segment_address(0)) {
++        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
++        _panic();
++    } 
++    db<Setup>(TRC) << "init has " << hex << sys_elf->segment_address(0) - ini_elf->segment_address(0) - ini_elf->segment_size(0) << " unused bytes of memory" << endl;
++    
++    // Load SYSTEM
++    if(si->lm.has_sys) {
++        db<Setup>(TRC) << "Setup_SifiveE::load_system()" << endl;
++        if(sys_elf->load_segment(0) < 0) {
++            db<Setup>(ERR) << "system code segment was corrupted during SETUP!" << endl;
++            _panic();
++        }
++        for(int i = 1; i < sys_elf->segments(); i++)
++            if(sys_elf->load_segment(i) < 0) {
++                db<Setup>(ERR) << "system data segment was corrupted during SETUP!" << endl;
++                _panic();
++            }
++    }
++    
++    if((long unsigned int)sys_elf->segment_size(0) > sys_elf->segment_address(1) - sys_elf->segment_address(0)) {
++        db<Setup>(ERR) << "sys code is larger than its reserved memory" << endl;
++        _panic();
++    } 
++    db<Setup>(TRC) << "sys code has " << hex << sys_elf->segment_address(1) - sys_elf->segment_address(0) - sys_elf->segment_size(0) << " unused bytes of memory" << endl;
++    
++    if((long unsigned int)ini_elf->segment_size(1) > sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1)) {
++        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
++        _panic();
++    } 
++    db<Setup>(TRC) << "sys data has " << hex << sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1) - ini_elf->segment_size(1) << " unused bytes of memory" << endl;
++
++    // // Load APP
++    // if(si->lm.has_app) {
++    //     ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
++    //     db<Setup>(TRC) << "PC_Setup::load_app()" << endl;
++    //     if(app_elf->load_segment(0) < 0) {
++    //         db<Setup>(ERR) << "Application code segment was corrupted during SETUP!" << endl;
++    //         _panic();
++    //     }
++    //     for(int i = 1; i < app_elf->segments(); i++)
++    //         if(app_elf->load_segment(i) < 0) {
++    //             db<Setup>(ERR) << "Application data segment was corrupted during SETUP!" << endl;
++    //             _panic();
++    //         }
++    // }
++
++}
++
++
++void Setup_SifiveE::build_lm()
++{
++    // Get boot image structure
++    si->lm.has_stp = (si->bm.setup_offset != -1u);
++    si->lm.has_ini = (si->bm.init_offset != -1u);
++    si->lm.has_sys = (si->bm.system_offset != -1u);
++    si->lm.has_app = (si->bm.application_offset != -1u);
++    si->lm.has_ext = (si->bm.extras_offset != -1u);
++
++    // Check SETUP integrity and get the size of its segments
++    si->lm.stp_entry = 0;
++    si->lm.stp_segments = 0;
++    si->lm.stp_code = ~0U;
++    si->lm.stp_code_size = 0;
++    si->lm.stp_data = ~0U;
++    si->lm.stp_data_size = 0;
++
++    db<Spin>(ERR) << "SETUP ELF image is corrupted!" << endl;
++    EPOS::S::kout << "oioioioioio" << endl;
++    bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE);
++    if(si->lm.has_stp) {
++        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
++        if(!stp_elf->valid()) {
++            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
++            _panic();
++        }
++
++        si->lm.stp_entry = stp_elf->entry();
++        si->lm.stp_segments = stp_elf->segments();
++        si->lm.stp_code = stp_elf->segment_address(0);
++        si->lm.stp_code_size = stp_elf->segment_size(0);
++        if(stp_elf->segments() > 1) {
++            for(int i = 1; i < stp_elf->segments(); i++) {
++                if(stp_elf->segment_type(i) != PT_LOAD)
++                    continue;
++                if(stp_elf->segment_address(i) < si->lm.stp_data)
++                    si->lm.stp_data = stp_elf->segment_address(i);
++                si->lm.stp_data_size += stp_elf->segment_size(i);
++            }
++        }
++    }
++
++
++    // Check INIT integrity and get the size of its segments
++    si->lm.ini_entry = 0;
++    si->lm.ini_segments = 0;
++    si->lm.ini_code = ~0U;
++    si->lm.ini_code_size = 0;
++    si->lm.ini_data = ~0U;
++    si->lm.ini_data_size = 0;
++    if(si->lm.has_ini) {
++        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
++        if(!ini_elf->valid()) {
++            db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
++            _panic();
++        }
++
++        si->lm.ini_entry = ini_elf->entry();
++        si->lm.ini_segments = ini_elf->segments();
++        si->lm.ini_code = ini_elf->segment_address(0);
++        si->lm.ini_code_size = ini_elf->segment_size(0);
++        if(ini_elf->segments() > 1) {
++            for(int i = 1; i < ini_elf->segments(); i++) {
++                if(ini_elf->segment_type(i) != PT_LOAD)
++                    continue;
++                if(ini_elf->segment_address(i) < si->lm.ini_data)
++                    si->lm.ini_data = ini_elf->segment_address(i);
++                si->lm.ini_data_size += ini_elf->segment_size(i);
++            }
++        }
++    }
++
++    // Check SYSTEM integrity and get the size of its segments
++    si->lm.sys_entry = 0;
++    si->lm.sys_segments = 0;
++    si->lm.sys_code = ~0U;
++    si->lm.sys_code_size = 0;
++    si->lm.sys_data = ~0U;
++    si->lm.sys_data_size = 0;
++    // si->lm.sys_stack = SYS_STACK;
++    // si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
++    if(si->lm.has_sys) {
++        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
++        if(!sys_elf->valid()) {
++            db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
++            _panic();
++        }
++
++        si->lm.sys_entry = sys_elf->entry();
++        si->lm.sys_segments = sys_elf->segments();
++        si->lm.sys_code = sys_elf->segment_address(0);
++        si->lm.sys_code_size = sys_elf->segment_size(0);
++        if(sys_elf->segments() > 1) {
++            for(int i = 1; i < sys_elf->segments(); i++) {
++                if(sys_elf->segment_type(i) != PT_LOAD)
++                    continue;
++                if(sys_elf->segment_address(i) < si->lm.sys_data)
++                    si->lm.sys_data = sys_elf->segment_address(i);
++                si->lm.sys_data_size += sys_elf->segment_size(i);
++            }
++        }
++
++        // if(si->lm.sys_code != SYS_CODE) {
++        //     db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
++        //     _panic();
++        // }
++        // if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
++        //     db<Setup>(ERR) << "OS code segment is too large!" << endl;
++        //     _panic();
++        // }
++        // if(si->lm.sys_data != SYS_DATA) {
++        //     db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
++        //     _panic();
++        // }
++        // if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack) {
++        //     db<Setup>(ERR) << "OS data segment is too large!" << endl;
++        //     panic();
++        // }
++        // if(MMU::page_tables(MMU::pages(si->lm.sys_stack - SYS + si->lm.sys_stack_size)) > 1) {
++        //     db<Setup>(ERR) << "OS stack segment is too large!" << endl;
++        //     _panic();
++        // }
++    }
++
++    // Check APPLICATION integrity and get the size of its segments
++    si->lm.app_entry = 0;
++    si->lm.app_segments = 0;
++    si->lm.app_code = ~0U;
++    si->lm.app_code_size = 0;
++    si->lm.app_data = ~0U;
++    si->lm.app_data_size = 0;
++    if(si->lm.has_app) {
++        ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
++        if(!app_elf->valid()) {
++            db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
++            _panic();
++        }
++        si->lm.app_entry = app_elf->entry();
++        si->lm.app_segments = app_elf->segments();
++        si->lm.app_code = app_elf->segment_address(0);
++        si->lm.app_code_size = app_elf->segment_size(0);
++        if(app_elf->segments() > 1) {
++            for(int i = 1; i < app_elf->segments(); i++) {
++                if(app_elf->segment_type(i) != PT_LOAD)
++                    continue;
++                if(app_elf->segment_address(i) < si->lm.app_data)
++                    si->lm.app_data = app_elf->segment_address(i);
++                si->lm.app_data_size += app_elf->segment_size(i);
++            }
++        }
++        // if(Traits<System>::multiheap) { // Application heap in data segment
++        //     si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
++        //     si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
++        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
++        //     si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
++        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
++        // }
++        // if(si->lm.has_ext) { // Check for EXTRA data in the boot image
++        //     si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
++        //     si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
++        //     if(Traits<System>::multiheap)
++        //         si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
++        //     si->lm.app_data_size += si->lm.app_extra_size;
++        // }
++    }
++}
++
+ void Setup_SifiveE::build_page_tables()
+ {
+     // Address of the Directory
+@@ -103,8 +362,13 @@ void Setup_SifiveE::setup_supervisor_environment()
+     build_page_tables();
+ 
+     //!P2: How could machine pre_init run before Init_System if it was linked w/ SYS?
+-    // if(CPU::id() == 0)
+-    //     Display::init();
++    if(CPU::id() == 0)
++        Display::init();
++
++    si = reinterpret_cast<System_Info*>(placeholder);
++    build_lm();
++    
++    load_parts();
+ 
+     // db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
+ 
+@@ -117,7 +381,8 @@ void Setup_SifiveE::setup_supervisor_environment()
+ 
+     // forward everything
+     CPU::satp((0x1 << 31) | (Traits<Machine>::PAGE_TABLES >> 12));
+-    // CPU::sepc_write((unsigned)&_start);
++    
++    CPU::sepc_write(si->lm.ini_entry);
+ 
+     // Interrupts will remain disable until the Context::load at Init_First
+     CPU::sstatus_write(CPU::SPP_S);
+@@ -128,7 +393,6 @@ void Setup_SifiveE::setup_supervisor_environment()
+ 
+ void Setup_SifiveE::setup_machine_environment()
+ {
+-    si = reinterpret_cast<System_Info*>(placeholder);
+     // We first configure the M-mode CSRs and then switch to S-mode
+     // configure paging. After that, we won't return to M-mode; an exception
+     // is the forwarding of ints and excps to S-mode.
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+deleted file mode 120000
+index fa235ad..0000000
+--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
++++ /dev/null
+@@ -1 +0,0 @@
+-../scheduler_rm_test/scheduler_rm_test.cc
+\ No newline at end of file
+diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
+new file mode 100644
+index 0000000..56fd387
+--- /dev/null
++++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
+@@ -0,0 +1,129 @@
++// EPOS Periodic Thread Component Test Program
++
++#include <time.h>
++#include <real-time.h>
++
++using namespace EPOS;
++
++const unsigned int iterations = 100;
++const unsigned int period_a = 100; // ms
++const unsigned int period_b = 80; // ms
++const unsigned int period_c = 60; // ms
++const unsigned int wcet_a = 50; // ms
++const unsigned int wcet_b = 20; // ms
++const unsigned int wcet_c = 10; // ms
++
++int func_a();
++int func_b();
++int func_c();
++long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
++
++OStream cout;
++Chronometer chrono;
++Periodic_Thread * thread_a;
++Periodic_Thread * thread_b;
++Periodic_Thread * thread_c;
++
++inline void exec(char c, unsigned int time = 0) // in miliseconds
++{
++    // Delay was not used here to prevent scheduling interference due to blocking
++    Microsecond elapsed = chrono.read() / 1000;
++
++    cout << "\n" << elapsed << "\t" << c
++         << "\t[p(A)=" << thread_a->priority()
++         << ", p(B)=" << thread_b->priority()
++         << ", p(C)=" << thread_c->priority() << "]";
++
++    if(time) {
++        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
++            if(last != elapsed) {
++                cout << "\n" << elapsed << "\t" << c
++                    << "\t[p(A)=" << thread_a->priority()
++                    << ", p(B)=" << thread_b->priority()
++                    << ", p(C)=" << thread_c->priority() << "]";
++                last = elapsed;
++            }
++    }
++}
++
++
++int main()
++{
++    cout << "Periodic Thread Component Test" << endl;
++
++    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
++    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
++    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
++    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
++
++    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
++
++    // p,d,c,act,t
++    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
++    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
++    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
++
++    exec('M');
++
++    chrono.start();
++
++    int status_a = thread_a->join();
++    int status_b = thread_b->join();
++    int status_c = thread_c->join();
++
++    chrono.stop();
++
++    exec('M');
++
++    cout << "\n... done!" << endl;
++    cout << "\n\nThread A exited with status \"" << char(status_a)
++         << "\", thread B exited with status \"" << char(status_b)
++         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
++
++    cout << "\nThe estimated time to run the test was "
++         << max(period_a, period_b, period_c) * iterations
++         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
++
++    cout << "I'm also done, bye!" << endl;
++
++    return 0;
++}
++
++int func_a()
++{
++    exec('A');
++
++    do {
++        exec('a', wcet_a);
++    } while (Periodic_Thread::wait_next());
++
++    exec('A');
++
++    return 'A';
++}
++
++int func_b()
++{
++    exec('B');
++
++    do {
++        exec('b', wcet_b);
++    } while (Periodic_Thread::wait_next());
++
++    exec('B');
++
++    return 'B';
++}
++
++int func_c()
++{
++    exec('C');
++
++    do {
++        exec('c', wcet_c);
++    } while (Periodic_Thread::wait_next());
++
++    exec('C');
++
++    return 'C';
++}
+diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
+index 75a2801..c7ed1ff 100644
+--- a/tools/eposmkbi/eposmkbi.cc
++++ b/tools/eposmkbi/eposmkbi.cc
+@@ -166,6 +166,11 @@ int main(int argc, char **argv)
+     unsigned int image_size = 0;
+     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
+ 
++    // !P2:
++    // riscv boot jump: jal 0x78
++    unsigned int boot_jump = 0b111100000000000000001101111; 
++    image_size += put_number(fd_img, boot_jump);
++    
+     // Add BOOT
+     if(CONFIG.boot_length_max > 0) {
+         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
+@@ -181,6 +186,8 @@ int main(int argc, char **argv)
+         }
+     }
+     unsigned int boot_size = image_size;
++    // !P2:
++    boot_size = 0;
+ 
+     // Determine if System_Info is needed and how it must be handled
+     bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
+@@ -210,10 +217,10 @@ int main(int argc, char **argv)
+     si.bm.space_z  = CONFIG.space_z;
+ 
+     fprintf(out, "\nsi.bm.n_cpus %u", si.bm.n_cpus);
+-    fprintf(out, "\nsi.bm.mem_base %u", si.bm.mem_base);
+-    fprintf(out, "\nsi.bm.mem_top %u", si.bm.mem_top);
+-    fprintf(out, "\nsi.bm.mio_base %u", si.bm.mio_base);
+-    fprintf(out, "\nsi.bm.mio_top %u", si.bm.mio_top);
++    fprintf(out, "\nsi.bm.mem_base %08x", si.bm.mem_base);
++    fprintf(out, "\nsi.bm.mem_top %08x", si.bm.mem_top);
++    fprintf(out, "\nsi.bm.mio_base %08x", si.bm.mio_base);
++    fprintf(out, "\nsi.bm.mio_top %08x", si.bm.mio_top);
+     fprintf(out, "\nsi.bm.node_id %u", si.bm.node_id);
+     fprintf(out, "\nsi.bm.space_x %u", si.bm.space_x);
+     fprintf(out, "\nsi.bm.space_y %u", si.bm.space_y);
diff --git a/docs/tmp/diff.patch b/docs/tmp/diff.patch
new file mode 100644
index 0000000..b92f670
--- /dev/null
+++ b/docs/tmp/diff.patch
@@ -0,0 +1,737 @@
+diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
+index 824a26a..8fe3f88 100644
+--- a/app/hello/hello_traits.h
++++ b/app/hello/hello_traits.h
+@@ -9,7 +9,7 @@ __BEGIN_SYS
+ template<> struct Traits<Build>: public Traits_Tokens
+ {
+     // Basic configuration
+-    static const unsigned int MODE = LIBRARY;
++    static const unsigned int MODE = BUILTIN;
+     static const unsigned int ARCHITECTURE = RV32;
+     static const unsigned int MACHINE = RISCV;
+     static const unsigned int MODEL = SiFive_E;
+diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
+index dca58e8..44d50d4 100644
+--- a/app/philosophers_dinner/philosophers_dinner_traits.h
++++ b/app/philosophers_dinner/philosophers_dinner_traits.h
+@@ -9,7 +9,7 @@ __BEGIN_SYS
+ template<> struct Traits<Build>: public Traits_Tokens
+ {
+     // Basic configuration
+-    static const unsigned int MODE = LIBRARY;
++    static const unsigned int MODE = BUILTIN;
+     static const unsigned int ARCHITECTURE = RV32;
+     static const unsigned int MACHINE = RISCV;
+     static const unsigned int MODEL = SiFive_E;
+diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
+index d1ca6d5..bdd7794 100644
+--- a/app/producer_consumer/producer_consumer_traits.h
++++ b/app/producer_consumer/producer_consumer_traits.h
+@@ -9,7 +9,7 @@ __BEGIN_SYS
+ template<> struct Traits<Build>: public Traits_Tokens
+ {
+     // Basic configuration
+-    static const unsigned int MODE = LIBRARY;
++    static const unsigned int MODE = BUILTIN;
+     static const unsigned int ARCHITECTURE = RV32;
+     static const unsigned int MACHINE = RISCV;
+     static const unsigned int MODEL = SiFive_E;
+diff --git a/app/test_rm1/test_rm1_traits.h b/app/test_rm1/test_rm1_traits.h
+index 16f955f..86e9470 100644
+--- a/app/test_rm1/test_rm1_traits.h
++++ b/app/test_rm1/test_rm1_traits.h
+@@ -9,7 +9,7 @@ __BEGIN_SYS
+ template<> struct Traits<Build>: public Traits_Tokens
+ {
+     // Basic configuration
+-    static const unsigned int MODE = LIBRARY;
++    static const unsigned int MODE = BUILTIN;
+     static const unsigned int ARCHITECTURE = RV32;
+     static const unsigned int MACHINE = RISCV;
+     static const unsigned int MODEL = SiFive_E;
+diff --git a/app/test_rm2/test_rm2_traits.h b/app/test_rm2/test_rm2_traits.h
+index 9bea085..b9053c9 100644
+--- a/app/test_rm2/test_rm2_traits.h
++++ b/app/test_rm2/test_rm2_traits.h
+@@ -9,7 +9,7 @@ __BEGIN_SYS
+ template<> struct Traits<Build>: public Traits_Tokens
+ {
+     // Basic configuration
+-    static const unsigned int MODE = LIBRARY;
++    static const unsigned int MODE = BUILTIN;
+     static const unsigned int ARCHITECTURE = RV32;
+     static const unsigned int MACHINE = RISCV;
+     static const unsigned int MODEL = SiFive_E;
+diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
+index aefc3ef..20fcb78 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_info.h
++++ b/include/machine/riscv/sifive_e/sifive_e_info.h
+@@ -7,6 +7,24 @@
+ 
+ __BEGIN_SYS
+ 
++
++struct App_Load_Map
++{
++private:
++    typedef unsigned int LAddr;
++    typedef unsigned int PAddr;
++    typedef unsigned int Size;
++
++public:
++    LAddr app_entry;
++    Size  app_segments;
++    LAddr app_code;
++    Size  app_code_size;
++    LAddr app_data;
++    LAddr app_stack;
++    LAddr app_heap;
++    Size  app_data_size;
++};
+ struct System_Info
+ {
+ private:
+@@ -33,7 +51,8 @@ public:
+         Size setup_offset;                // Image offsets (-1 => not present)
+         Size init_offset;
+         Size system_offset;
+-        Size application_offset;
++        Size application_offset[8];
++        unsigned int n_apps;
+         Size extras_offset;
+     };
+ 
+@@ -81,17 +100,19 @@ public:
+         Size  sys_data_size;
+         LAddr sys_stack;
+         Size  sys_stack_size;
+-        LAddr app_entry;
+-        Size  app_segments;
+-        LAddr app_code;
+-        Size  app_code_size;
+-        LAddr app_data;
+-        LAddr app_stack;
+-        LAddr app_heap;
+-        Size  app_data_size;
++        App_Load_Map app[8];
++        // LAddr app_entry;
++        // Size  app_segments;
++        // LAddr app_code;
++        // Size  app_code_size;
++        // LAddr app_data;
++        // LAddr app_stack;
++        // LAddr app_heap;
++        // Size  app_data_size;
+         PAddr app_extra;
+         Size  app_extra_size;
+     };
++    
+ 
+ public:
+     Boot_Map bm;
+diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+index ca90831..f36d8b7 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
++++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+@@ -31,6 +31,7 @@ struct Memory_Map
+         MIO_TOP         = Traits<Machine>::MIO_TOP,
+         BOOT_STACK      = Traits<Machine>::BOOT_STACK,
+         PAGE_TABLES     = Traits<Machine>::PAGE_TABLES,
++        MMODE_F         = Traits<Machine>::MMODE_F,
+     };
+ 
+     // Logical Address Space
+diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
+index 675a232..3313aaa 100644
+--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
++++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
+@@ -32,7 +32,8 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
+     static const unsigned int VECTOR_TABLE      = NOT_USED;
+     static const unsigned int PAGE_TABLES       = 0x87ffffff + 1 - 16*1024 - ((1024+1)*4*1024); // 0x87BFB000
+     static const unsigned int SYS_INFO          = PAGE_TABLES - 4096; 
+-
++    static const unsigned int MMODE_F           = SYS_INFO - 4096;
++   
+     // Logical Memory Map
+     static const unsigned int BOOT              = NOT_USED;
+     static const unsigned int IMAGE             = NOT_USED;
+diff --git a/include/process.h b/include/process.h
+index 774cb62..0497ec0 100644
+--- a/include/process.h
++++ b/include/process.h
+@@ -122,6 +122,9 @@ protected:
+     Queue * _waiting;
+     Thread * volatile _joining;
+     Queue::Element _link;
++    
++    // !P2:
++    volatile Task * _task;
+ 
+     static volatile unsigned int _thread_count;
+     static Scheduler_Timer * _timer;
+@@ -185,6 +188,7 @@ private:
+     typedef CPU::Log_Addr Log_Addr;
+ 
+ public:
++    static volatile Task * _active;
+     Task(Segment * cs, Segment * ds)
+     : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+         db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+@@ -198,7 +202,13 @@ public:
+     void activate() {
+         CPU::satp((0x1 << 31) | _as->pd() >> 12);
+     }
+-
++    
++    static void activate(volatile Task * task) __attribute__((noinline)){
++        Task::_active = task;
++        CPU::satp((0x1 << 31) | task->_as->pd() >> 12);
++        ASM("sfence.vma");
++    }
++    
+     Address_Space * address_space() const { return _as; }
+ 
+     Segment * code_segment() const { return _cs; }
+@@ -214,6 +224,7 @@ private:
+     Segment * _ds;
+     Log_Addr _code;
+     Log_Addr _data;
++    
+ };
+ 
+ 
+diff --git a/makedefs b/makedefs
+index 69145be..ac7e8f5 100644
+--- a/makedefs
++++ b/makedefs
+@@ -86,6 +86,7 @@ MEM_SIZE                = $(shell $(BIN)/eposcfg MEM_SIZE_KB 2> /dev/null)
+ BOOT_ADDR               = $(shell $(BIN)/eposcfg BOOT 2> /dev/null)
+ SETUP_ADDR              = $(shell $(BIN)/eposcfg SETUP 2> /dev/null)
+ INIT_ADDR               = $(shell $(BIN)/eposcfg INIT 2> /dev/null)
++MMODE_F                 = $(shell $(BIN)/eposcfg MMODE_F 2> /dev/null)
+ SYS_CODE_ADDR           = $(shell $(BIN)/eposcfg SYS_CODE 2> /dev/null)
+ SYS_DATA_ADDR           = $(shell $(BIN)/eposcfg SYS_DATA 2> /dev/null)
+ UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g')
+@@ -361,8 +362,11 @@ lib%.o: lib%.cc
+ (%.o): %.o
+ 		$(AR) $(ARFLAGS) $@ $^
+ 
++# %.img: %
++# 		$(MKBI) $@ $<
++
+ %.img: %
+-		$(MKBI) $@ $<
++		$(MKBI) $@ hello_usr philosophers_dinner
+ 
+ %.hex: %
+ 		$(OBJCOPY) -I elf32-$(ARCH_ENDIANESS) -O ihex $< $<.tmp
+diff --git a/makefile b/makefile
+index a35fe1f..3e7459c 100644
+--- a/makefile
++++ b/makefile
+@@ -8,9 +8,32 @@ all: FORCE
+ ifndef APPLICATION
+ 		$(foreach app,$(APPLICATIONS),$(MAKE) APPLICATION=$(app) $(PRECLEAN) prebuild_$(app) all1 posbuild_$(app);)
+ else
+-		$(MAKE) all1
++		(cd etc && $(MAKE) APPLICATION=hello_usr)
++		(cd tools && $(MAKE) APPLICATION=hello_usr)
++		(cd src && $(MAKE) APPLICATION=hello_usr)
++		(cd app && $(MAKE) APPLICATION=hello_usr)
++		(cd app && $(MAKE) APPLICATION=hello)
++		(cd img && $(MAKE) APPLICATION=hello_usr)
+ endif
+ 
++dbg: FORCE
++		(cd etc && $(MAKE)   DEBUG=1  APPLICATION=hello_usr)
++		(cd tools && $(MAKE) DEBUG=1  APPLICATION=hello_usr)
++		(cd src && $(MAKE)   DEBUG=1  APPLICATION=hello_usr)
++		(cd app && $(MAKE)   DEBUG=1  APPLICATION=hello_usr)
++		(cd app && $(MAKE)   DEBUG=1  APPLICATION=hello)
++		(cd img && $(MAKE)   DEBUG=1  APPLICATION=hello_usr)
++		(cd img && $(MAKE)   DEBUG=1  APPLICATION=hello_usr debug)
++
++rrrun:
++		(cd etc && $(MAKE) APPLICATION=hello_usr)
++		(cd tools && $(MAKE) APPLICATION=hello_usr)
++		(cd src && $(MAKE) APPLICATION=hello_usr)
++		(cd app && $(MAKE) APPLICATION=hello_usr)
++		(cd app && $(MAKE) APPLICATION=hello)
++		(cd img && $(MAKE) APPLICATION=hello_usr)
++		(cd img && $(MAKE) APPLICATION=hello_usr run1)
++
+ all1: $(SUBDIRS)
+ 
+ $(SUBDIRS): FORCE
+diff --git a/notes/build.txt b/notes/build.txt
+index 784275a..f8445fd 100644
+--- a/notes/build.txt
++++ b/notes/build.txt
+@@ -157,5 +157,24 @@ init global constructors
+ app entry 
+ 
+ 
++
++
++Init:
++rv32_cpu_init.o
++rv32_mmu_init.o
++riscv_ic_init.o
++riscv_machine_init.o
++riscv_timer_init.o
++alarm_init.o
++system_init.o
++thread_init.o
++
++crtbegin_sifive_e.o
++init_first.o
++init_system.o
++crtend_sifive_e.o
++
++
++Reduzir o PAGE_TABLES (vamos usar mais que 544+1 tabelas de pagina?)
+ =======
+         
+\ No newline at end of file
+diff --git a/src/api/thread.cc b/src/api/thread.cc
+index 3d5e6f5..e4a5445 100644
+--- a/src/api/thread.cc
++++ b/src/api/thread.cc
+@@ -12,6 +12,7 @@ __END_UTIL
+ __BEGIN_SYS
+ 
+ volatile unsigned int Thread::_thread_count;
++volatile Task * Task::_active;
+ Scheduler_Timer * Thread::_timer;
+ Scheduler<Thread> Thread::_scheduler;
+ 
+@@ -19,7 +20,8 @@ Scheduler<Thread> Thread::_scheduler;
+ void Thread::constructor_prologue(unsigned int stack_size)
+ {
+     lock();
+-
++    // !P2:
++    _task = Task::_active;
+     _thread_count++;
+     _scheduler.insert(this);
+ 
+@@ -338,6 +340,11 @@ void Thread::dispatch(Thread * prev, Thread * next, bool charge)
+         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
+         db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
+         db<Thread>(INF) << "next={" << next << ",ctx=" << *next->_context << "}" << endl;
++        
++        
++        if(prev->_task != next->_task){
++            Task::activate(next->_task);
++        }
+ 
+         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
+         // and necessary because of context switches, but here, we are locked() and
+diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
+index 685e3c1..2d3a7a9 100644
+--- a/src/api/thread_init.cc
++++ b/src/api/thread_init.cc
+@@ -22,43 +22,69 @@ void Thread::init()
+     typedef int (Main)();
+ 
+     System_Info * si = System::info();
+-    Main * main;
+-
++    // Main * main;
++    
+     if(Traits<System>::multitask) {
+-        main = reinterpret_cast<Main *>(si->lm.app_entry);
+-        
++        // main = reinterpret_cast<Main *>(si->lm.app[0].app_entry);
+         // Should we store this somewhere?
+         char * bi = reinterpret_cast<char*>(0x80000000);
+-        Segment * code_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL); // we need W permission to load the segment
+-        //!P2: do the ctor of Chunk and load_segment interact well if len=0 segments?
+-        Segment * data_seg = new (SYSTEM) Segment(4096, MMU::Flags::ALL); // UNUSED AS OF NOW
+-        Address_Space * master = new (SYSTEM) Address_Space(MMU::current());
+-        new (SYSTEM) Task(master, code_seg, data_seg);
+-        ASM("sfence.vma");
+-
+-        // Load APP
+-        if(si->lm.has_app) {
+-            ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+-            db<Setup>(TRC) << "Setup_SifiveE::load_app()" << endl;
+-            if(app_elf->load_segment(0) < 0) {
+-                db<Setup>(ERR) << "Application code segment was corrupted during SETUP!" << endl;
+-                Machine::panic();
++        
++        for(unsigned i = 0; i < 2; i++){
++            Segment * code_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL); // we need W permission to load the segment
++            //!P2: do the ctor of Chunk and load_segment interact well if len=0 segments?
++            Segment * data_seg = new (SYSTEM) Segment(4096, MMU::Flags::ALL); // UNUSED AS OF NOW
++            Task * app_task =  new (SYSTEM) Task(code_seg, data_seg);
++            db<Setup>(TRC) << "app_task = " << hex << app_task << endl;
++            Task::activate(app_task); //just create another thread constr with task
++            if(si->lm.has_app) {
++                ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
++                db<Setup>(TRC) << "Setup_SifiveE::load_app()" << endl;
++                if(app_elf->load_segment(0) < 0) {
++                    db<Setup>(ERR) << "Application code segment was corrupted during INIT!" << endl;
++                    Machine::panic();
++                }
++                for(int i = 1; i < app_elf->segments(); i++)
++                    if(app_elf->load_segment(i) < 0) {
++                        db<Setup>(ERR) << "Application data segment was corrupted during INIT!" << endl;
++                        Machine::panic();
++                    }
+             }
+-            // for(int i = 1; i < app_elf->segments(); i++)
+-            //     if(app_elf->load_segment(i) < 0) {
+-            //         db<Setup>(ERR) << "Application data segment was corrupted during SETUP!" << endl;
+-            //         panic();
+-            //     }
++            
++            new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<Main *>(si->lm.app[i].app_entry));
+         }
++        
++        
++        // Segment * code_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL); // we need W permission to load the segment
++        // //!P2: do the ctor of Chunk and load_segment interact well if len=0 segments?
++        // Segment * data_seg = new (SYSTEM) Segment(4096, MMU::Flags::ALL); // UNUSED AS OF NOW
++        // Address_Space * master = new (SYSTEM) Address_Space(MMU::current());
++        // Task * app_task =  new (SYSTEM) Task(master, code_seg, data_seg);
++        // Task::activate(app_task);
++        // // ASM("sfence.vma");
++
++        // // Load APP
++        // if(si->lm.has_app) {
++        //     ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[0]]);
++        //     db<Setup>(TRC) << "Setup_SifiveE::load_app()" << endl;
++        //     if(app_elf->load_segment(0) < 0) {
++        //         db<Setup>(ERR) << "Application code segment was corrupted during INIT!" << endl;
++        //         Machine::panic();
++        //     }
++        //     for(int i = 1; i < app_elf->segments(); i++)
++        //         if(app_elf->load_segment(i) < 0) {
++        //             db<Setup>(ERR) << "Application data segment was corrupted during INIT!" << endl;
++        //             Machine::panic();
++        //         }
++        // }
+     }
+-    else {
+-        // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
+-        // which will directly call main(). In this case, _init will have already been called,
+-        // before Init_Application to construct MAIN's global objects.
+-        main = reinterpret_cast<Main *>(__epos_app_entry);
+-    }
+-
+-    new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
++    // else {
++    //     // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
++    //     // which will directly call main(). In this case, _init will have already been called,
++    //     // before Init_Application to construct MAIN's global objects.
++    //     main = reinterpret_cast<Main *>(__epos_app_entry);
++    // }
++
++    // new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
+ 
+     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
+     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+diff --git a/src/architecture/rv32/rv32_cpu.cc b/src/architecture/rv32/rv32_cpu.cc
+index 47e8f61..093ad38 100644
+--- a/src/architecture/rv32/rv32_cpu.cc
++++ b/src/architecture/rv32/rv32_cpu.cc
+@@ -91,6 +91,9 @@ void CPU::Context::load() const volatile
+         "       sret                            \n");
+ }
+ 
++// NOTE:
++// during the first time switch context is called for a thread, the stack may be dirty
++// what will set the registers with random values, is this a problem?
+ void CPU::switch_context(Context ** o, Context * n)
+ {   
+     // Push the context into the stack and update "o"
+@@ -127,6 +130,8 @@ void CPU::switch_context(Context ** o, Context * n)
+         "       sw      x31, -120(sp)           \n"     // push sstatus
+         "       addi     sp,      sp,   -120    \n"     // complete the pushes above by adjusting the SP
+         "       sw       sp,    0(a0)           \n");   // update Context * volatile * o
++        
++    
+ 
+     // Set the stack pointer to "n" and pop the context from the stack
+     ASM("       mv       sp,      a1            \n"     // get Context * volatile n into SP
+diff --git a/src/architecture/rv32/rv32_mmu_init.cc b/src/architecture/rv32/rv32_mmu_init.cc
+index aa18175..fcad04e 100644
+--- a/src/architecture/rv32/rv32_mmu_init.cc
++++ b/src/architecture/rv32/rv32_mmu_init.cc
+@@ -20,11 +20,11 @@ void MMU::init()
+     db<Init, MMU>(TRC) << "sys_data= " << si->lm.sys_data << ", begin_free= " << sys_data_end << endl; 
+ 
+     // Worst-Fit guarantees this will work
+-    free(align_page(sys_data_end), pages(Memory_Map::SYS_INFO - align_page(sys_data_end))); // [align_page(&_end), 0x87bfa000]
++    free(align_page(sys_data_end), pages(Memory_Map::MMODE_F - align_page(sys_data_end))); // [align_page(&_end), 0x87bf9000]
+     free(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS, pages(Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS));
+     
+     // Free init/setup memory
+-    // free(Memory_Map::MEM_BASE, pages(Memory_Map::SYS - Memory_Map::MEM_BASE));
++    free(Memory_Map::MEM_BASE, pages(Memory_Map::SYS - Memory_Map::MEM_BASE));
+ }
+ 
+ __END_SYS
+\ No newline at end of file
+diff --git a/src/machine/riscv/riscv_ic.cc b/src/machine/riscv/riscv_ic.cc
+index f1b5e94..45b0d99 100644
+--- a/src/machine/riscv/riscv_ic.cc
++++ b/src/machine/riscv/riscv_ic.cc
+@@ -59,7 +59,7 @@ void IC::entry()
+         "# Restore context                                              \n"
+         ".restore:                                                      \n"
+         "        lw          x1,   4(sp)                                \n"
+-        "        lw          x2,   8(sp)                                \n"
++        "        lw          x2,   8(sp)                                \n" //?????????????????????????????????????????????????
+         "        lw          x3,  12(sp)                                \n"
+         "        lw          x4,  16(sp)                                \n"
+         "        lw          x5,  20(sp)                                \n"
+diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
+index 74d93df..2ffec02 100644
+--- a/src/setup/setup_sifive_e.cc
++++ b/src/setup/setup_sifive_e.cc
+@@ -22,7 +22,7 @@ extern "C"
+ }
+ 
+ // char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+-char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________________________________________________________________________________________________________________________________________";
++char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________";
+ System_Info * si;
+ 
+ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+@@ -45,6 +45,7 @@ private:
+     // Physical memory map
+     static const unsigned int SYS_INFO = Memory_Map::SYS_INFO;
+     static const unsigned int PAGE_TABLES = Memory_Map::PAGE_TABLES;
++    static const unsigned int MMODE_F = Memory_Map::MMODE_F;
+     static const unsigned int MEM_BASE = Memory_Map::MEM_BASE;
+     static const unsigned int MEM_TOP = Memory_Map::MEM_TOP;
+     
+@@ -73,7 +74,7 @@ void Setup_SifiveE::load_parts()
+         _panic();
+     }
+     memcpy(reinterpret_cast<void *>(SYS_INFO), si, sizeof(System_Info));
+-
++    
+     // Load INIT
+     ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+     ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+@@ -132,7 +133,7 @@ void Setup_SifiveE::build_lm()
+     si->lm.has_stp = (si->bm.setup_offset != -1u);
+     si->lm.has_ini = (si->bm.init_offset != -1u);
+     si->lm.has_sys = (si->bm.system_offset != -1u);
+-    si->lm.has_app = (si->bm.application_offset != -1u);
++    si->lm.has_app = (si->bm.application_offset[0] != -1u);
+     si->lm.has_ext = (si->bm.extras_offset != -1u);
+ 
+     // Check SETUP integrity and get the size of its segments
+@@ -248,31 +249,33 @@ void Setup_SifiveE::build_lm()
+     }
+ 
+     // Check APPLICATION integrity and get the size of its segments
+-    si->lm.app_entry = 0;
+-    si->lm.app_segments = 0;
+-    si->lm.app_code = ~0U;
+-    si->lm.app_code_size = 0;
+-    si->lm.app_data = ~0U;
+-    si->lm.app_data_size = 0;
+-    if(si->lm.has_app) {
+-        ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+-        if(!app_elf->valid()) {
+-            db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
+-            _panic();
+-        }
+-        si->lm.app_entry = app_elf->entry();
+-        si->lm.app_segments = app_elf->segments();
+-        si->lm.app_code = app_elf->segment_address(0);
+-        si->lm.app_code_size = app_elf->segment_size(0);
+-        if(app_elf->segments() > 1) {
+-            for(int i = 1; i < app_elf->segments(); i++) {
+-                if(app_elf->segment_type(i) != PT_LOAD)
+-                    continue;
+-                if(app_elf->segment_address(i) < si->lm.app_data)
+-                    si->lm.app_data = app_elf->segment_address(i);
+-                si->lm.app_data_size += app_elf->segment_size(i);
++    for(unsigned i=0; i < si->bm.n_apps; i++){
++        si->lm.app[i].app_entry = 0;
++        si->lm.app[i].app_segments = 0;
++        si->lm.app[i].app_code = ~0U;
++        si->lm.app[i].app_code_size = 0;
++        si->lm.app[i].app_data = ~0U;
++        si->lm.app[i].app_data_size = 0;
++        if(si->lm.has_app) {
++            ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
++            if(!app_elf->valid()) {
++                db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
++                _panic();
+             }
+-        }
++            si->lm.app[i].app_entry = app_elf->entry();
++            si->lm.app[i].app_segments = app_elf->segments();
++            si->lm.app[i].app_code = app_elf->segment_address(0);
++            si->lm.app[i].app_code_size = app_elf->segment_size(0);
++            if(app_elf->segments() > 1) {
++                for(int i = 1; i < app_elf->segments(); i++) {
++                    if(app_elf->segment_type(i) != PT_LOAD)
++                        continue;
++                    if(app_elf->segment_address(i) < si->lm.app[i].app_data)
++                        si->lm.app[i].app_data = app_elf->segment_address(i);
++                    si->lm.app[i].app_data_size += app_elf->segment_size(i);
++                }
++            }
++    }
+         // if(Traits<System>::multiheap) { // Application heap in data segment
+         //     si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
+         //     si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
+@@ -379,10 +382,19 @@ void Setup_SifiveE::setup_machine_environment()
+     CPU::mideleg_write(CPU::SSI | CPU::STI | CPU::SEI);
+     CPU::medeleg_write(0xffff);
+ 
++    // Relocate _mmode_forward - 1024 bytes are enough
++    char * src = reinterpret_cast<char *>(&_mmode_forward);
++    char * dst = reinterpret_cast<char *>(MMODE_F);
++    for(int i=0; i < 1024; i++){
++        *dst = *src;
++        src++;
++        dst++;
++    }
++    
+     // All ints received in M-mode are forwarded to S-mode.
+     // The first two bits indicate the mode: Direct or Vectored;
+     // we opted for Direct.
+-    CPU::mtvec((unsigned)&_mmode_forward & 0xfffffffc);
++    CPU::mtvec(MMODE_F & 0xfffffffc);
+     CPU::mepc((unsigned)&setup_supervisor_environment);
+ 
+     ASM("mret");
+diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
+index 3fb68de..093c89b 100644
+--- a/tools/eposcc/eposcc
++++ b/tools/eposcc/eposcc
+@@ -83,8 +83,8 @@ fi
+ LINKER_BUILTIN=$LINKER
+ LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+ LINK_OBJI_BUILTIN="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
+-LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o -R$SRC/system/system_$MMOD"
+-LINK_OBJL_BUILTIN="$LIB/crtend_$MMOD.o"
++LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o $LIB/crtend_$MMOD.o -R$SRC/system/system_$MMOD"
++# LINK_OBJL_BUILTIN=
+ LINK_LIBS_BUILTIN="util_$MMOD gcc"
+ if [ "$SETUP" = "" ] ; then
+ LINK_OBJN_BUILTIN="$LIB/setup_$MMOD.o $LINK_OBJN_BUILTIN"
+diff --git a/tools/eposcfg/eposcfg.cc b/tools/eposcfg/eposcfg.cc
+index ec54b41..b0f48d5 100644
+--- a/tools/eposcfg/eposcfg.cc
++++ b/tools/eposcfg/eposcfg.cc
+@@ -22,7 +22,7 @@ using namespace EPOS::S;
+ using namespace EPOS::S::U;
+ 
+ // Constants
+-const unsigned int TOKENS = 31;
++const unsigned int TOKENS = 32;
+ const unsigned int COMPONENTS = 62;
+ const unsigned int STRING_SIZE = 128;
+ 
+@@ -43,6 +43,7 @@ char tokens[TOKENS][STRING_SIZE] = {
+     "MEM_SIZE_KB",
+     "MIO_BASE",
+     "MIO_TOP",
++    "MMODE_F",
+     "MIO_SIZE",
+     "MIO_SIZE_KB",
+     "BOOT_STACK",
+@@ -205,6 +206,9 @@ void populate_strings()
+ 
+     snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP);
+     set_token_value("MEM_TOP", string);
++    
++    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MMODE_F);
++    set_token_value("MMODE_F", string);
+ 
+     snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE);
+     set_token_value("MEM_SIZE", string);
+diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
+index 4cedea1..4f4d299 100644
+--- a/tools/eposmkbi/eposmkbi.cc
++++ b/tools/eposmkbi/eposmkbi.cc
+@@ -210,6 +210,7 @@ int main(int argc, char **argv)
+     si.bm.space_x  = CONFIG.space_x;
+     si.bm.space_y  = CONFIG.space_y;
+     si.bm.space_z  = CONFIG.space_z;
++    si.bm.n_apps   = argc-3;
+ 
+     fprintf(out, "\nBoot Map:");
+     fprintf(out, "\n    si.bm.n_cpus %u", si.bm.n_cpus);
+@@ -229,10 +230,14 @@ int main(int argc, char **argv)
+     sprintf(file, "%s/img/setup_%s", argv[optind], CONFIG.mmod);
+     if(file_exist(file)) {
+         //!P2: stp is a raw binary file now; it has no Elf header to be read
++        
++        fprintf(out, "\nIMAGE SIZE NO SETUP_SIZE No PAD = %u", image_size);
+         si.bm.setup_offset = -1;
+         fprintf(out, "    Adding setup \"%s\":", file);
+         image_size += put_file(fd_img, file);
++        fprintf(out, "\nSETUP_SIZE No PAD = %u", image_size);
+         image_size += pad(fd_img, 4*4096 - (image_size % 4096));
++        fprintf(out, "\nSETUP_SIZE = %u", image_size);
+     } else
+         si.bm.setup_offset = -1;
+ 
+@@ -255,23 +260,32 @@ int main(int argc, char **argv)
+     }
+ 
+     // Add application(s) and data
+-    si.bm.application_offset = image_size - boot_size;
++    si.bm.application_offset[0] = image_size - boot_size;
+     fprintf(out, "    Adding application \"%s\":", argv[optind + 2]);
+     image_size += put_file(fd_img, argv[optind + 2]);
+     if((argc - optind) == 3) // single APP
+         si.bm.extras_offset = -1;
+-    else { // multiple APPs or data
+-        si.bm.extras_offset = image_size - boot_size;
+-        struct stat file_stat;
+-        for(int i = optind + 3; i < argc; i++) {
+-            fprintf(out, "    Adding file \"%s\":", argv[i]);
+-            stat(argv[i], &file_stat);
+-            image_size += put_number(fd_img, file_stat.st_size);
++    else{
++        fprintf(out, "HHHHHHHHHHEEEEEEEEEEEEEEEEE        %u        ELLLLLLLLLLLLLLLLLLLLLLLLLLLOOOOOOOOOOOOOOOOOOO\n\n", argc);
++        fprintf(out, "sizeof(System_Info) = %u\n", sizeof(System_Info));
++        for(int i=4; i<argc; i++){
++            si.bm.application_offset[i-3] = image_size - boot_size;
++            fprintf(out, "    Adding application \"%s\":", argv[i]);
+             image_size += put_file(fd_img, argv[i]);
+         }
+-        // Signalize last application by setting its size to 0
+-        image_size += put_number(fd_img, 0);
+     }
++    // else { // multiple APPs or data
++    //     si.bm.extras_offset = image_size - boot_size;
++    //     struct stat file_stat;
++    //     for(int i = optind + 3; i < argc; i++) {
++    //         fprintf(out, "    Adding file \"%s\":", argv[i]);
++    //         stat(argv[i], &file_stat);
++    //         image_size += put_number(fd_img, file_stat.st_size);
++    //         image_size += put_file(fd_img, argv[i]);
++    //     }
++    //     // Signalize last application by setting its size to 0
++    //     image_size += put_number(fd_img, 0);
++    // }
+ 
+     // Add the size of the image to the Boot_Map in System_Info (excluding BOOT)
+     si.bm.img_size = image_size - boot_size;
+@@ -579,7 +593,11 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
+         return false;
+     if(!put_number(fd, static_cast<T>(si->bm.system_offset)))
+         return false;
+-    if(!put_number(fd, static_cast<T>(si->bm.application_offset)))
++    for(int i=0; i<8; i++){
++        if(!put_number(fd, static_cast<T>(si->bm.application_offset[i])))                 
++            return false;
++    }
++    if(!put_number(fd, static_cast<T>(si->bm.n_apps)))
+         return false;
+     if(!put_number(fd, static_cast<T>(si->bm.extras_offset)))
+         return false;
diff --git a/docs/tmp/hello/hello.cc b/docs/tmp/hello/hello.cc
new file mode 100644
index 0000000..b275f8d
--- /dev/null
+++ b/docs/tmp/hello/hello.cc
@@ -0,0 +1,37 @@
+#include <utility/ostream.h>
+#include <time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+// int __attribute__((optimize("O0"))) dummy(int n) {
+//     long long int a = 0;
+//     for (int i = 0; i < n; i++) {
+//         for (int j = 0; j < n; j++) {
+//             a += i*j;
+//         }
+//     }
+//     return a;
+// }
+
+// static unsigned ITERATIONS = 1000;
+int main()
+{
+    // Chronometer chron;
+    // unsigned chron_freq = chron.frequency();
+    // unsigned alarm_freq = Alarm::frequency();
+    // cout << "Chron Frequency: " << chron_freq << endl;
+    // cout << "Alarm Frequency: " << alarm_freq << endl;
+    // unsigned int RESCALE = chron_freq / alarm_freq;
+    // chron.reset();
+    // chron.start();
+    // for (int i = 0; i < ITERATIONS; i++) {
+    //     dummy(900);
+    // }
+    // chron.stop();
+    // unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
+    // cout << "T=" << avg << endl;
+    cout << "Hello world!" << endl;
+    return 0;
+}
diff --git a/docs/tmp/hello/hello_traits.h b/docs/tmp/hello/hello_traits.h
new file mode 100644
index 0000000..8fe3f88
--- /dev/null
+++ b/docs/tmp/hello/hello_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/docs/tmp/hello/makefile b/docs/tmp/hello/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/docs/tmp/hello/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/docs/tmp/hello_usr.img b/docs/tmp/hello_usr.img
new file mode 100644
index 0000000..bbf96d5
Binary files /dev/null and b/docs/tmp/hello_usr.img differ
diff --git a/docs/tmp/test_task/makefile b/docs/tmp/test_task/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/docs/tmp/test_task/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/docs/tmp/test_task/test_task.cc b/docs/tmp/test_task/test_task.cc
new file mode 100644
index 0000000..409d8f8
--- /dev/null
+++ b/docs/tmp/test_task/test_task.cc
@@ -0,0 +1,44 @@
+#include <utility/ostream.h>
+#include <process.h>
+#include <memory.h>
+#include <architecture/rv32/rv32_mmu.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+int main()
+{
+    cout << "Task Test" << endl;
+    unsigned * data_base = reinterpret_cast<unsigned*>(Memory_Map::APP_DATA);
+    
+    Segment * code_seg1 = new Segment(1024*4, MMU::Flags::KCODE);
+    Segment * data_seg1 = new Segment(1024*4, MMU::Flags::KDATA);
+    cout << "Create Task1" << endl;
+    Task * t1 =  new Task(code_seg1, data_seg1);
+
+    ASM("A1:");
+    ASM("sfence.vma");
+    t1->activate();
+    *data_base = 10;
+
+    Segment * code_seg2 = new Segment(1024*4, MMU::Flags::KCODE);
+    Segment * data_seg2 = new Segment(1024*4, MMU::Flags::KDATA);
+    cout << "Create Task2" << endl;
+    Task * t2 =  new Task(code_seg2, data_seg2);
+
+    // Should be 10
+    cout << "Data base=" << *data_base << endl;
+    ASM("A2:");
+    ASM("sfence.vma");
+    t2->activate();
+    // Should be Garbage
+    cout << "Data base=" << *data_base << endl;
+    *data_base = 9;
+    // Should be 9
+    cout << "Data base=" << *data_base << endl;
+
+    ASM("End:");
+    cout << "End!" << endl;
+    return 0;
+}
diff --git a/docs/tmp/test_task/test_task_traits.h b/docs/tmp/test_task/test_task_traits.h
new file mode 100644
index 0000000..824a26a
--- /dev/null
+++ b/docs/tmp/test_task/test_task_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/docs/touch b/docs/touch
new file mode 100644
index 0000000..e69de29
diff --git a/etc/makefile b/etc/makefile
index 1e29432..45d0fcd 100644
--- a/etc/makefile
+++ b/etc/makefile
@@ -31,7 +31,7 @@ eposcc.conf: FORCE
 		@echo "APP_DATA=$(shell $(BIN)/eposcfg APP_DATA)" >> $@
 		@echo "SETUP=$(shell $(BIN)/eposcfg SETUP)" >> $@
 		@echo "BOOT_STACK=$(shell $(BIN)/eposcfg BOOT_STACK)" >> $@
-		@echo "MACH_CC_FLAGS='$(MACH_CC_FLAGS)'" >> $@
+		@echo "MACH_CC_FLAGS='$(MACH_CXX_FLAGS)'" >> $@
 		@echo "MACH_LD_FLAGS='$(MACH_LD_FLAGS)'" >> $@
 		@echo "MACH_CODE_NAME='$(MACH_CODE_NAME)'" >> $@
 		@echo "MACH_DATA_NAME='$(MACH_DATA_NAME)'" >> $@
@@ -47,6 +47,8 @@ eposmkbi.conf:	FORCE
 		@echo "ENDIANESS=$(shell $(BIN)/eposcfg ENDIANESS)" >> $@
 		@echo "MEM_BASE=$(shell $(BIN)/eposcfg MEM_BASE)" >> $@
 		@echo "MEM_TOP=$(shell $(BIN)/eposcfg MEM_TOP)" >> $@
+		@echo "MIO_BASE=$(shell $(BIN)/eposcfg MIO_BASE)" >> $@
+		@echo "MIO_TOP=$(shell $(BIN)/eposcfg MIO_TOP)" >> $@
 		@echo "BOOT_LENGTH_MIN=$(shell $(BIN)/eposcfg BOOT_LENGTH_MIN)" >> $@
 		@echo "BOOT_LENGTH_MAX=$(shell $(BIN)/eposcfg BOOT_LENGTH_MAX)" >> $@
 		@echo "NODE_ID=$(NODE_ID)" >> $@
diff --git a/img/INTS b/img/INTS
new file mode 100644
index 0000000..e69de29
diff --git a/img/makefile b/img/makefile
index f048773..e630418 100644
--- a/img/makefile
+++ b/img/makefile
@@ -20,14 +20,14 @@ endif
 
 DEBUGGER	:= $(MACH_DEBUGGER)
 ifeq ($(DEBUG),1)
-ifneq ($(wildcard $(IMG)/$(MACH)_setup),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/$(MACH)_setup,.text)"
+ifneq ($(wildcard $(IMG)/setup_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/setup_$(MMOD),.text)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_init),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/$(MACH)_init,.text)"
+ifneq ($(wildcard $(IMG)/init_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/init_$(MMOD),.text)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_system),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
+ifneq ($(wildcard $(IMG)/system_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/system_$(MMOD),.text)"
 endif
 DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
 PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
@@ -45,7 +45,7 @@ all:		strip $(IMAGE)
 
 else
 
-all:		strip $(IMAGE) $(PEER_IMAGE)
+all:	 	$(IMAGE) $(PEER_IMAGE)
 
 $(IMAGE):	$(APPLICATION)
 		$(MKBI) -x 0 -y 0 -z 0 $@ $<
@@ -83,7 +83,7 @@ endif
 
 debug:		$(IMAGE)
 ifeq ($(NODES),1)
-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
+		$(EMULATOR)$(IMAGE) &
 		$(DEBUGGER)
 else
 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
@@ -104,7 +104,7 @@ strip:		$(SYSTEM) $(APPLICATION)
 		@for file in $^; do $(STRIP) "$${file}"; done;
 
 clean:		FORCE
-		$(CLEAN) $(SYSTEM) $(APPLICATION) $(IMAGE)
+		$(CLEAN) $(SYSTEM) $(APPLICATION) $(IMAGE) setup_sifive_e
 ifneq ($(NODES),1)
 		$(CLEAN) $(PEER_IMAGE)
 endif
@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
 		@echo "Running $(APPLICATION) ..."
 posrun_$(APPLICATION):
 		@echo "done!"
-		
+
 FORCE:
diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
index 5735fcf..ea8a03e 100644
--- a/include/architecture/mmu.h
+++ b/include/architecture/mmu.h
@@ -37,15 +37,19 @@ public:
     {
     public:
         enum {
-            PRE = 0x001, // Presence (0=not-present, 1=present)
-            RW  = 0x002, // Write (0=read-only, 1=read-write)
-            USR = 0x004, // Access Control (0=supervisor, 1=user)
-            CWT = 0x008, // Cache Mode (0=write-back, 1=write-through)
-            CD  = 0x010, // Cache Disable (0=cacheable, 1=non-cacheable)
-            CT  = 0x020, // Contiguous (0=non-contiguous, 1=contiguous)
-            IO  = 0x040, // Memory Mapped I/O (0=memory, 1=I/O)
-            SYS = (PRE | RW ),
-            APP = (PRE | RW | USR)
+            PRE  = 0x001, // Presence (0=not-present, 1=present)
+            RW   = 0x002, // Write (0=read-only, 1=read-write)
+            USR  = 0x004, // Access Control (0=supervisor, 1=user)
+            CWT  = 0x008, // Cache Mode (0=write-back, 1=write-through)
+            CD   = 0x010, // Cache Disable (0=cacheable, 1=non-cacheable)
+            CT   = 0x020, // Contiguous (0=non-contiguous, 1=contiguous)
+            IO   = 0x040, // Memory Mapped I/O (0=memory, 1=I/O)
+            SYS = (PRE | RW),
+            APP = (PRE | RW | USR),
+            EXEC  = 0x080,
+            KCODE = (PRE | EXEC),
+            KDATA = (PRE | RW),
+            ALL = (PRE | RW | EXEC),
         };
 
     public:
@@ -67,8 +71,8 @@ public:
 
 public:
     static unsigned int pages(unsigned int bytes) { return (bytes + sizeof(Page) - 1) / sizeof(Page); }
-    static unsigned int page_tables(unsigned int pages) { return (pages + PT_ENTRIES - 1) / PT_ENTRIES; }
-
+    static unsigned int page_tables(unsigned int pages) { return sizeof(Page) > sizeof(int) ? (pages + PT_ENTRIES - 1) / PT_ENTRIES : 0; } // merged
+    
     static unsigned int offset(const Log_Addr & addr) { return addr & (sizeof(Page) - 1); }
     static unsigned int indexes(const Log_Addr & addr) { return addr & ~(sizeof(Page) - 1); }
 
@@ -76,7 +80,7 @@ public:
     static unsigned int directory(const Log_Addr & addr) { return addr >> DIRECTORY_SHIFT; }
 
     static Log_Addr align_page(const Log_Addr & addr) { return (addr + sizeof(Page) - 1) & ~(sizeof(Page) - 1); }
-    static Log_Addr align_directory(const Log_Addr & addr) { return (addr + sizeof(Page) * sizeof(Page) - 1) &  ~(sizeof(Page) * sizeof(Page) - 1); }
+    static Log_Addr align_directory(const Log_Addr & addr) { return (addr + PT_ENTRIES * sizeof(Page) - 1) &  ~(PT_ENTRIES * sizeof(Page) - 1); } // merged
 };
 
 __END_SYS
diff --git a/include/architecture/rv32/rv32_cpu.h b/include/architecture/rv32/rv32_cpu.h
index 55a077e..1956a0a 100644
--- a/include/architecture/rv32/rv32_cpu.h
+++ b/include/architecture/rv32/rv32_cpu.h
@@ -27,24 +27,26 @@ public:
 
     // Control and Status Register (CSR) for machine mode
     // Status Register (mstatus)
+    typedef Reg32 Flags;
     enum {
         MIE             = 1 << 3,      // Machine Interrupts Enabled
         SIE             = 1 << 1,      // Supervisor Interrupts Enabled
         SPIE            = 1 << 5,      // Supervisor Previous Interrupts Enabled
         MPIE            = 1 << 7,      // Machine Previous Interrupts Enabled
-        MPP             = 3 << 11,     // Machine Previous Privilege
-        SPP             = 3 << 12,     // Supervisor Previous Privilege
+        MPP             = 3 << 11,     // Machine Previous Privilege=Machine
+        MPP_S           = 1 << 11,     // Machine Previous Privilege=Supervisor
+        // SPP             = 3 << 8,     // Supervisor Previous Privilege=Machine
+        SPP_S           = 1 << 8,       // Supervisor Previous Privilege=Supervisor
         MPRV            = 1 << 17,     // Memory Priviledge
-        TVM             = 1 << 20,     // Trap Virtual Memory //not allow MMU
-        MSTATUS_DEFAULTS= (MIE | MPIE | MPP)
+        TVM             = 1 << 20      // Trap Virtual Memory //not allow MMU
     };
 
     // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers (mie, mip, and mcause when interrupt bit is set)
     enum {
         SSI             = 1 << 1,   // Supervisor Software Interrupt
         MSI             = 1 << 3,   // Machine Software Interrupt
-        STI             = 1 << 5,   // Supervisor Software Interrupt
-        MTI             = 1 << 7,   // Machine Software Interrupt
+        STI             = 1 << 5,   // Supervisor Timer Interrupt
+        MTI             = 1 << 7,   // Machine Timer Interrupt
         SEI             = 1 << 9,   // Supervisor External Interrupt
         MEI             = 1 << 11   // Machine External Interrupt
     };
@@ -62,15 +64,16 @@ public:
         EXC_DWFAULT     = 7,    // Store/AMO access fault
         EXC_ENVU        = 8,    // Environment call from U-mode
         EXC_ENVS        = 9,    // Environment call from S-mode
-        EXC_ENVH        = 10,   // Environment call from H-mode
-        EXC_ENVM        = 11    // Environment call from M-m
+        // EXC_ENVH        = 10,   // Environment call from H-mode
+        EXC_ENVM        = 11    // Environment call from M-mode
     };
 
     // Context
     class Context
     {
     public:
-        Context(const Log_Addr & entry, const Log_Addr & exit): _pc(entry), _x1(exit) {
+        // Contexts are loaded with mret, which gets pc from mepc and updates some bits of mstatus, that's why _st is initialized with MPIE and MPP
+        Context(const Log_Addr & entry, const Log_Addr & exit): _st(SPIE | SPP_S), _pc(entry), _x1(exit) {
             if(Traits<Build>::hysterically_debugged || Traits<Thread>::trace_idle) {
                                                                         _x5 =  5;  _x6 =  6;  _x7 =  7;  _x8 =  8;  _x9 =  9;
                 _x10 = 10; _x11 = 11; _x12 = 12; _x13 = 13; _x14 = 14; _x15 = 15; _x16 = 16; _x17 = 17; _x18 = 18; _x19 = 19;
@@ -84,8 +87,9 @@ public:
 
         friend Debug & operator<<(Debug & db, const Context & c) {
             db << hex
-               << "{pc="   << c._pc
-               << ",sp="   << &c
+               << "{sp="   << &c
+               << ",st="   << c._st
+			   << ",pc="   << c._pc
                << ",lr="   << c._x1
                << ",x5="   << c._x5
                << ",x6="   << c._x6
@@ -119,6 +123,7 @@ public:
         }
 
     public:
+        Reg32  _st; // mstatus
         Reg32  _pc; // pc
     //  Reg32  _x0; // zero
         Reg32  _x1; // ra, ABI Link Register
@@ -164,24 +169,31 @@ public:
     CPU() {};
 
 public:
-    // Register access
+    static Reg32 flags() { return mstatus(); }
+    static void flags(const Flags st) { mstatus(st); }
+    
+    static Reg32 tp() {
+        Reg32 value;
+        ASM("mv %0, tp" : "=r"(value) :);
+        return value;
+    }
+
+    static void tp(const Reg32 & tp) { ASM("mv tp, %0" : : "r"(tp) :); }
+
     static Reg32 sp() {
         Reg32 value;
         ASM("mv %0, sp" : "=r"(value) :);
         return value;
     }
-    static void sp(const Reg32 & sp) {
-        ASM("mv sp, %0" : : "r"(sp) :);
-    }
+
+    static void sp(const Reg32 & sp) { ASM("mv sp, %0" : : "r"(sp) :); }
 
     static Reg32 fr() {
         Reg32 value;
         ASM("mv %0, x10" : "=r"(value)); // x10 is a0
         return value;
     }
-    static void fr(const Reg32 & fr) {
-        ASM("mv x10, %0" : : "r"(fr) :); // x10 is a0
-    }
+    static void fr(const Reg32 & fr) { ASM("mv x10, %0" : : "r"(fr) :); } // x10 is a0
 
     static Log_Addr ip() {
         Reg32 value;
@@ -242,14 +254,21 @@ public:
     static void halt() { ASM("wfi"); }
 
     static unsigned int id() {
+        return tp();
+        // return 0;
+    }
+
+    static unsigned int mhartid() {
         int id;
         ASM("csrr %0, mhartid" : "=r"(id) : : "memory", "cc");
         return id & 0x3;
     }
 
-    static void mstatus(Reg value) {
-        ASM("csrs mstatus, %0" : : "r"(value) : "cc");
-    }
+    //================ status
+
+    static void mstatus(Reg value) {       ASM("csrs mstatus, %0" : : "r"(value) : "cc"); }
+    static void mstatus_write(Reg value) { ASM("csrw mstatus, %0" : : "r"(value) : "cc"); }
+    static void mstatus_clear(Reg value) { ASM("csrc mstatus, %0" : : "r"(value) : "cc"); }
 
     static Reg mstatus() {
         Reg value;
@@ -257,37 +276,89 @@ public:
         return value;
     }
 
-    static void mie(Reg value) {
-        ASM("csrs mie, %0" : : "r"(value) : "cc");
+    static Reg sstatus() {
+        Reg value;
+        ASM("csrr %0, sstatus" : "=r"(value) : : );
+        return value;
     }
 
-    static void mie_clear(Reg value) {
-        ASM("csrc mie, %0" : : "r"(value) : "cc");
+    static Reg rdtime() {
+        Reg value;
+        ASM("rdtime %0" : "=r"(value) : : );
+        return value;
     }
 
+    //================ exceptions
+
+    static void mepc(Reg value) { ASM("csrw mepc, %0" : : "r"(value) : "cc"); }
+
+    static void mtvec(Reg value) { ASM("csrw mtvec, %0" : : "r"(value) : "cc"); }
+
+    static void mie(Reg value) {       ASM("csrs mie, %0" : : "r"(value) : "cc"); }
+    static void mie_clear(Reg value) { ASM("csrc mie, %0" : : "r"(value) : "cc"); }
+    static void mie_write(Reg value) { ASM("csrw mie, %0" : : "r"(value) : "cc"); }
+
     static Reg mie() {
         Reg value;
         ASM("csrr %0, mie" : "=r"(value) : : );
         return value;
     }
 
+    static void mip(Reg value) {       ASM("csrs mip, %0" : : "r"(value) : "cc"); }
+    static void mip_write(Reg value) { ASM("csrw mip, %0" : : "r"(value) : "cc"); }
+    static void mip_clear(Reg value) { ASM("csrc mip, %0" : : "r"(value) : "cc"); }
+
     static Reg mcause() {
         Reg value;
         ASM("csrr %0, mcause" : "=r"(value) : : );
         return value;
     }
 
+    static Reg scause() {
+        Reg value;
+        ASM("csrr %0, scause" : "=r"(value) : : );
+        return value;
+    }
+
+    //================ supervisor mode
+    
+    static void satp(Reg value) {       ASM("csrw satp, %0" : : "r"(value) : "cc"); }
+    
+    static void mideleg_write(Reg value) { ASM("csrw mideleg, %0" : : "r"(value) : "cc"); }
+    static void medeleg_write(Reg value) { ASM("csrw medeleg, %0" : : "r"(value) : "cc"); }
+
+    static void sstatus_write(Reg value) { ASM("csrw sstatus, %0" : : "r"(value) : "cc"); }
+
+    static void sie(Reg value) {       ASM("csrs sie, %0" : : "r"(value) : "cc"); }
+    static void sie_write(Reg value) { ASM("csrw sie, %0" : : "r"(value) : "cc"); }
+    static void sie_clear(Reg value) { ASM("csrc sie, %0" : : "r"(value) : "cc"); }
+
+    static Reg sie() {
+        Reg value;
+        ASM("csrr %0, sie" : "=r"(value) : : );
+        return value;
+    }
+
+    static void sip(Reg value) {       ASM("csrs sip, %0" : : "r"(value) : "cc"); }
+    static void sip_clear(Reg value) { ASM("csrc sip, %0" : : "r"(value) : "cc"); }
+
+    static void stvec_write(Reg value) { ASM("csrw stvec, %0" : : "r"(value) : "cc"); }
+
+    static void sepc_write(Reg value) { ASM("csrw sepc, %0" : : "r"(value) : "cc"); }
+
     static unsigned int cores() {
         return Traits<Build>::CPUS;
     }
 
     static void smp_barrier(unsigned long cores = cores()) { CPU_Common::smp_barrier<&finc>(cores, id()); }
 
-    static void int_enable() { ASM("csrs mstatus, %0" : :"r"(MSTATUS_DEFAULTS)); }
-    static void int_disable() { ASM("csrc mstatus, %0" : :"r"(MIE)); }
-    static bool int_enabled() { return (mstatus() & MIE) ; }
+    static void mmode_int_disable() { ASM("csrc mstatus, %0" : :"r"(MIE)); }
+    static void int_enable() {        ASM("csrs sstatus, %0" : :"r"(SIE)); }
+    static void int_disable() {       ASM("csrc sstatus, %0" : :"r"(SIE)); }
+    static bool int_enabled() { return (sstatus() & SIE) ; }
     static bool int_disabled() { return !int_enabled(); }
-
+    
+    //!SMODE: Where is this being used?
     static void csrr31() { ASM("csrr x31, mstatus" : : : "x31"); }
     static void csrw31() { ASM("csrs mstatus, x31" : : : "cc"); }
 
@@ -370,4 +441,4 @@ inline CPU::Reg16 ntohs(CPU::Reg16 v) { return CPU::ntohs(v); }
 
 __END_SYS
 
-#endif
+#endif
\ No newline at end of file
diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
index 1c809b2..4283306 100644
--- a/include/architecture/rv32/rv32_mmu.h
+++ b/include/architecture/rv32/rv32_mmu.h
@@ -12,43 +12,127 @@
 
 __BEGIN_SYS
 
-class MMU: public MMU_Common<0, 0, 0>
+class MMU: public MMU_Common<10, 10, 12>
 {
     friend class CPU;
-
+    friend class Setup_SifiveE;
 private:
-    typedef Grouping_List<unsigned int> List;
-
+    typedef Grouping_List<Frame> List;
     static const unsigned int PHY_MEM = Memory_Map::PHY_MEM;
 
 public:
     // Page Flags
-    typedef MMU_Common<0, 0, 0>::Flags RV32_Flags;
+    class RV32_Flags
+    {
+    public:
+        enum {
+            VALID    = 1 << 0,
+            READ     = 1 << 1,
+            WRITE    = 1 << 2,
+            EXEC     = 1 << 3,
+            USR      = 1 << 4,
+            ACCESSED = 1 << 6,
+            DIRTY    = 1 << 7,
+            SYS      = VALID | READ | WRITE | EXEC,
+            KCODE    = VALID | READ | EXEC,
+            KDATA    = VALID | READ | WRITE,
+            UCODE    = VALID | READ | EXEC | USR,
+            UDATA    = VALID | READ | WRITE | USR,
+        };
+
+        RV32_Flags() {}
+        RV32_Flags(const RV32_Flags & f): _flags(f) {}
+        RV32_Flags(unsigned int f): _flags(f) {}
+        RV32_Flags(const Flags & f): _flags(((f & Flags::PRE)  ? VALID : 0) | 
+                                            ((f & Flags::RW)   ? (READ | WRITE) : READ) |
+                                            ((f & Flags::USR)  ? USR : 0) | 
+                                            ((f & Flags::EXEC) ? EXEC : 0)) {}
+        operator unsigned int() const { return _flags; }
+
+    private:
+        unsigned int _flags;
+
+    };
 
     // Page_Table
-    class Page_Table {};
+    class Page_Table
+    {
+
+    friend class Setup_SifiveE;
+
+    private:
+        typedef unsigned int PTE;
+        PTE ptes[1024];
+
+    public:
+        Page_Table() {}
+
+        PTE & operator[](unsigned int i) { return ptes[i]; }
+
+        void map(const RV32_Flags & flags, int from, int to) {
+            Phy_Addr * addr = alloc(to - from);
+            // Try to alloc contiguous
+            if (addr) {
+                remap(addr, flags, from , to);
+            } else {
+                for(; from < to; from++){
+                    ptes[from] = ((alloc(1) >> 12) << 10) | flags ;
+                }
+            }
+        }
+
+        void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
+            for(int i = from; i < to; i++) {
+                unsigned int pte = phy_addr >> 12;
+                pte = pte << 10;
+                pte += ((i) << 10);
+                pte = pte | flags;
+                ptes[i] = pte;
+            }
+        }
+    };
 
     // Chunk (for Segment)
     class Chunk
     {
     public:
         Chunk() {}
-        Chunk(unsigned int bytes, Flags flags): _phy_addr(alloc(bytes)), _bytes(bytes), _flags(flags) {}
-        Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags): _phy_addr(phy_addr), _bytes(bytes), _flags(flags) {}
+        // Chunk(unsigned int bytes, Flags flags): _phy_addr(alloc(bytes)), _bytes(bytes), _flags(flags) {}
+        // Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags): _phy_addr(phy_addr), _bytes(bytes), _flags(flags) {}
+
+        Chunk(unsigned int bytes, const Flags & flags)
+        : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _bytes(bytes), _flags(RV32_Flags(flags)), _pt(calloc(_pts)) {
+            _pt->map(_flags, _from, _to);
+        }
 
-        ~Chunk() { free(_phy_addr, _bytes); }
+        // Chunk(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags)
+        // : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _flags(RV32_Flags(flags)), _pt(calloc(_pts)) {
+        //     _pt->remap(phy_addr, flags);
+        // }
 
-        unsigned int pts() const { return 0; }
-        Flags flags() const { return _flags; }
-        Page_Table * pt() const { return 0; }
+        // ~Chunk() { free(_phy_addr, _bytes); }
+        ~Chunk() {
+            for( ; _from < _to; _from++)
+                free((*static_cast<Page_Table *>(phy2log(_pt)))[_from]);
+            free(_pt, _pts);
+        }
+
+        unsigned int pts() const { return _pts; }
+        // Flags flags() const { return Flags(_flags); }
+        Page_Table * pt() const { return _pt; }
         unsigned int size() const { return _bytes; }
-        Phy_Addr phy_address() const { return _phy_addr; } // always CT
+        // Phy_Addr phy_address() const { return _phy_addr; } // always CT
         int resize(unsigned int amount) { return 0; } // no resize in CT
 
     private:
-        Phy_Addr _phy_addr;
+        unsigned int _from;
+        unsigned int _to;
+        unsigned int _pts;
+        // Phy_Addr _phy_addr;
         unsigned int _bytes;
         RV32_Flags _flags;
+        Page_Table * _pt;
+
     };
 
     // Page Directory
@@ -58,74 +142,82 @@ public:
     class Directory
     {
     public:
-        Directory() {}
-        Directory(Page_Directory * pd) {}
+        Directory() : _pd(calloc(1)) {
+            for(unsigned int i = 0; i < 544; i++){
+                (*_pd)[i] = (*_master)[i];
+            }
+        }
+        Directory(Page_Directory * pd) : _pd(pd) {}
+
+        Phy_Addr pd() const { return _pd; }
 
-        Page_Table * pd() const { return 0; }
+        void activate() {
+            CPU::satp((0x1 << 31) | (Phy_Addr)_pd >> 12);
+            ASM("sfence.vma");
+        }
 
-        void activate() {}
+        Log_Addr attach(const Chunk & chunk, unsigned int from = 0) {
+            for(unsigned int i = from; i < PD_ENTRIES - chunk.pts(); i++)
+                if(attach(i, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                    return i << DIRECTORY_SHIFT;
+            return false;
+        }
+
+        // Used to create non-relocatable segments such as code
+        Log_Addr attach(const Chunk & chunk, const Log_Addr & addr) {
+            unsigned int from = directory(addr);
+            if(!attach(from, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                return Log_Addr(false);
+            return from << DIRECTORY_SHIFT;
+        }
 
-        Log_Addr attach(const Chunk & chunk) { return chunk.phy_address(); }
-        Log_Addr attach(const Chunk & chunk, Log_Addr addr) { return (addr == chunk.phy_address())? addr : Log_Addr(false); }
         void detach(const Chunk & chunk) {}
         void detach(const Chunk & chunk, Log_Addr addr) {}
 
         Phy_Addr physical(Log_Addr addr) { return addr; }
-    };
 
-    // DMA_Buffer (straightforward without paging)
-    class DMA_Buffer: public Chunk
-    {
-    public:
-        DMA_Buffer(unsigned int s): Chunk(s, Flags::CT) {
-            db<MMU>(TRC) << "MMU::DMA_Buffer() => " << *this << endl;
+    private:
+        bool attach(unsigned int from, const Page_Table * pt, unsigned int n, RV32_Flags flags) {
+            for(unsigned int i = from; i < from + n; i++)
+                if((*static_cast<Page_Directory *>(phy2log(_pd)))[i]) // it has already been used
+                    return false;
+            for(unsigned int i = from; i < from + n; i++, pt++)
+                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = ((Phy_Addr(pt) >> 12) << 10) | flags; // is pt the correct value?
+            return true;
         }
 
-        Log_Addr log_address() const { return phy_address(); }
-
-        friend Debug & operator<<(Debug & db, const DMA_Buffer & b) {
-            db << "{phy=" << b.phy_address()
-               << ",log=" << b.log_address()
-               << ",size=" << b.size()
-               << ",flags=" << b.flags() << "}";
-            return db;
-        }
+    private:
+        Page_Directory * _pd;
     };
 
 public:
     MMU() {}
 
-    static Phy_Addr alloc(unsigned int bytes = 1) {
+    static Phy_Addr alloc(unsigned int frames = 1) {
         Phy_Addr phy(false);
-        if(bytes) {
-            List::Element * e = _free.search_decrementing(bytes);
+        if(frames) {
+            List::Element * e = _free.search_decrementing(frames);
             if(e)
-                phy = reinterpret_cast<unsigned int>(e->object()) + e->size();
+                phy = reinterpret_cast<unsigned int>(e->object()) + e->size() * PAGE_SIZE;
             else
                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
         }
-        db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+        db<MMU>(TRC) << "MMU::alloc(frames=" << frames << ") => " << phy << endl;
 
         return phy;
     };
 
-    static Phy_Addr calloc(unsigned int bytes = 1) {
-        Phy_Addr phy = alloc(bytes);
-        memset(phy, 0, bytes);
+    static Phy_Addr calloc(unsigned int frames = 1) {
+        Phy_Addr phy = alloc(frames);
+        memset(phy2log(phy), 0, frames*PAGE_SIZE);
         return phy;
     }
 
-    static void free(Phy_Addr addr, unsigned int n = 1) {
-        db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
-
-        // No unaligned addresses if the CPU doesn't support it
-        assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
+    static void free(Phy_Addr frame, unsigned int n = 1) {
+        db<MMU>(TRC) << "MMU::free(frame=" << frame << ",n=" << n << ")" << endl;
 
-        // Free blocks must be large enough to contain a list element
-        assert(n > sizeof (List::Element));
-
-        if(addr && n) {
-            List::Element * e = new (addr) List::Element(addr, n);
+        if(frame && n) {
+            List::Element * e = new (frame) List::Element(frame, n);
             List::Element * m1, * m2;
             _free.insert_merging(e, &m1, &m2);
         }
@@ -133,7 +225,7 @@ public:
 
     static unsigned int allocable() { return _free.head() ? _free.head()->size() : 0; }
 
-    static Page_Directory * volatile current() { return 0; }
+    static Page_Directory * volatile current() { return _master; }
 
     static Phy_Addr physical(Log_Addr addr) { return addr; }
 
@@ -143,8 +235,11 @@ public:
 private:
     static void init();
 
+    static Log_Addr phy2log(const Phy_Addr & phy) { return phy ; }
+
 private:
     static List _free;
+    static Page_Directory * _master;
 };
 
 __END_SYS
diff --git a/include/machine/display.h b/include/machine/display.h
index 03a873c..f3599c7 100644
--- a/include/machine/display.h
+++ b/include/machine/display.h
@@ -34,6 +34,7 @@ public:
 class Serial_Display: public Display_Common
 {
     friend class PC_Setup;
+    friend class Setup_SifiveE;
     friend class Serial_Keyboard;
     friend class Machine;
 
diff --git a/include/machine/riscv/riscv_ic.h b/include/machine/riscv/riscv_ic.h
index c4ba106..e305efc 100644
--- a/include/machine/riscv/riscv_ic.h
+++ b/include/machine/riscv/riscv_ic.h
@@ -16,7 +16,7 @@ public:
     static const unsigned int IRQS = 16;
 
     // Interrupts (mcause with interrupt = 1)
-    enum {
+    enum : unsigned int {
         IRQ_USR_SOFT            = 0,
         IRQ_SUP_SOFT            = 1,
         IRQ_MAC_SOFT            = 3,
@@ -26,7 +26,8 @@ public:
         IRQ_USR_EXT             = 8,
         IRQ_SUP_EXT             = 9,
         IRQ_MAC_EXT             = 11,
-        INTERRUPT               = 1 << 31
+        INTERRUPT               = 1UL << 31,
+        INT_MASK                = ~INTERRUPT
     };
 
     // Registers offsets from CLINT_BASE
@@ -43,6 +44,7 @@ public:
 class IC: private IC_Common, private CLINT
 {
     friend class Machine;
+    friend class Setup_SifiveE;
 
 private:
     typedef CPU::Reg Reg;
@@ -55,8 +57,8 @@ public:
 
     enum {
         HARD_INT        = CPU::EXCEPTIONS,
-        INT_SYS_TIMER   = HARD_INT + IRQ_MAC_TIMER,
-        INT_RESCHEDULER = HARD_INT + IRQ_MAC_SOFT, // An IPI is mapped to the machine with mcause set to IRQ_MAC_SOFT
+        INT_SYS_TIMER   = HARD_INT + IRQ_SUP_TIMER,
+        INT_RESCHEDULER = HARD_INT + IRQ_SUP_SOFT, // An IPI is mapped to the machine with mcause set to IRQ_MAC_SOFT
         INT_MASK        = CPU::Reg32(1 << 31) - 1
     };
 
@@ -76,7 +78,7 @@ public:
 
     static void enable() {
         db<IC>(TRC) << "IC::enable()" << endl;
-        CPU::mie(CPU::MSI | CPU::MTI | CPU::MEI);
+        CPU::sie(CPU::SSI | CPU::STI | CPU::SEI);
     }
 
     static void enable(Interrupt_Id i) {
@@ -88,7 +90,7 @@ public:
 
     static void disable() {
         db<IC>(TRC) << "IC::disable()" << endl;
-        CPU::mie_clear(CPU::MSI | CPU::MTI | CPU::MEI);
+        CPU::sie_clear(CPU::SSI | CPU::STI | CPU::SEI);
     }
 
     static void disable(Interrupt_Id i) {
@@ -100,7 +102,7 @@ public:
 
     static Interrupt_Id int_id() {
         // Id is retrieved from mcause even if mip has the equivalent bit up, because only mcause can tell if it is an interrupt or an exception
-        Reg id = CPU::mcause();
+        Reg id = CPU::scause();
         if(id & INTERRUPT)
             return (id & INT_MASK) + HARD_INT;
         else
@@ -131,7 +133,7 @@ private:
     static void exception(Interrupt_Id i);
 
     // Physical handler
-    static void entry();
+    [[gnu::naked, gnu::aligned(4)]] static void entry();
 
     static void init();
 
diff --git a/include/machine/riscv/riscv_info.h b/include/machine/riscv/riscv_info.h
deleted file mode 100644
index f50bdda..0000000
--- a/include/machine/riscv/riscv_info.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// EPOS RISC-V Common Run-Time System Information
-
-#ifndef __riscv_info_h
-#define __riscv_info_h
-
-#include <system/info.h>
-
-__BEGIN_SYS
-
-struct System_Info
-{
-private:
-    typedef unsigned int LAddr;
-    typedef unsigned int PAddr;
-    typedef unsigned int Size;
-
-public:
-    // The information we have at boot time (built by MKBI)
-    // Modifications to this map requires adjustments at MKBI
-    struct Boot_Map
-    {
-        volatile unsigned int n_cpus;     // Number of CPUs in SMPs
-        PAddr mem_base;                   // Memory base address
-        PAddr mem_top;                    // Memory top address
-        PAddr io_base;                    // I/O Memory base address
-        PAddr io_top;                     // I/O Memory top address
-        int node_id;                      // Local node id in SAN (-1 => RARP)
-        int space_x;                      // Spatial coordinates of a node (-1 => mobile)
-        int space_y;                      //
-        int space_z;                      //
-        unsigned char uuid[8];            // EPOS image Universally Unique Identifier
-        Size img_size;                    // Boot image size (in bytes)
-        Size setup_offset;                // Image offsets (-1 => not present)
-        Size init_offset;
-        Size system_offset;
-        Size application_offset;
-        Size extras_offset;
-    };
-
-    // Load Map (not used in this machine, but kept for architectural transparency)
-    struct Load_Map
-    {
-        bool  has_ext;
-        LAddr app_entry;
-        Size  app_segments;
-        LAddr app_code;
-        Size  app_code_size;
-        LAddr app_data;
-        LAddr app_stack;
-        LAddr app_heap;
-        Size  app_data_size;
-        PAddr app_extra;
-        Size  app_extra_size;
-    };
-
-public:
-    Boot_Map bm;
-    Load_Map lm;
-};
-
-__END_SYS
-
-#endif
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index 18cca96..2b50117 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -17,13 +17,16 @@ class Timer: private Timer_Common, private CLINT
     friend Machine;
     friend IC;
     friend class Init_System;
-
 protected:
+    friend class Setup_SifiveE; // Timer::config will be called during setup
     static const unsigned int CHANNELS = 2;
     static const unsigned int FREQUENCY = Traits<Timer>::FREQUENCY;
-
     typedef IC_Common::Interrupt_Id Interrupt_Id;
 
+    static void config(const Hertz & frequency) {
+        reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
+    }
+
 public:
     using Timer_Common::Tick;
     using Timer_Common::Handler;
@@ -72,10 +75,6 @@ public:
 private:
     static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
 
-    static void config(const Hertz & frequency) {
-        reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
-    }
-
     static void int_handler(Interrupt_Id i);
 
     static void init();
diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
index f50bdda..4f9f592 100644
--- a/include/machine/riscv/sifive_e/sifive_e_info.h
+++ b/include/machine/riscv/sifive_e/sifive_e_info.h
@@ -1,12 +1,31 @@
 // EPOS RISC-V Common Run-Time System Information
 
-#ifndef __riscv_info_h
-#define __riscv_info_h
+#ifndef __riscv_sifive_e_info_h
+#define __riscv_sifive_e_info_h
 
 #include <system/info.h>
 
 __BEGIN_SYS
 
+
+struct App_Load_Map
+{
+private:
+    typedef unsigned int LAddr;
+    typedef unsigned int PAddr;
+    typedef unsigned int Size;
+
+public:
+    LAddr app_entry;
+    Size  app_segments;
+    LAddr app_code;
+    Size  app_code_size;
+    LAddr app_data;
+    LAddr app_stack;
+    LAddr app_heap;
+    Size  app_data_size;
+};
+
 struct System_Info
 {
 private:
@@ -22,8 +41,8 @@ public:
         volatile unsigned int n_cpus;     // Number of CPUs in SMPs
         PAddr mem_base;                   // Memory base address
         PAddr mem_top;                    // Memory top address
-        PAddr io_base;                    // I/O Memory base address
-        PAddr io_top;                     // I/O Memory top address
+        PAddr mio_base;                   // Memory-mapped I/O base address
+        PAddr mio_top;                    // Memory-mapped I/O top address
         int node_id;                      // Local node id in SAN (-1 => RARP)
         int space_x;                      // Spatial coordinates of a node (-1 => mobile)
         int space_y;                      //
@@ -33,25 +52,51 @@ public:
         Size setup_offset;                // Image offsets (-1 => not present)
         Size init_offset;
         Size system_offset;
-        Size application_offset;
+        Size application_offset[8];
+        unsigned int n_apps;
         Size extras_offset;
     };
 
-    // Load Map (not used in this machine, but kept for architectural transparency)
     struct Load_Map
     {
+        bool  has_stp;
+        bool  has_ini;
+        bool  has_sys;
+        bool  has_app;
         bool  has_ext;
-        LAddr app_entry;
-        Size  app_segments;
-        LAddr app_code;
-        Size  app_code_size;
-        LAddr app_data;
-        LAddr app_stack;
-        LAddr app_heap;
-        Size  app_data_size;
+        LAddr stp_entry;
+        Size  stp_segments;
+        LAddr stp_code;
+        Size  stp_code_size;
+        LAddr stp_data;
+        Size  stp_data_size;
+        LAddr ini_entry;
+        Size  ini_segments;
+        LAddr ini_code;
+        Size  ini_code_size;
+        LAddr ini_data;
+        Size  ini_data_size;
+        LAddr sys_entry;
+        Size  sys_segments;
+        LAddr sys_code;
+        Size  sys_code_size;
+        LAddr sys_data;
+        Size  sys_data_size;
+        LAddr sys_stack;
+        Size  sys_stack_size;
+        App_Load_Map app[8];
+        // LAddr app_entry;
+        // Size  app_segments;
+        // LAddr app_code;
+        // Size  app_code_size;
+        // LAddr app_data;
+        // LAddr app_stack;
+        // LAddr app_heap;
+        // Size  app_data_size;
         PAddr app_extra;
         Size  app_extra_size;
     };
+    
 
 public:
     Boot_Map bm;
diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
index 3ea43bd..f36d8b7 100644
--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
@@ -11,7 +11,9 @@ __BEGIN_SYS
 
 struct Memory_Map
 {
-    // Physical Memory
+    static const unsigned int NOT_USED = Traits<Machine>::NOT_USED;
+    
+    // Memory Mapped stuff
     enum {
         TEST_BASE                   = 0x00100000, // SiFive test engine
         RTC_BASE                    = 0x00101000, // goldfish_rtc
@@ -24,11 +26,21 @@ struct Memory_Map
     // Physical Memory
     enum {
         MEM_BASE        = Traits<Machine>::MEM_BASE,
-        MEM_TOP         = Traits<Machine>::MEM_TOP
+        MEM_TOP         = Traits<Machine>::MEM_TOP,
+        MIO_BASE        = Traits<Machine>::MIO_BASE,
+        MIO_TOP         = Traits<Machine>::MIO_TOP,
+        BOOT_STACK      = Traits<Machine>::BOOT_STACK,
+        PAGE_TABLES     = Traits<Machine>::PAGE_TABLES,
+        MMODE_F         = Traits<Machine>::MMODE_F,
     };
 
     // Logical Address Space
     enum {
+        BOOT            = Traits<Machine>::BOOT,
+        IMAGE           = Traits<Machine>::IMAGE,
+        SETUP           = Traits<Machine>::SETUP,
+        INIT            = Traits<Machine>::INIT,
+
         APP_LOW         = Traits<Machine>::APP_LOW,
         APP_CODE        = Traits<Machine>::APP_CODE,
         APP_DATA        = Traits<Machine>::APP_DATA,
@@ -37,10 +49,10 @@ struct Memory_Map
         PHY_MEM         = Traits<Machine>::PHY_MEM,
         IO              = Traits<Machine>::IO_BASE,
 
-        SYS             = Traits<Machine>::NOT_USED,
-        SYS_INFO        = unsigned(-1),                 // Dynamically built during initialization.
-        SYS_CODE        = Traits<Machine>::NOT_USED,
-        SYS_DATA        = Traits<Machine>::NOT_USED,
+        SYS             = Traits<Machine>::SYS,
+        SYS_INFO        = Traits<Machine>::SYS_INFO,
+        SYS_CODE        = Traits<Machine>::SYS_CODE,
+        SYS_DATA        = Traits<Machine>::SYS_DATA,
         SYS_HEAP        = Traits<Machine>::NOT_USED,
         SYS_STACK       = Traits<Machine>::NOT_USED
     };
diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
index 9fa9ce7..07662bf 100644
--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
+++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
@@ -10,6 +10,7 @@ __BEGIN_SYS
 class Machine_Common;
 template<> struct Traits<Machine_Common>: public Traits<Build> {};
 
+//!ECALL: When will we allocate a kernel stack? We may repurpose boot_stack by not freeing it.
 template <> struct Traits<Machine>: public Traits<Machine_Common>
 {
     static const bool cpus_use_local_timer      = false;
@@ -20,33 +21,40 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
     // Boot Image
     static const unsigned int BOOT_LENGTH_MIN   = NOT_USED;
     static const unsigned int BOOT_LENGTH_MAX   = NOT_USED;
+    static const unsigned int BOOT_STACK        = 0x87ffffff;
 
     // Physical Memory
     static const unsigned int MEM_BASE          = 0x80000000;
-    static const unsigned int VECTOR_TABLE      = NOT_USED;
-    static const unsigned int PAGE_TABLES       = NOT_USED; // No paging MMU
     static const unsigned int MEM_TOP           = 0x87ffffff; // 128 MB
-    static const unsigned int BOOT_STACK        = 0x87ffffff;
+    static const unsigned int MIO_BASE          = 0x00000000;
+    static const unsigned int MIO_TOP           = 0x100081ff;
 
+    static const unsigned int VECTOR_TABLE      = NOT_USED;
+    static const unsigned int PAGE_TABLES       = 0x87ffffff + 1 - 16*1024 - ((1024+1)*4*1024); // 0x87BFB000
+    static const unsigned int SYS_INFO          = PAGE_TABLES - 4096; 
+    static const unsigned int MMODE_F           = SYS_INFO - 4096;
+   
     // Logical Memory Map
     static const unsigned int BOOT              = NOT_USED;
-    static const unsigned int SETUP             = NOT_USED;
-    static const unsigned int INIT              = NOT_USED;
-
-    static const unsigned int APP_LOW           = 0x80000000;
-    static const unsigned int APP_CODE          = 0x80000000;
-    static const unsigned int APP_DATA          = 0x80000000;
+    static const unsigned int IMAGE             = NOT_USED;
+    // static const unsigned int SETUP             = 0x80000000 + 0x78; // This controls whether an ELF file is generated for setup; boot + elf header
+    static const unsigned int SETUP             = 0x80000000;
+    static const unsigned int INIT              = 0x80200000;
+
+    static const unsigned int APP_LOW           = 0x88000000;
+    static const unsigned int APP_CODE          = 0x88000000;
+    static const unsigned int APP_DATA          = 0xffc00000;
     static const unsigned int APP_HIGH          = 0x87ffffff;
 
-    static const unsigned int PHY_MEM           = NOT_USED; // No paging MMU
-    static const unsigned int IO_BASE           = NOT_USED; // No paging MMU
-    static const unsigned int IO_TOP            = NOT_USED; // No paging MMU
+    static const unsigned int PHY_MEM           = NOT_USED;
+    static const unsigned int IO_BASE           = NOT_USED;
+    static const unsigned int IO_TOP            = NOT_USED;
 
-    static const unsigned int SYS               = NOT_USED; // No paging MMU
-    static const unsigned int SYS_CODE          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_DATA          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_HEAP          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_STACK         = NOT_USED; // No paging MMU
+    static const unsigned int SYS               = 0x80300000;
+    static const unsigned int SYS_CODE          = SYS;
+    static const unsigned int SYS_DATA          = 0x80400000;
+    static const unsigned int SYS_HEAP          = NOT_USED;
+    static const unsigned int SYS_STACK         = NOT_USED;
 
     // Default Sizes and Quantities
     static const unsigned int STACK_SIZE        = 16 * 1024;
@@ -60,6 +68,7 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
 template <> struct Traits<IC>: public Traits<Machine_Common>
 {
     static const bool debugged = hysterically_debugged;
+    static const bool enabled = true;
 
     static const unsigned int IRQS = 1024; // PLIC
     static const unsigned int INTS = 1056; // Exceptions + Software + Local + Timer + External
@@ -68,6 +77,7 @@ template <> struct Traits<IC>: public Traits<Machine_Common>
 template <> struct Traits<Timer>: public Traits<Machine_Common>
 {
     static const bool debugged = hysterically_debugged;
+    static const bool enabled = true;
 
     static const unsigned int UNITS = 1;
 
@@ -104,7 +114,7 @@ template<> struct Traits<Serial_Display>: public Traits<Machine_Common>
 
 template<> struct Traits<Scratchpad>: public Traits<Machine_Common>
 {
-    static const bool enabled = false;
+    static const bool enabled = true;
 };
 
 __END_SYS
diff --git a/include/memory.h b/include/memory.h
index b2f8be5..ed73b23 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -9,10 +9,6 @@ __BEGIN_SYS
 
 class Address_Space: private MMU::Directory
 {
-
-private:
-    using MMU::Directory::activate;
-
 public:
     typedef CPU::Phy_Addr Phy_Addr;
     typedef CPU::Log_Addr Log_Addr;
@@ -23,6 +19,7 @@ public:
     ~Address_Space();
 
     using MMU::Directory::pd;
+    using MMU::Directory::activate;
 
     Log_Addr attach(Segment * seg);
     Log_Addr attach(Segment * seg, const Log_Addr & addr);
@@ -43,8 +40,8 @@ public:
     typedef MMU::Flags Flags;
 
 public:
-    Segment(unsigned int bytes, const Color & color = Color::WHITE, const Flags & flags = Flags::APP);
-    Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
+    Segment(unsigned int bytes, const Flags & flags);
+    // Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
     ~Segment();
 
     unsigned int size() const;
diff --git a/include/process.h b/include/process.h
index 5978227..65a4f44 100644
--- a/include/process.h
+++ b/include/process.h
@@ -7,6 +7,7 @@
 #include <machine.h>
 #include <utility/queue.h>
 #include <utility/handler.h>
+#include <scheduler.h>
 
 extern "C" { void __exit(); }
 
@@ -16,12 +17,14 @@ class Thread
 {
     friend class Init_First;            // context->load()
     friend class Init_System;           // for init() on CPU != 0
+    friend class Scheduler<Thread>;     // for link()
     friend class Synchronizer_Common;   // for lock() and sleep()
     friend class Alarm;                 // for lock()
     friend class System;                // for init()
+    friend class IC;                    // for link() for priority ceiling
 
 protected:
-    static const bool preemptive = Traits<Thread>::preemptive;
+    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
     static const bool reboot = Traits<System>::reboot;
 
     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
@@ -40,26 +43,26 @@ public:
         FINISHING
     };
 
-    // Thread Priority
-    typedef unsigned int Priority;
+    // Thread Scheduling Criterion
+    typedef Traits<Thread>::Criterion Criterion;
     enum {
-        MAIN   = 0,
-        HIGH   = 1,
-        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 4,
-        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
-        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2
+        HIGH    = Criterion::HIGH,
+        NORMAL  = Criterion::NORMAL,
+        LOW     = Criterion::LOW,
+        MAIN    = Criterion::MAIN,
+        IDLE    = Criterion::IDLE
     };
 
     // Thread Queue
-    typedef Ordered_Queue<Thread, Priority> Queue;
+    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
 
     // Thread Configuration
     struct Configuration {
-        Configuration(const State & s = READY, const Priority & p = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), priority(p), stack_size(ss) {}
+        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+        : state(s), criterion(c), stack_size(ss) {}
 
         State state;
-        Priority priority;
+        Criterion criterion;
         unsigned int stack_size;
     };
 
@@ -78,8 +81,8 @@ public:
 
     int join();
     void pass();
-    void suspend() { suspend(false); }
-    void resume() { resume(false); }
+    void suspend();
+    void resume();
 
     static Thread * volatile self() { return running(); }
     static void yield();
@@ -89,15 +92,15 @@ protected:
     void constructor_prologue(unsigned int stack_size);
     void constructor_epilogue(const Log_Addr & entry, unsigned int stack_size);
 
-    static Thread * volatile running() { return _running; }
+    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
+    Queue::Element * link() { return &_link; }
+
+    static Thread * volatile running() { return _scheduler.chosen(); }
 
     static void lock() { CPU::int_disable(); }
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
 
-    void suspend(bool locked);
-    void resume(bool unpreemptive);
-
     static void sleep(Queue * q);
     static void wakeup(Queue * q);
     static void wakeup_all(Queue * q);
@@ -105,7 +108,7 @@ protected:
     static void reschedule();
     static void time_slicer(IC::Interrupt_Id interrupt);
 
-    static void dispatch(Thread * prev, Thread * next);
+    static void dispatch(Thread * prev, Thread * next, bool charge = true);
 
     static int idle();
 
@@ -119,14 +122,12 @@ protected:
     Queue * _waiting;
     Thread * volatile _joining;
     Queue::Element _link;
+    
+    volatile Task * _task;
 
     static volatile unsigned int _thread_count;
     static Scheduler_Timer * _timer;
-
-private:
-    static Thread * volatile _running;
-    static Queue _ready;
-    static Queue _suspended;
+    static Scheduler<Thread> _scheduler;
 };
 
 
@@ -141,7 +142,7 @@ inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
 
 template<typename ... Tn>
 inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.priority)
+: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
     constructor_prologue(conf.stack_size);
     _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
@@ -149,6 +150,22 @@ inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ...
 }
 
 
+// A Java-like Active Object
+class Active: public Thread
+{
+public:
+    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
+    virtual ~Active() {}
+
+    virtual int run() = 0;
+
+    void start() { resume(); }
+
+private:
+    static int entry(Active * runnable) { return runnable->run(); }
+};
+
+
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
@@ -162,6 +179,53 @@ private:
     Thread * _handler;
 };
 
+
+class Task
+{
+private:
+    static const bool multitask = Traits<System>::multitask;
+    typedef CPU::Log_Addr Log_Addr;
+
+public:
+    static volatile Task * _active;
+    Task(Segment * cs, Segment * ds)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    Task(Address_Space * as, Segment * cs, Segment * ds)
+    : _as(as), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    ~Task();
+    
+    static void activate(volatile Task * t) {
+        Task::_active = t;
+        t->_as->activate();
+    }
+
+    // void activate() {
+    //     Task::_active = this;
+    //     _as->activate();
+    // }
+    
+    Address_Space * address_space() const { return _as; }
+
+    Segment * code_segment() const { return _cs; }
+    Segment * data_segment() const { return _ds; }
+
+    Log_Addr code() const { return _code; }
+    Log_Addr data() const { return _data; }
+
+
+private:
+    Address_Space * _as;
+    Segment * _cs;
+    Segment * _ds;
+    Log_Addr _code;
+    Log_Addr _data;
+    
+};
+
 __END_SYS
 
 #endif
diff --git a/include/real-time.h b/include/real-time.h
new file mode 100644
index 0000000..4b2b0c8
--- /dev/null
+++ b/include/real-time.h
@@ -0,0 +1,138 @@
+// EPOS Real-time Declarations
+
+#ifndef __real_time_h
+#define __real_time_h
+
+#include <utility/handler.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+#include <time.h>
+#include <process.h>
+#include <synchronizer.h>
+
+__BEGIN_SYS
+
+// Aperiodic Thread
+typedef Thread Aperiodic_Thread;
+
+// Periodic threads are achieved by programming an alarm handler to invoke
+// p() on a control semaphore after each job (i.e. task activation). Base
+// threads are created in BEGINNING state, so the scheduler won't dispatch
+// them before the associate alarm and semaphore are created. The first job
+// is dispatched by resume() (thus the _state = SUSPENDED statement)
+
+// Periodic Thread
+class Periodic_Thread: public Thread
+{
+
+protected:
+    // Alarm Handler for periodic threads under static scheduling policies
+    class Static_Handler: public Semaphore_Handler
+    {
+    public:
+        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
+        ~Static_Handler() {}
+    };
+
+    // Alarm Handler for periodic threads under dynamic scheduling policies
+    class Dynamic_Handler: public Semaphore_Handler
+    {
+    public:
+        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
+        ~Dynamic_Handler() {}
+
+        void operator()() {
+            _thread->criterion().update();
+
+            Semaphore_Handler::operator()();
+        }
+
+    private:
+        Periodic_Thread * _thread;
+    };
+
+    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
+
+public:
+    // struct Configuration: public Thread::Configuration {
+    //     Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+    //     : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
+
+    //     Microsecond period;
+    //     Microsecond deadline;
+    //     Microsecond capacity;
+    //     Microsecond activation;
+    //     unsigned int times;
+    // };
+
+//!SMODE: 
+struct Configuration {
+        Configuration(const Microsecond & p, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = HIGH, unsigned int ss = STACK_SIZE)
+        : period(p), times(n), state(s), criterion(p, c), stack_size(ss) {}
+
+        Microsecond period;
+        unsigned int times;
+        State state;
+        Criterion criterion;
+        unsigned int stack_size;
+};
+
+public:
+    // template<typename ... Tn>
+    // Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+    // typedef Alarm::Tick Tick;
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Tick & t, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(t)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(t * Alarm::timer_period(), &_handler, INFINITE) { resume(); }
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+    //     if((conf.state == READY) || (conf.state == RUNNING)) {
+    //         _state = SUSPENDED;
+    //         resume();
+    //     } else
+    //         _state = conf.state;
+    // }
+
+    template<typename ... Tn>
+    Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    : Thread(Thread::Configuration(SUSPENDED, conf.criterion, conf.stack_size), entry, an ...),
+      _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+        if((conf.state == READY) || (conf.state == RUNNING)) {
+            _state = SUSPENDED;
+            resume();
+        } else
+            _state = conf.state;
+    }
+
+    const Microsecond & period() const { return _alarm.period(); }
+    void period(const Microsecond & p) { _alarm.period(p); }
+
+    static volatile bool wait_next() {
+        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
+
+        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
+
+        if(t->_alarm.times())
+            t->_semaphore.p();
+
+        return t->_alarm.times();
+    }
+
+protected:
+    Semaphore _semaphore;
+    Handler _handler;
+    Alarm _alarm;
+};
+
+typedef Periodic_Thread::Configuration RTConf;
+
+__END_SYS
+
+#endif
diff --git a/include/scheduler.h b/include/scheduler.h
new file mode 100644
index 0000000..8e8a512
--- /dev/null
+++ b/include/scheduler.h
@@ -0,0 +1,229 @@
+// EPOS Scheduler Component Declarations
+
+#ifndef __scheduler_h
+#define __scheduler_h
+
+#include <architecture/cpu.h>
+#include <architecture/pmu.h>
+#include <architecture/tsc.h>
+#include <utility/scheduling.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+
+__BEGIN_SYS
+
+// All scheduling criteria, or disciplines, must define operator int() with
+// the semantics of returning the desired order of a given object within the
+// scheduling list
+class Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+    friend class _SYS::Clerk<System>;         // for _statistics
+
+public:
+    // Priorities
+    enum : int {
+        MAIN   = 0,
+        HIGH   = 1,
+        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
+        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2,
+        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+    };
+
+    // Constructor helpers
+    enum : unsigned int {
+        SAME        = 0,
+        NOW         = 0,
+        UNKNOWN     = 0,
+        ANY         = -1U
+    };
+
+    // Policy types
+    enum : int {
+        PERIODIC    = HIGH,
+        APERIODIC   = NORMAL,
+        SPORADIC    = NORMAL
+    };
+
+    // Policy traits
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+    static const bool collecting = false;
+    static const bool charging = false;
+    static const bool awarding = false;
+    static const bool migrating = false;
+    static const bool track_idle = false;
+    static const bool task_wide = false;
+    static const bool cpu_wide = false;
+    static const bool system_wide = false;
+    static const unsigned int QUEUES = 1;
+
+    // Runtime Statistics (for policies that don't use any; thats why its a union)
+    union Statistics {
+        // Thread Execution Time
+        TSC::Time_Stamp thread_execution_time;  // accumulated thread execution time
+        TSC::Time_Stamp last_thread_dispatch;   // time stamp of last dispatch
+
+        // Deadline Miss count - Used By Clerk
+        Alarm * alarm_times;                    // pointer to RT_Thread private alarm (for monitoring purposes)
+        unsigned int finished_jobs;             // number of finished jobs given by the number of times alarm->p() was called for this thread
+        unsigned int missed_deadlines;          // number of missed deadlines given by the number of finished jobs (finished_jobs) minus the number of dispatched jobs (alarm_times->times)
+
+        // CPU Execution Time (capture ts)
+        static TSC::Time_Stamp _cpu_time[Traits<Build>::CPUS];              // accumulated CPU time in the current hyperperiod for each CPU
+        static TSC::Time_Stamp _last_dispatch_time[Traits<Build>::CPUS];    // time Stamp of last dispatch in each CPU
+        static TSC::Time_Stamp _last_activation_time;                       // global time stamp of the last heuristic activation
+    };
+
+protected:
+    Scheduling_Criterion_Common() {}
+
+public:
+    const Microsecond period() { return 0;}
+    void period(const Microsecond & p) {}
+
+    unsigned int queue() const { return 0; }
+    void queue(unsigned int q) {}
+
+    bool update() { return false; }
+
+    bool collect(bool end = false) { return false; }
+    bool charge(bool end = false) { return true; }
+    bool award(bool end = false) { return true; }
+
+    volatile Statistics & statistics() { return _statistics; }
+
+    static void init() {}
+
+protected:
+    Statistics _statistics;
+};
+
+// Priority (static and dynamic)
+class Priority: public Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+
+public:
+    template <typename ... Tn>
+    Priority(int p = NORMAL, Tn & ... an): _priority(p) {}
+
+    operator const volatile int() const volatile { return _priority; }
+
+protected:
+    volatile int _priority;
+};
+
+// Round-Robin
+class RR: public Priority
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    template <typename ... Tn>
+    RR(int p = NORMAL, Tn & ... an): Priority(p) {}
+};
+
+// First-Come, First-Served (FIFO)
+class FCFS: public Priority
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = false;
+
+public:
+    template <typename ... Tn>
+    FCFS(int p = NORMAL, Tn & ... an);
+};
+
+
+// Real-time Algorithms
+class Real_Time_Scheduler_Common: public Priority
+{
+protected:
+    Real_Time_Scheduler_Common(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {} // aperiodic
+    Real_Time_Scheduler_Common(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
+    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
+
+public:
+    const Microsecond period() { return _period; }
+    void period(const Microsecond & p) { _period = p; }
+
+public:
+    Microsecond _deadline;
+    Microsecond _period;
+    Microsecond _capacity;
+};
+
+// Rate Monotonic
+// class RM:public Real_Time_Scheduler_Common
+// {
+// public:
+//     static const bool timed = false;
+//     static const bool dynamic = false;
+//     static const bool preemptive = true;
+
+// public:
+//     RM(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+//     RM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+//     : Real_Time_Scheduler_Common(p ? p : d, d, p, c) {}
+// };
+
+//!SMODE:
+// Rate Monotonic
+class RM: public Priority
+{
+public:
+    static const bool preemptive = true;
+    static const bool timed = true;
+
+public:
+    // used for aperiodic threads
+    RM(int priority): Priority(priority) {}
+
+    // used for periodic threads
+    template <typename ... Tn>
+    RM(const Microsecond & period, int priority, Tn & ... an);
+};
+
+// Deadline Monotonic
+class DM: public Real_Time_Scheduler_Common
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    DM(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+    : Real_Time_Scheduler_Common(d, d, p, c) {}
+};
+
+// Earliest Deadline First
+class EDF: public Real_Time_Scheduler_Common
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = true;
+    static const bool preemptive = true;
+
+public:
+    EDF(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+    EDF(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY);
+
+    void update();
+};
+
+__END_SYS
+
+#endif
diff --git a/include/time.h b/include/time.h
index a024cb7..7e9e0e0 100644
--- a/include/time.h
+++ b/include/time.h
@@ -31,7 +31,9 @@ class Alarm
 {
     friend class System;                        // for init()
     friend class Alarm_Chronometer;             // for elapsed()
+    friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
     friend class FCFS;                          // for ticks() and elapsed()
+    friend class EDF;                           // for ticks() and elapsed()
 
 private:
     typedef Timer_Common::Tick Tick;
@@ -47,22 +49,22 @@ public:
     void reset();
 
     static Hertz frequency() { return _timer->frequency(); }
+    static Microsecond timer_period() { return 1000000 / frequency(); }
+    static volatile Tick & elapsed() { return _elapsed; }
+    static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
 
     static void delay(const Microsecond & time);
 
 private:
-    static void init();
-
-    static volatile Tick & elapsed() { return _elapsed; }
-
-    static Microsecond timer_period() { return 1000000 / frequency(); }
-    static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
+    unsigned int times() const { return _times; }
 
     static void lock();
     static void unlock();
 
     static void handler(IC::Interrupt_Id i);
 
+    static void init();
+
 private:
     Microsecond _time;
     Handler * _handler;
@@ -102,8 +104,6 @@ public:
     void stop() { lap(); }
 
     Microsecond read() { return ticks() * 1000000 / frequency(); }
-
-private:
     Time_Stamp ticks() {
         if(_start == 0)
             return 0;
@@ -112,6 +112,8 @@ private:
         return _stop - _start;
     }
 
+private:
+
 private:
     TSC tsc;
     Time_Stamp _start;
diff --git a/include/utility/elf.h b/include/utility/elf.h
index 0ef4158..df2b4b5 100644
--- a/include/utility/elf.h
+++ b/include/utility/elf.h
@@ -31,7 +31,7 @@ public:
         : seg(i)->p_align ? seg(i)->p_vaddr
         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
     }
-
+    
     int segment_size(int i) {
         return (i > segments()) ? -1 : (int)(
             ((seg(i)->p_offset % seg(i)->p_align)
diff --git a/include/utility/heap.h b/include/utility/heap.h
index f377454..57fd84b 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -18,6 +18,9 @@ protected:
 public:
     using Grouping_List<char>::empty;
     using Grouping_List<char>::size;
+    using Grouping_List<char>::search_decrementing;
+    using Grouping_List<char>::find_first;
+    using Grouping_List<char>::find_worst;
 
     Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
@@ -30,8 +33,7 @@ public:
     }
 
     void * alloc(unsigned int bytes) {
-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
         if(!bytes)
             return 0;
 
@@ -45,6 +47,8 @@ public:
         if(bytes < sizeof(Element))
             bytes = sizeof(Element);
 
+        db<Heaps>(TRC) << "First Fit: " << find_first(bytes) << endl;
+        db<Heaps>(TRC) << "Worst Fit: " << find_worst(bytes) << endl;
         Element * e = search_decrementing(bytes);
         if(!e) {
             out_of_memory();
@@ -65,7 +69,7 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
-        if(ptr && (bytes >= sizeof(Element))) {
+        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
diff --git a/include/utility/list.h b/include/utility/list.h
index ccc8954..eca1174 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -1348,7 +1348,7 @@ public:
 
     Element * search_size(unsigned int s) {
         Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
+        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
         else
             for(; e && (e->size() < s); e = e->next());
@@ -1381,7 +1381,7 @@ public:
         print_head();
         print_tail();
 
-        Element * e = search_size(s);
+        Element * e = find_worst(s);
         if(e) {
             e->shrink(s);
             _grouped_size -= s;
@@ -1392,6 +1392,33 @@ public:
         return e;
     }
 
+    // Used by Heap/Worst-Fit
+    // for empty lists, return 0
+    // for nonempty lists,
+    //      return 0 if there is no element big enough to fit s
+    //      return the element with biggest size otherwise
+    // precons:
+    //  1. s >= sizeof(Element) [s >= 16]
+    Element * find_worst(unsigned int s) {
+        Element * max = 0;
+        unsigned max_size = 0;
+        for(Element * e = head(); e; e = e->next()) {
+            if (e->size() > max_size) {
+                max_size = e->size();
+                max = e;
+            }
+        }
+
+        if (max_size < s)
+            return 0;
+
+        return max;
+    }
+
+    Element * find_first(unsigned int s) {
+        return search_size(s);
+    }
+
 private:
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
diff --git a/makedefs b/makedefs
index 21674d9..62deb60 100644
--- a/makedefs
+++ b/makedefs
@@ -86,6 +86,7 @@ MEM_SIZE                = $(shell $(BIN)/eposcfg MEM_SIZE_KB 2> /dev/null)
 BOOT_ADDR               = $(shell $(BIN)/eposcfg BOOT 2> /dev/null)
 SETUP_ADDR              = $(shell $(BIN)/eposcfg SETUP 2> /dev/null)
 INIT_ADDR               = $(shell $(BIN)/eposcfg INIT 2> /dev/null)
+MMODE_F                 = $(shell $(BIN)/eposcfg MMODE_F 2> /dev/null)
 SYS_CODE_ADDR           = $(shell $(BIN)/eposcfg SYS_CODE 2> /dev/null)
 SYS_DATA_ADDR           = $(shell $(BIN)/eposcfg SYS_DATA 2> /dev/null)
 UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g')
@@ -103,7 +104,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
 pc_AS_FLAGS		:= --32
 pc_LD_FLAGS		:= -m elf_i386
 pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
-pc_DEBUGGER		:= gdb
+pc_DEBUGGER		:= gdb -tui
 pc_FLASHER		:=
 pc_MAGIC		:= --nmagic
 pc_CODE_NAME		:= .init
@@ -114,7 +115,7 @@ ifeq ($(MMOD),realview_pbx)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -126,7 +127,7 @@ endif
 ifeq ($(MMOD),zynq)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -139,7 +140,7 @@ ifeq ($(MMOD),raspberry_pi3)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -149,7 +150,7 @@ cortex_IMG_SUFFIX	:= .bin
 endif
 
 ifeq ($(MMOD),lm3s811)
-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -162,7 +163,7 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),emote3)
-cortex_EMULATOR		= 
+cortex_EMULATOR		=
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -175,25 +176,26 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),sifive_e)
-riscv_CC_FLAGS          := -Wl, -mno-relax
-riscv_AS_FLAGS          := 
+riscv_CC_FLAGS          := -Wl, -mno-relax -march='rv32g'
+riscv_AS_FLAGS          :=
 riscv_LD_FLAGS          := --no-relax
-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_EMULATOR			= qemu-system-riscv32 -d int -D INTS -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --nmagic
-riscv_CODE_NAME := .init
-riscv_DATA_NAME :=
+riscv_CODE_NAME 		:= .init
+riscv_DATA_NAME 		:= .sdata
 riscv_IMG_SUFFIX        := .img
 endif
 
 ifeq ($(MMOD),sifive_u)
 riscv_CC_FLAGS          := -mcmodel=medany
-riscv_AS_FLAGS          := 
-riscv_LD_FLAGS          := 
-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_AS_FLAGS          :=
+riscv_LD_FLAGS          :=
+riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --omagic
 riscv_CODE_NAME := .init
 riscv_DATA_NAME :=
@@ -212,13 +214,13 @@ atmega_DATA_NAME	:= .data
 atmega_IMG_SUFFIX	:= .hex
 
 MACH_CC_FLAGS           := $($(MACH)_CC_FLAGS) -O -nostdinc -fno-stack-protector -fno-pie -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-address-of-packed-member
-MACH_CXX_FLAGS          := $($(MACH)_CC_FLAGS) -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit --no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-attribute-alias -Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member
+MACH_CXX_FLAGS          := $($(MACH)_CC_FLAGS) -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit --no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-attribute-alias -Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member -Wattributes
 MACH_AS_FLAGS           := $($(MACH)_AS_FLAGS)
 MACH_LD_FLAGS           := $($(MACH)_LD_FLAGS)
 MACH_CODE_NAME          := $($(MACH)_CODE_NAME)
 MACH_DATA_NAME          := $($(MACH)_DATA_NAME)
-MACH_EMULATOR           := $($(MACH)_EMULATOR)
-MACH_DEBUGGER           := $(TERM) $($(MACH)_DEBUGGER) -ex "target remote:1235" -ex "set confirm off"
+MACH_EMULATOR           := $(TERM) $($(MACH)_EMULATOR)
+MACH_DEBUGGER           := $(TERM) $($(MACH)_DEBUGGER) -ex "target remote:1236" -ex "set confirm off"
 MACH_FLASHER            := $($(MACH)_FLASHER)
 MACH_MAGIC              := $($(MACH)_MAGIC)
 MACH_IMGSUFF            := $($(MACH)_IMG_SUFFIX)
@@ -227,7 +229,7 @@ ifeq ($(DEBUG),1)
 MACH_CC_FLAGS		:= -g -feliminate-unused-debug-symbols $(MACH_CC_FLAGS)
 MACH_CXX_FLAGS          := -g -feliminate-unused-debug-symbols $(MACH_CXX_FLAGS)
 MACH_AS_FLAGS		:= -g $(MACH_AS_FLAGS)
-MACH_EMULATOR           := $(subst -m ,-gdb tcp::1235 -S -m ,$(MACH_EMULATOR))
+MACH_EMULATOR           := $(subst -m ,-gdb tcp::1236 -S -m ,$(MACH_EMULATOR))
 endif
 
 # Architecture specifics
@@ -251,10 +253,10 @@ TLD		:= gcc
 TLDFLAGS	:= -m32
 
 # Tools and flags to compile applications
-ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
@@ -306,7 +308,7 @@ OBJDUMPFLAGS	:=
 
 SHELL		:= bash
 
-STRIP		= $(COMP_PREFIX)strip -R .note -R .comment
+STRIP		= $(COMP_PREFIX)strip -R .note -R .comment --strip-debug
 
 TCPDUMP		:= tcpdump -tttttennvvvXXr
 
@@ -315,7 +317,7 @@ TEE		:= tee
 ifndef DISPLAY
 TERM        := sh -c
 else
-TERM        := xterm -e
+TERM        := konsole -e
 endif
 
 TOUCH		:= touch
@@ -360,8 +362,11 @@ lib%.o: lib%.cc
 (%.o): %.o
 		$(AR) $(ARFLAGS) $@ $^
 
+# %.img: %
+# 		$(MKBI) $@ $<
+
 %.img: %
-		$(MKBI) $@ $<
+		$(MKBI) $@  philosophers_dinner hello_usr
 
 %.hex: %
 		$(OBJCOPY) -I elf32-$(ARCH_ENDIANESS) -O ihex $< $<.tmp
diff --git a/makefile b/makefile
index a35fe1f..2a8e03b 100644
--- a/makefile
+++ b/makefile
@@ -2,7 +2,16 @@
 
 include makedefs
 
+ifndef APPS
 SUBDIRS	:= etc tools src app img
+else
+SUBDIRS := etc tools src
+export APPS
+ifndef APPLICATION
+export APPLICATION=$(word 1, $(APPS))
+endif
+endif
+
 
 all: FORCE
 ifndef APPLICATION
@@ -12,6 +21,9 @@ else
 endif
 
 all1: $(SUBDIRS)
+ifdef APPS
+	$(foreach app,$(APPS), (cd $(APP) && $(MAKE) APPLICATION=$(app));)
+endif
 
 $(SUBDIRS): FORCE
 		(cd $@ && $(MAKE))
@@ -23,6 +35,7 @@ else
 		$(MAKE) run1
 endif
 
+#!P2: needs fix
 run1: etc img/$(APPLICATION)$(MACH_IMGSUFF)
 		(cd img && $(MAKE) run1)
 		
@@ -36,7 +49,8 @@ else
 		$(MAKE) DEBUG=1 all1 debug1
 endif
 
-debug1: etc img/$(APPLICATION)$(MACH_IMGSUFF)
+debug1: FORCE
+		(cd img && $(MKBI) $(word 1, $(APPS)).img $(addprefix $(IMG)/,$(APPS)))
 		(cd img && $(MAKE) DEBUG=1 debug)
 
 flash: FORCE
diff --git a/src/api/alarm.cc b/src/api/alarm.cc
index 3352a3a..f01ee94 100644
--- a/src/api/alarm.cc
+++ b/src/api/alarm.cc
@@ -25,6 +25,7 @@ Alarm::Alarm(const Microsecond & time, Handler * handler, unsigned int times)
         _request.insert(&_link);
         unlock();
     } else {
+        assert(times == 1);
         unlock();
         (*handler)();
     }
@@ -120,6 +121,7 @@ void Alarm::handler(IC::Interrupt_Id i)
     }
 
     unlock();
+    // kout << "*";
 
     if(alarm) {
         db<Alarm>(TRC) << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
new file mode 100644
index 0000000..c0e3513
--- /dev/null
+++ b/src/api/scheduler.cc
@@ -0,0 +1,36 @@
+// EPOS CPU Scheduler Component Implementation
+
+#include <process.h>
+#include <time.h>
+
+__BEGIN_SYS
+
+// The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
+template <typename ... Tn>
+FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
+
+EDF::EDF(const Microsecond & d, const Microsecond & p, const Microsecond & c, unsigned int): Real_Time_Scheduler_Common(Alarm::ticks(d), Alarm::ticks(d), p, c) {}
+
+void EDF::update() {
+    if((_priority >= PERIODIC) && (_priority < APERIODIC))
+        _priority = Alarm::elapsed() + _deadline;
+}
+
+// Since the definition of FCFS above is only known to this unit, forcing its instantiation here so it gets emitted in scheduler.o for subsequent linking with other units is necessary.
+template FCFS::FCFS<>(int p);
+
+//!SMODE:
+template <typename ... Tn>
+RM::RM(const Microsecond & period, int priority, Tn & ... an) {
+    if(priority == HIGH) {
+        _priority = HIGH + Alarm::ticks(period);
+    }else {
+        _priority = priority;
+    }
+
+     db<Init>(TRC) << "_priority=" << _priority << endl;
+}
+
+template RM::RM<>(const Microsecond & period, int priority);
+
+__END_SYS
diff --git a/src/api/segment.cc b/src/api/segment.cc
index 9ae9b96..8ef60ff 100644
--- a/src/api/segment.cc
+++ b/src/api/segment.cc
@@ -5,19 +5,25 @@
 __BEGIN_SYS
 
 // Methods
-Segment::Segment(unsigned int bytes, const Color & color, const Flags & flags): Chunk(bytes, flags, color)
+Segment::Segment(unsigned int bytes, const Flags & flags): Chunk(bytes, flags)
 {
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",color=" << color << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
 }
 
 
-Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags | Flags::IO)
-// The MMU::IO flag signalizes the MMU that the attached memory shall
-// not be released when the chunk is deleted
-{
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
-}
+// Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags | Flags::IO)
+// // The MMU::IO flag signalizes the MMU that the attached memory shall
+// // not be released when the chunk is deleted
+// {
+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+// }
 
+// Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags)
+// // The MMU::IO flag signalizes the MMU that the attached memory shall
+// // not be released when the chunk is deleted
+// {
+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+// }
 
 Segment::~Segment()
 {
@@ -31,10 +37,10 @@ unsigned int Segment::size() const
 }
 
 
-Segment::Phy_Addr Segment::phy_address() const
-{
-    return Chunk::phy_address();
-}
+// Segment::Phy_Addr Segment::phy_address() const
+// {
+//     return Chunk::phy_address();
+// }
 
 
 int Segment::resize(int amount)
diff --git a/src/api/thread.cc b/src/api/thread.cc
index fdd0583..0813c90 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -11,20 +11,19 @@ __END_UTIL
 
 __BEGIN_SYS
 
-extern "C" { void __epos_app_entry(); }
-
 volatile unsigned int Thread::_thread_count;
+volatile Task * Task::_active;
 Scheduler_Timer * Thread::_timer;
+Scheduler<Thread> Thread::_scheduler;
 
-Thread* volatile Thread::_running;
-Thread::Queue Thread::_ready;
-Thread::Queue Thread::_suspended;
 
 void Thread::constructor_prologue(unsigned int stack_size)
 {
     lock();
-
+    
+    _task = Task::_active;
     _thread_count++;
+    _scheduler.insert(this);
 
     _stack = new (SYSTEM) char[stack_size];
 }
@@ -42,13 +41,8 @@ void Thread::constructor_epilogue(const Log_Addr & entry, unsigned int stack_siz
 
     assert((_state != WAITING) && (_state != FINISHING)); // Invalid states
 
-    switch(_state) {
-        case RUNNING: assert(entry == __epos_app_entry); break;
-        case READY: _ready.insert(&_link); break;
-        case SUSPENDED: _suspended.insert(&_link); break;
-        case WAITING: break;   // invalid state, for switch completion only
-        case FINISHING: break; // invalid state, for switch completion only
-    }
+    if((_state != READY) && (_state != RUNNING))
+        _scheduler.suspend(this);
 
     if(preemptive && (_state == READY) && (_link.rank() != IDLE))
         reschedule();
@@ -76,15 +70,18 @@ Thread::~Thread()
         exit(-1);
         break;
     case READY:
-        _ready.remove(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case SUSPENDED:
-        _suspended.remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case WAITING:
         _waiting->remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case FINISHING: // Already called exit()
@@ -100,6 +97,26 @@ Thread::~Thread()
 }
 
 
+void Thread::priority(const Priority & c)
+{
+    lock();
+
+    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+
+    _link.rank(Criterion(c));
+
+    if(_state != RUNNING) { // reorder the scheduling queue
+        _scheduler.remove(this);
+        _scheduler.insert(this);
+    }
+
+    if(preemptive)
+        reschedule();
+
+    unlock();
+}
+
+
 int Thread::join()
 {
     lock();
@@ -113,10 +130,18 @@ int Thread::join()
     assert(!_joining);
 
     if(_state != FINISHING) {
-        _joining = running();
-        _joining->suspend(true);
-    } else
-        unlock();
+        Thread * prev = running();
+
+        _joining = prev;
+        prev->_state = SUSPENDED;
+        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+
+        Thread * next = _scheduler.chosen();
+
+        dispatch(prev, next);
+    }
+
+    unlock();
 
     return *reinterpret_cast<int *>(_stack);
 }
@@ -128,56 +153,48 @@ void Thread::pass()
 
     db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
-
-    _ready.remove(this);
-    _state = RUNNING;
-    _running = this;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose(this);
 
-    dispatch(prev, this);
+    if(next)
+        dispatch(prev, next, false);
+    else
+        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
 
     unlock();
 }
 
 
-void Thread::suspend(bool locked)
+void Thread::suspend()
 {
-    if(!locked)
-        lock();
+    lock();
 
     db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    if(_running != this)
-        _ready.remove(this);
+    Thread * prev = running();
 
     _state = SUSPENDED;
-    _suspended.insert(&_link);
+    _scheduler.suspend(this);
 
-    if(_running == this) {
-        _running = _ready.remove()->object();
-        _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-        dispatch(this, _running);
-    }
+    dispatch(prev, next);
 
     unlock();
 }
 
 
-void Thread::resume(bool unpreemptive)
+void Thread::resume()
 {
     lock();
 
     db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
 
     if(_state == SUSPENDED) {
-        _suspended.remove(this);
         _state = READY;
-        _ready.insert(&_link);
+        _scheduler.resume(this);
 
-        if(preemptive && !unpreemptive)
+        if(preemptive)
             reschedule();
     } else
         db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
@@ -191,16 +208,12 @@ void Thread::yield()
 {
     lock();
 
-    db<Thread>(TRC) << "Thread::yield(running=" << _running << ")" << endl;
-
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
+    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose_another();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -212,23 +225,22 @@ void Thread::exit(int status)
 
     db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    Thread * prev = _running;
+    Thread * prev = running();
+    _scheduler.remove(prev);
     prev->_state = FINISHING;
     *reinterpret_cast<int *>(prev->_stack) = status;
 
     _thread_count--;
 
     if(prev->_joining) {
-        Thread * joining = prev->_joining;
+        prev->_joining->_state = READY;
+        _scheduler.resume(prev->_joining);
         prev->_joining = 0;
-        joining->resume(true);
-        lock();
     }
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.choose(); // at least idle will always be there
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -241,14 +253,14 @@ void Thread::sleep(Queue * q)
     assert(locked()); // locking handled by caller
 
     Thread * prev = running();
+    _scheduler.suspend(prev);
     prev->_state = WAITING;
     prev->_waiting = q;
     q->insert(&prev->_link);
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 }
 
 
@@ -262,7 +274,7 @@ void Thread::wakeup(Queue * q)
         Thread * t = q->remove()->object();
         t->_state = READY;
         t->_waiting = 0;
-        _ready.insert(&t->_link);
+        _scheduler.resume(t);
 
         if(preemptive)
             reschedule();
@@ -281,7 +293,7 @@ void Thread::wakeup_all(Queue * q)
             Thread * t = q->remove()->object();
             t->_state = READY;
             t->_waiting = 0;
-            _ready.insert(&t->_link);
+            _scheduler.resume(t);
         }
 
         if(preemptive)
@@ -292,25 +304,47 @@ void Thread::wakeup_all(Queue * q)
 
 void Thread::reschedule()
 {
-    yield();
-}
+    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
+        db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
+    assert(locked()); // locking handled by caller
+
+    Thread * prev = running();
+    Thread * next = _scheduler.choose();
+
+    dispatch(prev, next);
+}
 
 void Thread::time_slicer(IC::Interrupt_Id i)
 {
+    lock();
     reschedule();
+    unlock();
 }
 
 
-void Thread::dispatch(Thread * prev, Thread * next)
+void Thread::dispatch(Thread * prev, Thread * next, bool charge)
 {
+    // "next" is not in the scheduler's queue anymore. It's already "chosen"
+
+    if(charge) {
+        if(Criterion::timed)
+            _timer->restart();
+    }
+
     if(prev != next) {
-        assert(prev->_state != RUNNING);
-        assert(next->_state == RUNNING);
+        if(prev->_state == RUNNING)
+            prev->_state = READY;
+        next->_state = RUNNING;
 
         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
         db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
         db<Thread>(INF) << "next={" << next << ",ctx=" << *next->_context << "}" << endl;
+        
+        
+        if(prev->_task != next->_task){
+            Task::activate(next->_task);
+        }
 
         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
         // and necessary because of context switches, but here, we are locked() and
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index db05478..7ce6e89 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -1,9 +1,13 @@
 // EPOS Thread Initialization
 
+#include <utility/elf.h>
+#include <architecture/mmu.h>
 #include <machine/timer.h>
 #include <machine/ic.h>
 #include <system.h>
 #include <process.h>
+#include <memory.h>
+
 
 __BEGIN_SYS
 
@@ -12,12 +16,42 @@ extern "C" { void __epos_app_entry(); }
 void Thread::init()
 {
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
-
-    // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
-    // which will directly call main(). In this case, _init will have already been called,
-    // before Init_Application to construct MAIN's global objects.
-    Thread::_running = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
-
+    typedef int (Main)();
+    System_Info * si = System::info();
+    
+    if(Traits<System>::multitask) {
+        char * bi = reinterpret_cast<char*>(Memory_Map::MEM_BASE);
+        
+        for(unsigned i = 0; i < si->bm.n_apps; i++) {
+             // We need W permission to load the segment
+            Segment * code_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL);
+            Segment * data_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL);
+            Task * app_task =  new (SYSTEM) Task(code_seg, data_seg);
+            
+            db<Setup>(TRC) << "app_task = " << hex << app_task << endl;
+            Task::activate(app_task);
+            
+            if(si->lm.has_app) {
+                ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
+                db<Setup>(TRC) << "Setup_SifiveE::load_app()" << endl;
+                if(app_elf->load_segment(0) < 0) {
+                    db<Setup>(ERR) << "Application code segment was corrupted during INIT!" << endl;
+                    Machine::panic();
+                }
+                for(int i = 1; i < app_elf->segments(); i++)
+                    if(app_elf->load_segment(i) < 0) {
+                        db<Setup>(ERR) << "Application data segment was corrupted during INIT!" << endl;
+                        Machine::panic();
+                    }
+            }
+            
+            new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<Main *>(si->lm.app[i].app_entry));
+        }
+        
+        // We need to be in the AS of the first thread.
+        Task::activate(Thread::self()->_task);
+    }
+   
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
 
@@ -27,7 +61,7 @@ void Thread::init()
     // Letting reschedule() happen during thread creation is also harmless, since MAIN is
     // created first and dispatch won't replace it nor by itself neither by IDLE (which
     // has a lower priority)
-    if(preemptive)
+    if(Criterion::timed)
         _timer = new (SYSTEM) Scheduler_Timer(QUANTUM, time_slicer);
 
     // No more interrupts until we reach init_first
diff --git a/src/architecture/armv7/armv7_crtend.c b/src/architecture/armv7/armv7_crtend.c
index 84ae9b3..78a6b11 100644
--- a/src/architecture/armv7/armv7_crtend.c
+++ b/src/architecture/armv7/armv7_crtend.c
@@ -16,5 +16,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/ia32/ia32_crtend.c b/src/architecture/ia32/ia32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/ia32/ia32_crtend.c
+++ b/src/architecture/ia32/ia32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_cpu.cc b/src/architecture/rv32/rv32_cpu.cc
index 2e5830e..7773356 100644
--- a/src/architecture/rv32/rv32_cpu.cc
+++ b/src/architecture/rv32/rv32_cpu.cc
@@ -12,8 +12,10 @@ unsigned int CPU::_bus_clock;
 // Class methods
 void CPU::Context::save() volatile
 {
-    ASM("       la       x4,      pc            \n"
-        "       sw       x4, -116(sp)           \n"     // push pc
+    ASM("       csrr     gp,  sstatus           \n"
+        "       sw       gp, -120(sp)           \n"     // push sstatus
+        "       auipc    gp, 0                  \n" 
+        "       sw       gp, -116(sp)           \n"     // push pc
         "       sw       x1, -112(sp)           \n"     // push ra
         "       sw       x5, -108(sp)           \n"     // push x5-x31
         "       sw       x6, -104(sp)           \n"
@@ -43,17 +45,18 @@ void CPU::Context::save() volatile
         "       sw      x30,   -8(sp)           \n"
         "       sw      x31,   -4(sp)           \n");
 
-    ASM("       addi     sp, sp, -116           \n"                     // complete the pushes above by adjusting the SP
+    ASM("       addi     sp, sp, -120           \n"                     // complete the pushes above by adjusting the SP
         "       sw       sp, 0(%0)              \n" : : "r"(this));     // update the this pointer to match the context saved on the stack
 }
 
+// Context load does not verify if interrupts were previously enabled by the Context's constructor
+// We are setting sstatus to SPP_S | SPIE, therefore, interrupts will be enabled only after sret
 void CPU::Context::load() const volatile
 {
     ASM("       mv      sp, %0                  \n"                     // load the stack pointer with the this pointer
-        "       addi    sp, sp, 116             \n" : : "r"(this));     // adjust the stack pointer to match the subsequent series of pops
+        "       addi    sp, sp, 120             \n" : : "r"(this));     // adjust the stack pointer to match the subsequent series of pops
 
-    ASM("       lw       x4, -116(sp)           \n"     // pop pc
-        "       lw       x1, -112(sp)           \n"     // pop ra
+    ASM("       lw       x1, -112(sp)           \n"     // pop ra
         "       lw       x5, -108(sp)           \n"     // pop x5-x31
         "       lw       x6, -104(sp)           \n"
         "       lw       x7, -100(sp)           \n"
@@ -81,14 +84,20 @@ void CPU::Context::load() const volatile
         "       lw      x29,  -12(sp)           \n"
         "       lw      x30,   -8(sp)           \n"
         "       lw      x31,   -4(sp)           \n"
-        "       jalr     x0,     (x4)           \n");   // jump to pc stored in x4 (jalr with x0 is equivalent to jr)
+        "       lw       gp, -120(sp)           \n"     // pop sstatus
+        "       csrs    sstatus,   gp           \n"     // set sstatus for sret
+        "       lw       gp, -116(sp)           \n"     // pop pc
+        "       csrw     sepc,     gp           \n"     // move pc to sepc for sret
+        "       sret                            \n");
 }
 
+// NOTE:
+// during the first time switch context is called for a thread, the stack may be dirty
+// what will set the registers with random values, is this a problem?
 void CPU::switch_context(Context ** o, Context * n)
 {   
     // Push the context into the stack and update "o"
-    ASM("       la       x4,    .ret            \n"     // get the return address in a temporary
-        "       sw       x4, -116(sp)           \n"     // push the return address as pc
+    ASM("       sw       x1, -116(sp)           \n"     // push the return address as pc
         "       sw       x1, -112(sp)           \n"     // push ra
         "       sw       x5, -108(sp)           \n"     // push x5-x31
         "       sw       x6, -104(sp)           \n"
@@ -117,13 +126,18 @@ void CPU::switch_context(Context ** o, Context * n)
         "       sw      x29,  -12(sp)           \n"
         "       sw      x30,   -8(sp)           \n"
         "       sw      x31,   -4(sp)           \n"
-        "       addi     sp,      sp,   -116    \n"     // complete the pushes above by adjusting the SP
+        "       csrr    x31,  sstatus           \n"     // get mstatus
+        "       sw      x31, -120(sp)           \n"     // push sstatus
+        "       addi     sp,      sp,   -120    \n"     // complete the pushes above by adjusting the SP
         "       sw       sp,    0(a0)           \n");   // update Context * volatile * o
+        
+    
 
     // Set the stack pointer to "n" and pop the context from the stack
     ASM("       mv       sp,      a1            \n"     // get Context * volatile n into SP
-        "       addi     sp,      sp,    116    \n"     // adjust stack pointer as part of the subsequent pops
-        "       lw       x4, -116(sp)           \n"     // pop pc to a temporary
+        "       addi     sp,      sp,    120    \n"     // adjust stack pointer as part of the subsequent pops
+        "       lw      x31, -116(sp)           \n"     // pop pc to a temporary
+        "       csrw    sepc, x31               \n"
         "       lw       x1, -112(sp)           \n"     // pop ra
         "       lw       x5, -108(sp)           \n"     // pop x5-x31
         "       lw       x6, -104(sp)           \n"
@@ -150,10 +164,15 @@ void CPU::switch_context(Context ** o, Context * n)
         "       lw      x27,  -20(sp)           \n"
         "       lw      x28,  -16(sp)           \n"
         "       lw      x29,  -12(sp)           \n"
+        "       lw      x31, -120(sp)           \n"     // pop sstatus
+        // As we are not handling an interrupt, we need to manually configure SPP_S to avoid
+        // going to user mode.
+        "       li      x30, 0b1 << 8           \n"
+        "       or      x31, x31, x30           \n"   
+        "       csrw     sstatus, x31           \n"
         "       lw      x30,   -8(sp)           \n"
         "       lw      x31,   -4(sp)           \n"
-        "       jalr     x0,     (x4)           \n"     // return (for the thread entering the CPU)
-        ".ret:  jalr     x0,     (x1)           \n");   // return (for the thread leaving the CPU)
+        "       sret                            \n");
 }
 
 __END_SYS
diff --git a/src/architecture/rv32/rv32_crt0.S b/src/architecture/rv32/rv32_crt0.S
index 22159d3..3c53ac9 100644
--- a/src/architecture/rv32/rv32_crt0.S
+++ b/src/architecture/rv32/rv32_crt0.S
@@ -10,19 +10,6 @@
 _start:
         // Temporary stack(s) for INIT are created and configure by SETUP
 
-        // Only hart (core) 0 cleans cache
-        csrr    t0, mhartid
-        bnez    t0, 2f
-
-        // Set all bytes in the BSS section to zero.
-        la      a0, __bss_start
-        la      a1, _end
-        bgeu    a0, a1, 2f
-1:
-        sw      zero, (a0)
-        addi    a0, a0, 4
-        bltu    a0, a1, 1b
-2:
         // Call _init
         call      _init
 
diff --git a/src/architecture/rv32/rv32_crtend.c b/src/architecture/rv32/rv32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv32/rv32_crtend.c
+++ b/src/architecture/rv32/rv32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_mmu.cc b/src/architecture/rv32/rv32_mmu.cc
index 1008524..fa3a7d7 100644
--- a/src/architecture/rv32/rv32_mmu.cc
+++ b/src/architecture/rv32/rv32_mmu.cc
@@ -6,5 +6,6 @@ __BEGIN_SYS
 
 // Class attributes
 MMU::List MMU::_free;
+MMU::Page_Directory * MMU::_master;
 
 __END_SYS
diff --git a/src/architecture/rv32/rv32_mmu_init.cc b/src/architecture/rv32/rv32_mmu_init.cc
index 127200c..fcad04e 100644
--- a/src/architecture/rv32/rv32_mmu_init.cc
+++ b/src/architecture/rv32/rv32_mmu_init.cc
@@ -1,26 +1,30 @@
 // EPOS RISC-V 32 MMU Mediator Initialization
 
 #include <architecture/mmu.h>
-
-extern "C" void * _edata;
-extern "C" void * __bss_start;
-extern "C" void * _end;
+#include <system.h>
 
 __BEGIN_SYS
 
 void MMU::init()
 {
-    db<Init, MMU>(TRC) << "MMU::init()" << endl;
-
-    db<Init, MMU>(INF) << "MMU::init::dat.e=" << &_edata << ",bss.b=" << &__bss_start << ",bss.e=" << &_end << endl;
-
     // For machines that do not feature a real MMU, frame size = 1 byte
     // Allocations (using Grouping_List<Frame>::search_decrementing() start from the end
     // To preserve the BOOT stacks until the end of INIT, the free memory list initialization is split in two sections
     // with allocations (from the end) of the first section taking place first
-    free(&_end, pages(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS - reinterpret_cast<unsigned int>(&_end)));
+    db<Init, MMU>(TRC) << "MMU::init()" << endl;
+
+    System_Info * si = System::info();
+    unsigned sys_data_end = si->lm.sys_data + si->lm.sys_data_size + 1;
+    MMU::_master = reinterpret_cast<Page_Directory*>(Memory_Map::PAGE_TABLES);
+
+    db<Init, MMU>(TRC) << "sys_data= " << si->lm.sys_data << ", begin_free= " << sys_data_end << endl; 
+
+    // Worst-Fit guarantees this will work
+    free(align_page(sys_data_end), pages(Memory_Map::MMODE_F - align_page(sys_data_end))); // [align_page(&_end), 0x87bf9000]
     free(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS, pages(Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS));
+    
+    // Free init/setup memory
+    free(Memory_Map::MEM_BASE, pages(Memory_Map::SYS - Memory_Map::MEM_BASE));
 }
 
-__END_SYS
-
+__END_SYS
\ No newline at end of file
diff --git a/src/architecture/rv64/rv64_crtend.c b/src/architecture/rv64/rv64_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv64/rv64_crtend.c
+++ b/src/architecture/rv64/rv64_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/init/init_application.cc b/src/init/init_application.cc
index c3c4b15..52bb7f5 100644
--- a/src/init/init_application.cc
+++ b/src/init/init_application.cc
@@ -5,7 +5,7 @@
 #include <machine.h>
 #include <system.h>
 
-extern "C" { char _end; } // defined by GCC
+extern "C" char _end; // defined by GCC
 
 __BEGIN_SYS
 
@@ -22,13 +22,11 @@ public:
         // Initialize Application's heap
         db<Init>(INF) << "Initializing application's heap: " << endl;
         if(Traits<System>::multiheap) { // heap in data segment arranged by SETUP
-            char * heap = MMU::align_page(&_end);
-            if(Traits<Build>::MODE != Traits<Build>::KERNEL) // if not a kernel, then use the stack allocated by SETUP, otherwise make that part of the heap
-                heap += MMU::align_page(Traits<Application>::STACK_SIZE);
-            Application::_heap = new (&Application::_preheap[0]) Heap(heap, HEAP_SIZE);
-        } else
+            Application::_heap = new (&Application::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+        } else {
             for(unsigned int frames = MMU::allocable(); frames; frames = MMU::allocable())
                 System::_heap->free(MMU::alloc(frames), frames * sizeof(MMU::Page));
+        }
         db<Init>(INF) << "done!" << endl;
     }
 };
diff --git a/src/init/init_first.cc b/src/init/init_first.cc
index cef9299..ecbbe4a 100644
--- a/src/init/init_first.cc
+++ b/src/init/init_first.cc
@@ -18,13 +18,17 @@ public:
 
         db<Init>(INF) << "INIT ends here!" << endl;
 
-        db<Init, Thread>(INF) << "Dispatching the first thread: " << Thread::running() << endl;
+        // Thread::self() and Task::self() can be safely called after the construction of MAIN
+        // even if no reschedule() was called (running is set by the Scheduler at each insert())
+        Thread * first = Thread::self();
+
+        db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
 
         // Interrupts have been disable at Thread::init() and will be reenabled by CPU::Context::load()
         // but we first reset the timer to avoid getting a time interrupt during load()
-        Timer::reset();
-        CPU::int_enable();
-        Thread::running()->_context->load();
+        if (Traits<Timer>::enabled)
+            Timer::reset();
+        first->_context->load();
     }
 };
 
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index d3c373f..bc19699 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -6,6 +6,8 @@
 #include <system.h>
 #include <process.h>
 
+extern "C" void _int_entry();
+
 __BEGIN_SYS
 
 class Init_System
@@ -17,6 +19,8 @@ public:
     Init_System() {
         db<Init>(TRC) << "Init_System()" << endl;
 
+        Machine::pre_init(System::info());
+
         // Initialize the processor
         db<Init>(INF) << "Initializing the CPU: " << endl;
         CPU::init();
@@ -24,12 +28,7 @@ public:
 
         // Initialize System's heap
         db<Init>(INF) << "Initializing system's heap: " << endl;
-        if(Traits<System>::multiheap) {
-            Segment * tmp = reinterpret_cast<Segment *>(&System::_preheap[0]);
-            System::_heap_segment = new (tmp) Segment(HEAP_SIZE, WHITE, Segment::Flags::SYS);
-            System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
-        } else
-            System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+        System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
         db<Init>(INF) << "done!" << endl;
 
         // Initialize the machine
diff --git a/src/machine/riscv/riscv_ic.cc b/src/machine/riscv/riscv_ic.cc
index 96a53c3..35362cc 100644
--- a/src/machine/riscv/riscv_ic.cc
+++ b/src/machine/riscv/riscv_ic.cc
@@ -3,21 +3,21 @@
 #include <machine/machine.h>
 #include <machine/ic.h>
 
-extern "C" { void _int_entry() __attribute__ ((alias("_ZN4EPOS1S2IC5entryEv"))); }
-
 __BEGIN_SYS
 
+extern "C" { [[gnu::alias("_ZN4EPOS1S2IC5entryEv"), gnu::nothrow]] void _int_entry(); }
+
 // Class attributes
 IC::Interrupt_Handler IC::_int_vector[IC::INTS];
 
 // Class methods
 void IC::entry()
 {
-    // Handle interrupts in machine mode
+    // Handle interrupts in supervisor mode
     ASM("        .align 4                                               \n"
         "                                                               \n"
         "# Save context                                                 \n"
-        "        addi        sp,     sp,   -140                         \n"          // 32 regs of 4 bytes each = 128 Bytes
+        "        addi        sp,     sp,   -136                         \n"          // 32 regs of 4 bytes each = 128 Bytes
         "        sw          x1,   4(sp)                                \n"
         "        sw          x2,   8(sp)                                \n"
         "        sw          x3,  12(sp)                                \n"
@@ -49,12 +49,10 @@ void IC::entry()
         "        sw         x29, 116(sp)                                \n"
         "        sw         x30, 120(sp)                                \n"
         "        sw         x31, 124(sp)                                \n"
-        "        csrr       x31, mie                                    \n"
+        "        csrr       x31, sstatus                                \n"
         "        sw         x31, 128(sp)                                \n"
-        "        csrr       x31, mstatus                                \n"
+        "        csrr       x31, sepc                                   \n"
         "        sw         x31, 132(sp)                                \n"
-        "        csrr       x31, mepc                                   \n"
-        "        sw         x31, 136(sp)                                \n"
         "        la          ra, .restore                               \n" // Set LR to restore context before returning
         "        j          %0                                          \n"
         "                                                               \n"
@@ -90,15 +88,13 @@ void IC::entry()
         "        lw         x28, 112(sp)                                \n"
         "        lw         x29, 116(sp)                                \n"
         "        lw         x30, 120(sp)                                \n"
-        "        lw         x31, 124(sp)                                \n"
         "        lw         x31, 128(sp)                                \n"
-        "        csrs       mie, x31                                    \n"
+        "        csrw   sstatus, x31                                    \n"
         "        lw         x31, 132(sp)                                \n"
-        "        csrs   mstatus, x31                                    \n"
-        "        lw         x31, 136(sp)                                \n"
-        "        csrw      mepc, x31                                    \n"
-        "        addi        sp, sp,    140                             \n"
-        "        mret                                                   \n" : : "i"(&dispatch));
+        "        csrw      sepc, x31                                    \n"
+        "        lw         x31, 124(sp)                                \n"
+        "        addi        sp, sp,    136                             \n"
+        "        sret                                                   \n" : : "i"(&dispatch));
 }
 
 void IC::dispatch()
@@ -108,8 +104,8 @@ void IC::dispatch()
     if((id != INT_SYS_TIMER) || Traits<IC>::hysterically_debugged)
         db<IC>(TRC) << "IC::dispatch(i=" << id << ")" << endl;
 
-    if(id == INT_RESCHEDULER)
-        IC::ipi_eoi(id);
+    if(id == INT_SYS_TIMER)
+        CPU::sie_clear(CPU::STI);
 
     _int_vector[id](id);
 }
@@ -125,17 +121,13 @@ void IC::int_not(Interrupt_Id id)
 
 void IC::exception(Interrupt_Id id)
 {
-    CPU::Reg mstatus = CPU::mstatus();
-    CPU::Reg mcause = CPU::mcause();
+    CPU::Reg sstatus = CPU::sstatus();
+    CPU::Reg scause = CPU::scause();
     CPU::Reg mhartid = CPU::id();
-    CPU::Reg mepc;
-    ASM("csrr %0, mepc" : "=r"(mepc) : :);
     CPU::Reg sepc;
     ASM("csrr %0, sepc" : "=r"(sepc) : :);
-    CPU::Reg mtval;
-    ASM("csrr %0, mtval" : "=r"(mtval) : :);
 
-    db<IC>(WRN) << "IC::Exception(" << id << ") => {" << hex << "mstatus=" << mstatus << ",mcause=" << mcause << ",mhartid=" << mhartid << ",mepc=" << hex << mepc << ",sepc=" << sepc << ",mtval=" << mtval << "}" << dec;
+    db<IC>(WRN) << "IC::Exception(" << id << ") => {" << hex << "sstatus=" << sstatus << ",scause=" << scause << ",mhartid=" << mhartid << ",sepc=" << sepc  << "}" << dec;
 
     switch(id) {
         case 0: // unaligned Instruction
diff --git a/src/machine/riscv/riscv_ic_init.cc b/src/machine/riscv/riscv_ic_init.cc
index 8904a70..0422e41 100644
--- a/src/machine/riscv/riscv_ic_init.cc
+++ b/src/machine/riscv/riscv_ic_init.cc
@@ -4,6 +4,8 @@
 #include <machine/ic.h>
 #include <machine/timer.h>
 
+extern "C" void _int_entry();
+
 __BEGIN_SYS
 
 // Class methods
@@ -11,9 +13,9 @@ void IC::init()
 {
     db<Init, IC>(TRC) << "IC::init()" << endl;
 
-    CPU::int_disable(); // will be reenabled at Thread::init() by Context::load()
-
-    disable(); // will be enabled on demand as handlers are registered
+    // CPU::int_disable();
+    // Will be enabled on demand as handlers are registered
+    disable();
 
     // Set all exception handlers to exception()
     for(Interrupt_Id i = 0; i < CPU::EXCEPTIONS; i++)
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index 1e5be41..859442f 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -6,21 +6,8 @@ __BEGIN_SYS
 
 void Machine::pre_init(System_Info * si)
 {
-    if(CPU::id() == 0)
-        Display::init();
-
-    db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
-
-    if(CPU::id() == 0) {
-        if(Traits<IC>::enabled) {
-            IC::init();
-
-            // Wake up remaining CPUs
-            // si->bm.n_cpus = Traits<Build>::CPUS;
-            if(Traits<System>::multicore)
-                smp_barrier_init(Traits<Build>::CPUS);
-        }
-    }
+    CPU::stvec_write((unsigned)&IC::entry & 0xfffffffc);
+    IC::init();
 }
 
 void Machine::init()
diff --git a/src/machine/riscv/riscv_timer.cc b/src/machine/riscv/riscv_timer.cc
index 1773715..fa57b41 100644
--- a/src/machine/riscv/riscv_timer.cc
+++ b/src/machine/riscv/riscv_timer.cc
@@ -11,6 +11,7 @@ Timer * Timer::_channels[CHANNELS];
 // Class methods
 void Timer::int_handler(Interrupt_Id i)
 {
+    // kout << "ESTOU DE SACANAGEM" << endl;
     config(FREQUENCY);
     if(_channels[SCHEDULER] && (--_channels[SCHEDULER]->_current[CPU::id()] <= 0)) {
         _channels[SCHEDULER]->_current[CPU::id()] = _channels[SCHEDULER]->_initial;
diff --git a/src/machine/riscv/riscv_timer_init.cc b/src/machine/riscv/riscv_timer_init.cc
index 6013906..c634bc7 100644
--- a/src/machine/riscv/riscv_timer_init.cc
+++ b/src/machine/riscv/riscv_timer_init.cc
@@ -9,6 +9,7 @@ __BEGIN_SYS
 void Timer::init()
 {
     db<Init, Timer>(TRC) << "Timer::init()" << endl;
+    db<Init, Timer>(TRC) << "Time=" << CPU::rdtime() << endl;
 
     CPU::int_disable();
 
@@ -18,7 +19,7 @@ void Timer::init()
     config(FREQUENCY);
     IC::enable(IC::INT_SYS_TIMER);
 
-    CPU::int_enable();
+    // CPU::int_enable();
 
 }
 
diff --git a/src/setup/makefile b/src/setup/makefile
index b5ead57..fe0620a 100644
--- a/src/setup/makefile
+++ b/src/setup/makefile
@@ -7,10 +7,11 @@ TARGET := $(if $(shell find setup_$(MMOD)* 2> /dev/null), $(if $(SETUP_ADDR), in
 all:	$(TARGET)
 
 setup_$(MMOD):	setup_$(MMOD).o
-		$(LD) $(LDFLAGS) -L$(CCLIB) --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
+		$(LD) $(LDFLAGS) -L$(CCLIB) --trace --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
 
 install:	setup_$(MMOD)
-		$(INSTALL) $< $(IMG)
+		$(OBJCOPY) $< $<_raw -O binary
+		mv $<_raw $(IMG)/$<
 
 install.o:	setup_$(MMOD).o
 		$(INSTALL) $< $(LIB)
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index 67287a6..369f5e9 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -1,74 +1,400 @@
 // EPOS RISC-V sifive SETUP
 
-#include <system/config.h>
+#include <utility/ostream.h>
+#include <utility/elf.h>
+#include <utility/debug.h>
+#include <system/info.h>
+#include <architecture.h>
+#include <machine.h>
 
-extern "C" { void _setup() __attribute__ ((used, naked, section(".init"))); }
+using namespace EPOS::S;
+typedef unsigned int Reg;
 
-// Interrupt Vector Table
-void _setup()
+extern "C"
 {
-    ASM("\t\n\
-        j       .reset                                                          \t\n\
-                                                                                \t\n\
-.reset:                                                                         \t\n\
-        # Disable interrupts                                                    \t\n\
-        csrs    mstatus, 1 << 3                                                 \t\n\
-                                                                                \t\n\
-        # Disable paging                                                        \t\n\
-        csrw    sptbr, zero                                                     \t\n\
-                                                                                \t\n\
-        # Put CLINT in direct mode (mtvec.mode = 0) and set mtvec to _int_entry \t\n\
-        la      t0, _int_entry                                                  \t\n\
-        andi    t0, t0, 0xfffffffe  # mtvec.mode = 0                            \t\n\
-        csrw    mtvec, t0                                                       \t\n\
-                                                                                \t\n\
-        # Get the hart's id                                                     \t\n\
-        csrr    a0, mhartid                                                     \t\n\
-                                                                                \t\n\
-        # Set a 16KB stack for each hart (#0 at __boot_stack__)                 \t\n\
-        la      sp, __boot_stack__                                              \t\n\
-        li      t0, 1                                                           \t\n\
-        slli    t0, t0, 14                                                      \t\n\
-        mul     t0, t0, a0                                                      \t\n\
-        sub     sp, sp, t0                                                      \t\n\
-                                                                                \t\n\
-        # Non-bootstrapping harts wait for an IPI                               \t\n\
-        bnez    a0, .secondary                                                  \t\n\
-                                                                                \t\n\
-        # Set mstatus to machine mode with interrupts disabled                  \t\n\
-        # 0b11 << 11: Machine's previous protection mode is 3 (MPP=3)           \t\n\
-        #    1 <<  7: Machine's previous interrupt-enable bit is 1 (MPIE=1)     \t\n\
-        li      t0, (0b11 << 11) | (1 << 7)                                     \t\n\
-        csrw    mstatus, t0                                                     \t\n\
-                                                                                \t\n\
-        # Set mepc to `_start` (will be used by mret)                           \t\n\
-        la      t0, _start                                                      \t\n\
-        csrw    mepc, t0                                                        \t\n\
-                                                                                \t\n\
-        # Go to _start and update mstatus accordingly by returning to mepc      \t\n\
-        mret                                                                    \t\n\
-                                                                                \t\n\
-.secondary:                                                                     \t\n\
-        # Set mstatus to machine mode with interrupts enabled                   \t\n\
-        # 0b11 << 11: Machine's previous protection mode is 3 (MPP=3)           \t\n\
-        #    1 <<  7: Machine's previous interrupt-enable bit is 1 (MPIE=1)     \t\n\
-        #    1 <<  3: Machine's interrupt-enable bit is 1 (MIE=1)               \t\n\
-        li      t0, (0b11 << 11) | (1 << 7) | (1 << 3)                          \t\n\
-        csrw    mstatus, t0                                                     \t\n\
-                                                                                \t\n\
-        # Enable software interrupts so hart #0 can latter wake up this hart    \t\n\
-        li      t0, (1 << 3) | (1 << 7) | (1 << 11)                             \t\n\
-        csrw    mie, t0                                                         \t\n\
-                                                                                \t\n\
-        # Set mepc to `_wait` (will be used by mret)                            \t\n\
-        la  t0, .wait                                                           \t\n\
-        csrw mepc, t0                                                           \t\n\
-                                                                                \t\n\
-        # Go to _wait and update mstatus accordingly by returning to mepc       \t\n\
-        mret                                                                    \t\n\
-                                                                                \t\n\
-.wait:                                                                          \t\n\
-        wfi                                                                     \t\n\
-        j _start                                                                \t\n\
-        ");
+    [[gnu::naked, gnu::section(".init")]] void _setup();
+    void _print(const char * s) { Display::puts(s); }
+    void _panic() { Machine::panic(); }
 }
+
+char placeholder[sizeof(System_Info)] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+System_Info * si;
+
+extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+    Reg id = CPU::mcause();
+    if((id & IC::INT_MASK) == CLINT::IRQ_MAC_TIMER) {
+        Timer::reset();
+        CPU::sie(CPU::STI);
+    }
+    Reg interrupt_id = 1 << ((id & IC::INT_MASK) - 2);
+    if(CPU::int_enabled() && (CPU::sie() & (interrupt_id)))
+        CPU::mip(interrupt_id);
+}
+
+__BEGIN_SYS
+EPOS::S::U::OStream kout, kerr;
+char * bi;
+
+class Setup_SifiveE {
+private:
+    // Physical memory map
+    static const unsigned int SYS_INFO = Memory_Map::SYS_INFO;
+    static const unsigned int PAGE_TABLES = Memory_Map::PAGE_TABLES;
+    static const unsigned int MMODE_F = Memory_Map::MMODE_F;
+    static const unsigned int MEM_BASE = Memory_Map::MEM_BASE;
+    static const unsigned int MEM_TOP = Memory_Map::MEM_TOP;
+    
+    typedef CPU::Reg Reg;
+    typedef MMU::RV32_Flags RV32_Flags;
+    typedef MMU::Page Page;
+    typedef MMU::Page_Table Page_Table;
+    typedef MMU::Page_Directory Page_Directory;
+    typedef MMU::PT_Entry PT_Entry;
+
+public:
+    static void init() { setup_machine_environment(); }
+    static void setup_machine_environment();
+    static void setup_supervisor_environment();
+    static void build_page_tables();
+    static void clean_bss();
+    static void build_lm();
+    static void load_parts();
+};
+
+void Setup_SifiveE::load_parts()
+{
+    // Relocate System_Info
+    if(sizeof(System_Info) > sizeof(Page)) {
+        db<Setup>(ERR) << "System_Info is bigger than a page (" << sizeof(System_Info) << ")!" << endl;
+        _panic();
+    }
+    memcpy(reinterpret_cast<void *>(SYS_INFO), si, sizeof(System_Info));
+    
+    // Load INIT
+    ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+    ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+    
+    if(si->lm.has_ini) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_init()" << endl;
+        if(ini_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "INIT code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        
+        for(int i = 1; i < ini_elf->segments(); i++)
+            if(ini_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "INIT data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    
+    if((long unsigned int)ini_elf->segment_size(0) > sys_elf->segment_address(0) - ini_elf->segment_address(0)) {
+        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "init has " << hex << sys_elf->segment_address(0) - ini_elf->segment_address(0) - ini_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    // Load SYSTEM
+    if(si->lm.has_sys) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_system()" << endl;
+        if(sys_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "system code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        for(int i = 1; i < sys_elf->segments(); i++)
+            if(sys_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "system data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    
+    if((long unsigned int)sys_elf->segment_size(0) > sys_elf->segment_address(1) - sys_elf->segment_address(0)) {
+        db<Setup>(ERR) << "sys code is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "sys code has " << hex << sys_elf->segment_address(1) - sys_elf->segment_address(0) - sys_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    if((long unsigned int)ini_elf->segment_size(1) > sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1)) {
+        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "sys data has " << hex << sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1) - ini_elf->segment_size(1) << " unused bytes of memory" << endl;
+}
+
+
+void Setup_SifiveE::build_lm()
+{
+    // Get boot image structure
+    si->lm.has_stp = (si->bm.setup_offset != -1u);
+    si->lm.has_ini = (si->bm.init_offset != -1u);
+    si->lm.has_sys = (si->bm.system_offset != -1u);
+    si->lm.has_app = (si->bm.application_offset[0] != -1u);
+    si->lm.has_ext = (si->bm.extras_offset != -1u);
+
+    // Check SETUP integrity and get the size of its segments
+    si->lm.stp_entry = 0;
+    si->lm.stp_segments = 0;
+    si->lm.stp_code = ~0U;
+    si->lm.stp_code_size = 0;
+    si->lm.stp_data = ~0U;
+    si->lm.stp_data_size = 0;
+
+    bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE); // bi is loaded at MEM_BASE
+    if(si->lm.has_stp) {
+        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
+        if(!stp_elf->valid()) {
+            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.stp_entry = stp_elf->entry();
+        si->lm.stp_segments = stp_elf->segments();
+        si->lm.stp_code = stp_elf->segment_address(0);
+        si->lm.stp_code_size = stp_elf->segment_size(0);
+        if(stp_elf->segments() > 1) {
+            for(int i = 1; i < stp_elf->segments(); i++) {
+                if(stp_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(stp_elf->segment_address(i) < si->lm.stp_data)
+                    si->lm.stp_data = stp_elf->segment_address(i);
+                si->lm.stp_data_size += stp_elf->segment_size(i);
+            }
+        }
+    }
+
+    // Check INIT integrity and get the size of its segments
+    si->lm.ini_entry = 0;
+    si->lm.ini_segments = 0;
+    si->lm.ini_code = ~0U;
+    si->lm.ini_code_size = 0;
+    si->lm.ini_data = ~0U;
+    si->lm.ini_data_size = 0;
+    if(si->lm.has_ini) {
+        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+        if(!ini_elf->valid()) {
+            db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.ini_entry = ini_elf->entry();
+        si->lm.ini_segments = ini_elf->segments();
+        si->lm.ini_code = ini_elf->segment_address(0);
+        si->lm.ini_code_size = ini_elf->segment_size(0);
+        if(ini_elf->segments() > 1) {
+            for(int i = 1; i < ini_elf->segments(); i++) {
+                if(ini_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(ini_elf->segment_address(i) < si->lm.ini_data)
+                    si->lm.ini_data = ini_elf->segment_address(i);
+                si->lm.ini_data_size += ini_elf->segment_size(i);
+            }
+        }
+    }
+
+    // Check SYSTEM integrity and get the size of its segments
+    si->lm.sys_entry = 0;
+    si->lm.sys_segments = 0;
+    si->lm.sys_code = ~0U;
+    si->lm.sys_code_size = 0;
+    si->lm.sys_data = ~0U;
+    si->lm.sys_data_size = 0;
+    // si->lm.sys_stack = SYS_STACK;
+    // si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
+    if(si->lm.has_sys) {
+        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+        if(!sys_elf->valid()) {
+            db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.sys_entry = sys_elf->entry();
+        si->lm.sys_segments = sys_elf->segments();
+        si->lm.sys_code = sys_elf->segment_address(0);
+        si->lm.sys_code_size = sys_elf->segment_size(0);
+        if(sys_elf->segments() > 1) {
+            for(int i = 1; i < sys_elf->segments(); i++) {
+                if(sys_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(sys_elf->segment_address(i) < si->lm.sys_data)
+                    si->lm.sys_data = sys_elf->segment_address(i);
+                si->lm.sys_data_size += sys_elf->segment_size(i);
+            }
+        }
+
+        // if(si->lm.sys_code != SYS_CODE) {
+        //     db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
+        //     db<Setup>(ERR) << "OS code segment is too large!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_data != SYS_DATA) {
+        //     db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack) {
+        //     db<Setup>(ERR) << "OS data segment is too large!" << endl;
+        //     panic();
+        // }
+        // if(MMU::page_tables(MMU::pages(si->lm.sys_stack - SYS + si->lm.sys_stack_size)) > 1) {
+        //     db<Setup>(ERR) << "OS stack segment is too large!" << endl;
+        //     _panic();
+        // }
+    }
+
+    // Check APPLICATION integrity and get the size of its segments
+    for(unsigned i=0; i < si->bm.n_apps; i++){
+        si->lm.app[i].app_entry = 0;
+        si->lm.app[i].app_segments = 0;
+        si->lm.app[i].app_code = ~0U;
+        si->lm.app[i].app_code_size = 0;
+        si->lm.app[i].app_data = ~0U;
+        si->lm.app[i].app_data_size = 0;
+        if(si->lm.has_app) {
+            ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
+            if(!app_elf->valid()) {
+                db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
+                _panic();
+            }
+            si->lm.app[i].app_entry = app_elf->entry();
+            si->lm.app[i].app_segments = app_elf->segments();
+            si->lm.app[i].app_code = app_elf->segment_address(0);
+            si->lm.app[i].app_code_size = app_elf->segment_size(0);
+            if(app_elf->segments() > 1) {
+                for(int i = 1; i < app_elf->segments(); i++) {
+                    if(app_elf->segment_type(i) != PT_LOAD)
+                        continue;
+                    if(app_elf->segment_address(i) < si->lm.app[i].app_data)
+                        si->lm.app[i].app_data = app_elf->segment_address(i);
+                    si->lm.app[i].app_data_size += app_elf->segment_size(i);
+                }
+            }
+    }
+        // if(Traits<System>::multiheap) { // Application heap in data segment
+        //     si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
+        //     si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
+        //     si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
+        // }
+        // if(si->lm.has_ext) { // Check for EXTRA data in the boot image
+        //     si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
+        //     if(Traits<System>::multiheap)
+        //         si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
+        //     si->lm.app_data_size += si->lm.app_extra_size;
+        // }
+    }
+}
+
+void Setup_SifiveE::build_page_tables()
+{
+    // Address of the Directory
+    Reg page_tables = PAGE_TABLES;
+    MMU::_master = new ( (void *) page_tables ) Page_Directory();
+
+    // Number of kernel entries in each directory
+    unsigned sys_entries = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
+
+    MMU::_master->remap(page_tables + 4096, RV32_Flags::VALID, 0, sys_entries);
+
+    // Map logical addrs back to themselves; with this, the kernel may access any
+    // physical RAM address directly (as if paging wasn't there)
+    for(unsigned i = 0; i < sys_entries; i++)
+    {
+        Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1)) ) Page_Table();
+        pt->remap(i * 1024*4096, RV32_Flags::SYS);
+    }
+}
+
+extern "C" char __bss_start;
+extern "C" char _end;
+
+void Setup_SifiveE::clean_bss()
+{
+    unsigned * bss_start = reinterpret_cast<unsigned *>(&__bss_start);
+    unsigned * bss_end = reinterpret_cast<unsigned *>(&_end);
+    
+    db<Setup>(TRC) << "bss_start=" << bss_start << ", bss_end=" << bss_end << endl;
+    for (unsigned * word = bss_start; word < bss_end; word++) {
+        unsigned * t = new (word) unsigned;
+        *t = 0;
+    }
+}
+
+void Setup_SifiveE::setup_supervisor_environment()
+{
+    Display::init();
+    
+    // We must clean the bss before setting MMU::_master
+    clean_bss();
+
+    // This creates and configures the kernel page tables (which map logical==physical)
+    build_page_tables();
+
+    si = reinterpret_cast<System_Info*>(placeholder);
+    build_lm();
+    load_parts();
+
+    // forward everything
+    CPU::satp((0x1 << 31) | (PAGE_TABLES >> 12));
+    
+    CPU::sepc_write(si->lm.ini_entry);
+
+    // Interrupts will remain disable until the Context::load at Init_First
+    CPU::sstatus_write(CPU::SPP_S);
+    CPU::sie_write(CPU::SSI | CPU::STI | CPU::SEI);
+
+    ASM("sret");
+}
+
+void Setup_SifiveE::setup_machine_environment()
+{
+    // We first configure the M-mode CSRs and then switch to S-mode
+    // configure paging. After that, we won't return to M-mode; an exception
+    // is the forwarding of ints and excps to S-mode.
+    CPU::mie_write(CPU::MSI | CPU::MTI | CPU::MEI);
+    CPU::mmode_int_disable();
+
+    // We need to set:
+    //      MPP_S: to switch to S-mode after mret
+    //      MPIE:  otherwise we won't ever receive interrupts
+    CPU::mstatus_write(CPU::MPP_S | CPU::MPIE);
+
+    // We store mhartid at tp, since it becomes inaccessible while in S-mode.
+    Reg core = CPU::mhartid();
+    CPU::tp(core);
+
+    // Set stack for each core
+    CPU::sp(Traits<Machine>::BOOT_STACK - Traits<Machine>::STACK_SIZE * core);
+
+    // Guarantee that paging is off before going to S-mode.
+    CPU::satp(0);
+
+    // Forward all ints and excs to S-mode.
+    //!ECALLS: Not yet implemented.
+    CPU::mideleg_write(CPU::SSI | CPU::STI | CPU::SEI);
+    CPU::medeleg_write(0xffff);
+
+    // Relocate _mmode_forward - 1024 bytes are enough
+    char * src = reinterpret_cast<char *>(&_mmode_forward);
+    char * dst = reinterpret_cast<char *>(MMODE_F);
+    for(int i=0; i < 1024; i++){
+        *dst = *src;
+        src++;
+        dst++;
+    }
+    
+    // All ints received in M-mode are forwarded to S-mode.
+    // The first two bits indicate the mode: Direct or Vectored;
+    // we opted for Direct.
+    CPU::mtvec(MMODE_F & 0xfffffffc);
+    CPU::mepc((unsigned)&setup_supervisor_environment);
+
+    ASM("mret");
+}
+
+__END_SYS
+
+void _setup() { Setup_SifiveE::init(); }
diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
index cfb0d35..95f1ce4 100644
--- a/src/system/system_scaffold.cc
+++ b/src/system/system_scaffold.cc
@@ -15,7 +15,7 @@ class First_Object
 {
 public:
     First_Object() {
-        Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
+        // Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
     }
 };
 
diff --git a/tests/active_test/active_test.cc b/tests/active_test/active_test.cc
new file mode 100644
index 0000000..a7bd4cc
--- /dev/null
+++ b/tests/active_test/active_test.cc
@@ -0,0 +1,63 @@
+// EPOS Active Object Component Test Program
+
+#include <process.h>
+
+using namespace EPOS;
+
+const int iterations = 100;
+
+OStream cout;
+
+class A: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "a";
+            cout << endl;
+        }
+
+        return 'A';
+    }
+};
+
+class B: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "b";
+            cout << endl;
+        }
+
+        return 'B';
+    }
+};
+
+int main()
+{
+    cout << "Active Object Test" << endl;
+
+    A * a = new A;
+    B * b = new B;
+
+    a->start();
+    b->start();
+
+    cout << "Both threads are now done and have suspended themselves. I'll now wake them up so they can exit ..." << endl;
+
+    int status_a = a->join();
+    int status_b = b->join();
+
+    cout << "Thread A exited with status " << status_a
+ 	 << " and thread B exited with status " << status_b << endl;
+
+    delete a;
+    delete b;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
new file mode 100644
index 0000000..4642f73
--- /dev/null
+++ b/tests/active_test/active_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 1000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/active_test/makefile b/tests/active_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/active_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index 609d140..0f9a2d0 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = IA32;
-    static const unsigned int MACHINE = PC;
-    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/tests/scheduler_dm_test/makefile b/tests/scheduler_dm_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_dm_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_dm_test/scheduler_dm_test_traits.h b/tests/scheduler_dm_test/scheduler_dm_test_traits.h
new file mode 100644
index 0000000..9479846
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef DM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/scheduler_edf_test/makefile b/tests/scheduler_edf_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_edf_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_edf_test/scheduler_edf_test_traits.h b/tests/scheduler_edf_test/scheduler_edf_test_traits.h
new file mode 100644
index 0000000..186aaa6
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef EDF Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/scheduler_rm_test/makefile b/tests/scheduler_rm_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_rm_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_rm_test/scheduler_rm_test.cc b/tests/scheduler_rm_test/scheduler_rm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_rm_test/scheduler_rm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_rm_test/scheduler_rm_test_traits.h b/tests/scheduler_rm_test/scheduler_rm_test_traits.h
new file mode 100644
index 0000000..47e23e5
--- /dev/null
+++ b/tests/scheduler_rm_test/scheduler_rm_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/segment_test/makefile b/tests/segment_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/segment_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
new file mode 100644
index 0000000..67c0759
--- /dev/null
+++ b/tests/segment_test/segment_test.cc
@@ -0,0 +1,50 @@
+// EPOS Segment Test Program
+
+#include <memory.h>
+
+using namespace EPOS;
+
+const unsigned ES1_SIZE = 10000;
+const unsigned ES2_SIZE = 100000;
+
+int main()
+{
+    OStream cout;
+
+    cout << "Segment test" << endl;
+
+    cout << "My address space's page directory is located at "
+         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
+    Address_Space self(MMU::current());
+
+    cout << "Creating two extra data segments:" << endl;
+    Segment * es1 = new (SYSTEM) Segment(ES1_SIZE);
+    Segment * es2 = new (SYSTEM) Segment(ES2_SIZE);
+    cout << "  extra segment 1 => " << ES1_SIZE << " bytes, done!" << endl;
+    cout << "  extra segment 2 => " << ES2_SIZE << " bytes, done!" << endl;
+
+    cout << "Attaching segments:" << endl;
+    CPU::Log_Addr * extra1 = self.attach(es1);
+    CPU::Log_Addr * extra2 = self.attach(es2);
+    cout << "  extra segment 1 => " << extra1 << " done!" << endl;
+    cout << "  extra segment 2 => " << extra2 << " done!" << endl;
+
+    cout << "Clearing segments:";
+    memset(extra1, 0, ES1_SIZE);
+    memset(extra2, 0, ES2_SIZE);
+    cout << "  done!" << endl;
+
+    cout << "Detaching segments:";
+    self.detach(es1);
+    self.detach(es2);
+    cout << "  done!" << endl;
+
+    cout << "Deleting segments:";
+    delete es1;
+    delete es2;
+    cout << "  done!" << endl;
+
+    cout << "I'm done, bye!" << endl;
+
+    return 0;
+}
diff --git a/app/hello/hello_traits.h b/tests/segment_test/segment_test_traits.h
similarity index 99%
rename from app/hello/hello_traits.h
rename to tests/segment_test/segment_test_traits.h
index 6661b46..d1ca6d5 100644
--- a/app/hello/hello_traits.h
+++ b/tests/segment_test/segment_test_traits.h
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
index dbe3578..6a583c0 100644
--- a/tools/eposcc/eposcc
+++ b/tools/eposcc/eposcc
@@ -45,26 +45,26 @@ C_LINK_OBJS=
 C_LINK_LIBS=
 
 CPP_COMPILER="$TOOLS_PREFIX""g++"
-CPP_COMP_FLGS="--no-exceptions --no-rtti --no-use-cxa-atexit -std=c++14"
+CPP_COMP_FLGS="$MACH_CC_FLAGS"
 CPP_COMP_HDRS=
 CPP_LINK_FLGS="$MACH_LD_FLAGS"
 CPP_LINK_OBJS=
 CPP_LINK_LIBS=
 
-F77_COMPILER="$TOOLS_PREFIX""g77"
-F77_COMP_FLGS=
-F77_COMP_HDRS=
-F77_LINK_FLGS="$MACH_LD_FLAGS"
-F77_LINK_OBJS=
-F77_LINK_LIBS="f2c"
+# F77_COMPILER="$TOOLS_PREFIX""g77"
+# F77_COMP_FLGS=
+# F77_COMP_HDRS=
+# F77_LINK_FLGS="$MACH_LD_FLAGS"
+# F77_LINK_OBJS=
+# F77_LINK_LIBS="f2c"
 
 LINKER="$TOOLS_PREFIX""ld"
 
 LINKER_LIBRARY=$LINKER
 LINK_FLGS_LIBRARY="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE"
-if [ "$MACH_DATA_NAME" != "" ] ; then
-    LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=$APP_DATA"
-fi
+# if [ "$MACH_DATA_NAME" != "" ] ; then
+#     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=0x86000000"
+# fi
 if [ "$BOOT_STACK" != "" ] ; then
     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --defsym=__boot_stack__=$BOOT_STACK"
 fi
@@ -79,19 +79,19 @@ fi
 LINKER_BUILTIN=$LINKER
 LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
 LINK_OBJI_BUILTIN="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
-LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o -R$SRC/system/system_$MMOD"
-LINK_OBJL_BUILTIN="$LIB/crtend_$MMOD.o"
+LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o $LIB/crtend_$MMOD.o -R$SRC/system/system_$MMOD"
+# LINK_OBJL_BUILTIN=
 LINK_LIBS_BUILTIN="util_$MMOD gcc"
 if [ "$SETUP" = "" ] ; then
 LINK_OBJN_BUILTIN="$LIB/setup_$MMOD.o $LINK_OBJN_BUILTIN"
 fi
 
-LINKER_KERNEL=$LINKER
-LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
-LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
-LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
-LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
-LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
+# LINKER_KERNEL=$LINKER
+# LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+# LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
+# LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
+# LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
+# LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
 
 #=========================================================================
 # VARIABLES
@@ -271,6 +271,7 @@ done
 #=========================================================================
 # COMMAND ISSUING
 #=========================================================================
+
 if [ "$language" = "F77" ] ; then
     compiler=$F77_COMPILER
     compile_flgs="$compile_flgs $F77_COMP_FLGS"
@@ -347,51 +348,54 @@ if [ $need_compile = 1 -a ! -f "$key_file" ] ; then
 fi
 
 # disabled for EPOS
-if [ $need_analyze = 5 ] ; then
-    analyze_flgs=$compile_flgs
+# if [ $need_analyze = 5 ] ; then
+#     analyze_flgs=$compile_flgs
 
-    if [ $has_dash_c = 0 ] ; then
-        analyze_flgs="-c $analyze_flgs"
-    fi
-    tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
-    analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
-    analyze_flgs="$analyze_flgs -o $tmp_file.o"
-    $do_echo $compiler $analyze_flgs $analyze_args $input_file
-    $do_exec $compiler $analyze_flgs $analyze_args $input_file
-    status=$?
-    if [ $status != 0 ] ; then
-        $do_echo rm -f "$tmp_file.*"
-        $do_exec rm -f "$tmp_file.*"
-        exit $status
-    fi
+#     if [ $has_dash_c = 0 ] ; then
+#         analyze_flgs="-c $analyze_flgs"
+#     fi
+#     tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
+#     analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
+#     analyze_flgs="$analyze_flgs -o $tmp_file.o"
+#     $do_echo $compiler $analyze_flgs $analyze_args $input_file
+#     $do_exec $compiler $analyze_flgs $analyze_args $input_file
+#     status=$?
+#     if [ $status != 0 ] ; then
+#         $do_echo rm -f "$tmp_file.*"
+#         $do_exec rm -f "$tmp_file.*"
+#         exit $status
+#     fi
 
-    $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
-    $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
-    status=$?
-    if [ $status != 0 ] ; then
-        $do_echo rm -f "$tmp_file.*"
-        $do_exec rm -f "$tmp_file.*"
-        exit $status
-    fi
+#     $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+#     $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+#     status=$?
+#     if [ $status != 0 ] ; then
+#         $do_echo rm -f "$tmp_file.*"
+#         $do_exec rm -f "$tmp_file.*"
+#         exit $status
+#     fi
 
-    if [ $only_analyze = 1 -a -n "$output_file" ] ; then
-        configurator_output_file=$output_file
-    else
-        configurator_output_file=$key_file
-    fi
-    $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
-    $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+#     if [ $only_analyze = 1 -a -n "$output_file" ] ; then
+#         configurator_output_file=$output_file
+#     else
+#         configurator_output_file=$key_file
+#     fi
+#     $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+#     $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
 
-    status=$?
-    $do_echo rm -f "$tmp_file.*"
-    $do_exec rm -f "$tmp_file.*"
+#     status=$?
+#     $do_echo rm -f "$tmp_file.*"
+#     $do_exec rm -f "$tmp_file.*"
 
-    if [ $only_analyze = 1 ] ; then
-        exit $status
-    fi
-fi
+#     if [ $only_analyze = 1 ] ; then
+#         exit $status
+#     fi
+# fi
 
 if [ $need_compile = 1 ] ; then
+    # echo $has_dash_c
+    # echo $language
+    # echo $compile_flgs
     if [ $has_dash_c = 0 ] ; then
         compile_flgs="-c $compile_flgs"
     fi
@@ -412,7 +416,7 @@ if [ $need_link = 1 ] ; then
         link_flgs="$link_flgs -o $output_file"
     fi
     $do_echo "$linker $link_flgs $link_objs $link_args $link_libs"
-    $do_exec $linker $link_flgs $link_objs $link_args $link_libs
+    $do_exec $linker --trace $link_flgs $link_objs $link_args $link_libs
     status=$?
 fi
 
diff --git a/tools/eposcfg/eposcfg.cc b/tools/eposcfg/eposcfg.cc
index 51b0f64..b0f48d5 100644
--- a/tools/eposcfg/eposcfg.cc
+++ b/tools/eposcfg/eposcfg.cc
@@ -10,6 +10,7 @@
 
 // Traits are included in config.h
 #include <system/config.h>
+#include <system/memory_map.h>
 
 // Using only bare C to avoid conflicts with EPOS
 #include <stdio.h>
@@ -21,7 +22,7 @@ using namespace EPOS::S;
 using namespace EPOS::S::U;
 
 // Constants
-const unsigned int TOKENS = 24;
+const unsigned int TOKENS = 32;
 const unsigned int COMPONENTS = 62;
 const unsigned int STRING_SIZE = 128;
 
@@ -40,14 +41,22 @@ char tokens[TOKENS][STRING_SIZE] = {
     "MEM_TOP",
     "MEM_SIZE",
     "MEM_SIZE_KB",
+    "MIO_BASE",
+    "MIO_TOP",
+    "MMODE_F",
+    "MIO_SIZE",
+    "MIO_SIZE_KB",
     "BOOT_STACK",
     "BOOT",
+    "IMAGE",
     "SETUP",
     "INIT",
     "APP_CODE",
     "APP_DATA",
     "SYS_CODE",
     "SYS_DATA",
+    "SYS_STACK",
+    "SYS_HEAP",
     "BOOT_LENGTH_MIN",
     "BOOT_LENGTH_MAX",
     "EXPECTED_SIMULATION_TIME"
@@ -192,66 +201,99 @@ void populate_strings()
     snprintf(string, STRING_SIZE, "%i", Traits<CPU>::WORD_SIZE);
     set_token_value("WORD_SIZE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_BASE);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_BASE);
     set_token_value("MEM_BASE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP);
     set_token_value("MEM_TOP", string);
+    
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MMODE_F);
+    set_token_value("MMODE_F", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE);
     set_token_value("MEM_SIZE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", (Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE) / 1024);
+    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE) / 1024);
     set_token_value("MEM_SIZE_KB", string);
 
-    if(Traits<Machine>::BOOT_STACK != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT_STACK);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_BASE);
+    set_token_value("MIO_BASE", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP);
+    set_token_value("MIO_TOP", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE);
+    set_token_value("MIO_SIZE", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE) / 1024);
+    set_token_value("MIO_SIZE_KB", string);
+
+    if(Memory_Map::BOOT_STACK != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT_STACK);
     else
         string[0] = '\0';
     set_token_value("BOOT_STACK", string);
 
-    if(Traits<Machine>::BOOT != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT);
+    if(Memory_Map::BOOT != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT);
     else
         string[0] = '\0';
     set_token_value("BOOT", string);
 
-    if(Traits<Machine>::SETUP != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SETUP);
+    if(Memory_Map::IMAGE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::IMAGE);
+    else
+        string[0] = '\0';
+    set_token_value("IMAGE", string);
+
+    if(Memory_Map::SETUP != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SETUP);
     else
         string[0] = '\0';
     set_token_value("SETUP", string);
 
-    if(Traits<Machine>::INIT != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::INIT);
+    if(Memory_Map::INIT != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::INIT);
     else
         string[0] = '\0';
     set_token_value("INIT", string);
 
-    if(Traits<Machine>::APP_CODE != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_CODE);
+    if(Memory_Map::APP_CODE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_CODE);
     else
         string[0] = '\0';
     set_token_value("APP_CODE", string);
 
-    if(Traits<Machine>::APP_DATA != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_DATA);
+    if(Memory_Map::APP_DATA != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_DATA);
     else
         string[0] = '\0';
     set_token_value("APP_DATA", string);
 
-    if(Traits<Machine>::SYS_CODE != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_CODE);
+    if(Memory_Map::SYS_CODE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_CODE);
     else
         string[0] = '\0';
     set_token_value("SYS_CODE", string);
 
-    if(Traits<Machine>::SYS_DATA != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_DATA);
+    if(Memory_Map::SYS_DATA != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_DATA);
     else
         string[0] = '\0';
     set_token_value("SYS_DATA", string);
 
+    if(Memory_Map::SYS_STACK != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_STACK);
+    else
+        string[0] = '\0';
+    set_token_value("SYS_STACK", string);
+
+    if(Memory_Map::SYS_HEAP != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_HEAP);
+    else
+        string[0] = '\0';
+    set_token_value("SYS_HEAP", string);
+
     if(Traits<Machine>::BOOT_LENGTH_MIN != Traits<Machine>::NOT_USED)
         snprintf(string, STRING_SIZE, "%i", Traits<Machine>::BOOT_LENGTH_MIN);
     else
diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
index c54f943..d0e99b2 100755
--- a/tools/eposctors/eposctors
+++ b/tools/eposctors/eposctors
@@ -6,14 +6,16 @@
 ELF=$1
 GDB=$2
 
-INIT_ARRAY_OFFSET=`objdump -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
-INIT_ARRAY_SIZE=`objdump -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
-FINI_ARRAY_OFFSET=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
-FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
+OBJDUMP=/usr/local/rv32/bin/riscv32-unknown-linux-gnu-objdump
+INIT_ARRAY_OFFSET=`$OBJDUMP -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
+INIT_ARRAY_SIZE=`$OBJDUMP -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
+FINI_ARRAY_OFFSET=`$OBJDUMP -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
+FINI_ARRAY_SIZE=`$OBJDUMP -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
 
 echo "CTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    dec=`printf "%d" 0x$INIT_ARRAY_SIZE`
+    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n $dec -v -e '1/4 "%08x\n"' $ELF`
     for item in $LIST; do
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
         echo 0x$item $sym
@@ -25,7 +27,8 @@ fi
 echo
 echo "DTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$FINI_ARRAY_OFFSET -n 0x$FINI_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    dec=`printf "%d" 0x$FINI_ARRAY_SIZE`
+    LIST=`hexdump -s 0x$FINI_ARRAY_OFFSET -n $dec -v -e '1/4 "%08x\n"' $ELF`
     for item in $LIST; do
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_D_//g"|c++filt`
         echo 0x$item $sym
diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
index da82176..9072761 100644
--- a/tools/eposmkbi/eposmkbi.cc
+++ b/tools/eposmkbi/eposmkbi.cc
@@ -38,6 +38,8 @@ struct Configuration
     bool           endianess;  // true => little, false => big
     unsigned int   mem_base;
     unsigned int   mem_top;
+    unsigned int   mio_base;
+    unsigned int   mio_top;
     unsigned int   boot_length_min;
     unsigned int   boot_length_max;
     short          node_id;   // nodes in SAN (-1 => dynamic)
@@ -52,13 +54,13 @@ typedef _SYS::System_Info System_Info;
 
 // PROTOTYPES
 bool parse_config(FILE * cfg_file, Configuration * cfg);
-void strtolower (char *dst,const char* src);
+void strtolower (char * dst,const char * src);
 bool add_machine_secrets(int fd_img, unsigned int i_size, char * mach, char * mmod);
 
 bool file_exist(char *file);
 
-int put_buf(int fd_out, void *buf, int size);
-int put_file(int fd_out, char *file);
+int put_buf(int fd_out, void * buf, int size);
+int put_file(int fd_out, char * file);
 int pad(int fd_out, int size);
 bool lil_endian();
 
@@ -140,7 +142,7 @@ int main(int argc, char **argv)
     }
 
     // Open destination file (rewrite)
-    int fd_img = open(argv[optind + 1], O_WRONLY | O_CREAT | O_TRUNC, 00644);
+    int fd_img = open(argv[optind + 1], O_RDWR | O_CREAT | O_TRUNC, 00644);
     if(fd_img < 0) {
         fprintf(err, "Error: can't create boot image \"%s\"!\n", argv[optind + 1]);
         return 1;
@@ -152,7 +154,8 @@ int main(int argc, char **argv)
     fprintf(out, "  Model: %s\n", CONFIG.mmod);
     fprintf(out, "  Processor: %s (%d bits, %s-endian)\n", CONFIG.arch, CONFIG.word_size, CONFIG.endianess ? "little" : "big");
     fprintf(out, "  Memory: %d KBytes\n", (CONFIG.mem_top - CONFIG.mem_base) / 1024);
-    fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
+    if((CONFIG.boot_length_min + CONFIG.boot_length_max) > 0)
+        fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
     if(CONFIG.space_x != -1)
         fprintf(out, "  Node location: (%d, %d, %d)\n", CONFIG.space_x, CONFIG.space_y, CONFIG.space_z);
     fprintf(out, "  UUID: ");
@@ -162,7 +165,7 @@ int main(int argc, char **argv)
     // Create the boot image
     unsigned int image_size = 0;
     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
-
+    
     // Add BOOT
     if(CONFIG.boot_length_max > 0) {
         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
@@ -179,38 +182,56 @@ int main(int argc, char **argv)
     }
     unsigned int boot_size = image_size;
 
+    // Determine if System_Info is needed and how it must be handled
+    bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
+    bool si_in_setup = (need_si && (boot_size == 0)); // If the image contains a boot sector, then SI will be on a separate disk sector. Otherwise, it will be inside SETUP.
+
     // Reserve space for System_Info if necessary
-    System_Info si;
-    bool need_si = true;
-    if(image_size == 0) {
-        need_si = false;
-    } else
-        if(sizeof(System_Info) > MAX_SI_LEN) {
+    if(need_si && !si_in_setup) {
+        if(sizeof(System_Info) <= MAX_SI_LEN) {
+            image_size += pad(fd_img, MAX_SI_LEN);
+        } else {
             fprintf(out, " failed!\n");
             fprintf(err, "System_Info structure is too large (%d)!\n", sizeof(System_Info));
             return 1;
-        } else
-            image_size += pad(fd_img, MAX_SI_LEN);
+        }
+    }
 
     // Initialize the Boot_Map in System_Info
-    si.bm.n_cpus   = CONFIG.n_cpus; // can be adjusted by SETUP in some machines
+    System_Info si;
+    si.bm.n_cpus   = CONFIG.n_cpus;     // can be adjusted by SETUP in some machines
     si.bm.mem_base = CONFIG.mem_base;
     si.bm.mem_top  = CONFIG.mem_top;
-    si.bm.io_base  = 0; // will be adjusted by SETUP
-    si.bm.io_top   = 0; // will be adjusted by SETUP
+    si.bm.mio_base = CONFIG.mio_base;   // can be adjusted by SETUP in some machines
+    si.bm.mio_top  = CONFIG.mio_top;    // can be adjusted by SETUP in some machines
     si.bm.node_id  = CONFIG.node_id;
     si.bm.space_x  = CONFIG.space_x;
     si.bm.space_y  = CONFIG.space_y;
     si.bm.space_z  = CONFIG.space_z;
+    si.bm.n_apps   = argc-3;
+
+    fprintf(out, "\nBoot Map:");
+    fprintf(out, "\n    si.bm.n_cpus %u", si.bm.n_cpus);
+    fprintf(out, "\n    si.bm.mem_base %08x", si.bm.mem_base);
+    fprintf(out, "\n    si.bm.mem_top %08x", si.bm.mem_top);
+    fprintf(out, "\n    si.bm.mio_base %08x", si.bm.mio_base);
+    fprintf(out, "\n    si.bm.mio_top %08x", si.bm.mio_top);
+    fprintf(out, "\n    si.bm.node_id %u", si.bm.node_id);
+    fprintf(out, "\n    si.bm.space_x %u", si.bm.space_x);
+    fprintf(out, "\n    si.bm.space_y %u", si.bm.space_y);
+    fprintf(out, "\n    si.bm.space_z %u\n\n", si.bm.space_z);
+
     for(unsigned int i = 0; i < 8; i++)
         si.bm.uuid[i]  = CONFIG.uuid[i];
 
     // Add SETUP
     sprintf(file, "%s/img/setup_%s", argv[optind], CONFIG.mmod);
     if(file_exist(file)) {
-        si.bm.setup_offset = image_size - boot_size;
+        // Setup is a raw binary file now; it has no Elf header to be read
+        si.bm.setup_offset = -1;
         fprintf(out, "    Adding setup \"%s\":", file);
         image_size += put_file(fd_img, file);
+        image_size += pad(fd_img, 4*4096 - (image_size % 4096));
     } else
         si.bm.setup_offset = -1;
 
@@ -233,22 +254,17 @@ int main(int argc, char **argv)
     }
 
     // Add application(s) and data
-    si.bm.application_offset = image_size - boot_size;
+    si.bm.application_offset[0] = image_size - boot_size;
     fprintf(out, "    Adding application \"%s\":", argv[optind + 2]);
     image_size += put_file(fd_img, argv[optind + 2]);
     if((argc - optind) == 3) // single APP
         si.bm.extras_offset = -1;
-    else { // multiple APPs or data
-        si.bm.extras_offset = image_size - boot_size;
-        struct stat file_stat;
-        for(int i = optind + 3; i < argc; i++) {
-            fprintf(out, "    Adding file \"%s\":", argv[i]);
-            stat(argv[i], &file_stat);
-            image_size += put_number(fd_img, file_stat.st_size);
+    else{
+        for(int i=4; i<argc; i++){
+            si.bm.application_offset[i-3] = image_size - boot_size;
+            fprintf(out, "    Adding application \"%s\":", argv[i]);
             image_size += put_file(fd_img, argv[i]);
         }
-        // Signalize last application by setting its size to 0
-        image_size += put_number(fd_img, 0);
     }
 
     // Add the size of the image to the Boot_Map in System_Info (excluding BOOT)
@@ -256,8 +272,42 @@ int main(int argc, char **argv)
 
     // Add System_Info
     if(need_si) {
-        fprintf(out, "    Adding system info:");
-        if(lseek(fd_img, boot_size, SEEK_SET) < 0) {
+        unsigned int si_offset = boot_size;
+        fprintf(out, "    Adding system info");
+        if(si_in_setup) {
+            fprintf(out, " to SETUP:");
+            struct stat stat;
+            if(fstat(fd_img, &stat) < 0)  {
+                fprintf(out, " failed! (stat)\n");
+                return 0;
+            }
+            char * buffer = (char *) malloc(stat.st_size);
+            if(!buffer) {
+                fprintf(out, " failed! (malloc)\n");
+                return 0;
+            }
+            memset(buffer, '\1', stat.st_size);
+            lseek(fd_img, 0, SEEK_SET);
+            if(read(fd_img, buffer, stat.st_size) < 0) {
+                fprintf(out, " failed! (read)\n");
+                free(buffer);
+                return 0;
+            }
+
+            char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+            char * setup_si = reinterpret_cast<char *>(memmem(buffer, stat.st_size, placeholder, strlen(placeholder)));
+            if(setup_si) {
+                si_offset = setup_si - buffer;
+            } else {
+                fprintf(out, " failed! (SETUP does not contain System_Info placeholder)\n");
+                free(buffer);
+                return 0;
+            }
+        } else {
+            fprintf(out, " to image:");
+            si_offset = boot_size;
+        }
+        if(lseek(fd_img, si_offset, SEEK_SET) < 0) {
             fprintf(err, "Error: can't seek the boot image!\n");
             return 1;
         }
@@ -279,7 +329,7 @@ int main(int argc, char **argv)
     }
     fprintf(out, " done.\n");
 
-    //Finish
+    // Finish
     close(fd_img);
     fprintf(out, "\n  Image successfully generated (%d bytes)!\n\n", image_size);
 
@@ -400,7 +450,7 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
         fprintf(err, "Error: no valid MEM_BASE in configuration!\n");
         return false;
     }
-    cfg->mem_base = strtol(token, 0, 16);
+    cfg->mem_base = strtoll(token, 0, 16);
 
     // Memory Top
     if(fgets(line, 256, cfg_file) != line) {
@@ -412,7 +462,31 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
         fprintf(err, "Error: no valid MEM_TOP in configuration!\n");
         return false;
     }
-    cfg->mem_top=strtol(token, 0, 16);
+    cfg->mem_top = strtoll(token, 0, 16);
+
+    // I/O Base
+    if(fgets(line, 256, cfg_file) != line) {
+        fprintf(err, "Error: failed to read MIO_BASE from configuration file!\n");
+        return false;
+    }
+    token = strtok(line, "=");
+    if(strcmp(token, "MIO_BASE") || !(token = strtok(NULL, "\n"))) {
+        fprintf(err, "Error: no valid MIO_BASE in configuration!\n");
+        return false;
+    }
+    cfg->mio_base = strtoll(token, 0, 16);
+
+    // I/O Top
+    if(fgets(line, 256, cfg_file) != line) {
+        fprintf(err, "Error: failed to read MIO_TOP from configuration file!\n");
+        return false;
+    }
+    token = strtok(line, "=");
+    if(strcmp(token, "MIO_TOP") || !(token = strtok(NULL, "\n"))) {
+        fprintf(err, "Error: no valid MIO_TOP in configuration!\n");
+        return false;
+    }
+    cfg->mio_top = strtoll(token, 0, 16);
 
     // Boot Length Min
     if(fgets(line, 256, cfg_file) != line)
@@ -474,9 +548,9 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
     if(!put_number(fd, static_cast<T>(si->bm.mem_top)))
         return false;
 
-    if(!put_number(fd, static_cast<T>(0))) // io_base
+    if(!put_number(fd, static_cast<T>(si->bm.mio_base)))
         return false;
-    if(!put_number(fd, static_cast<T>(0))) // io_top
+    if(!put_number(fd, static_cast<T>(si->bm.mio_top)))
         return false;
 
     if(!put_number(fd, si->bm.node_id))
@@ -499,7 +573,11 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
         return false;
     if(!put_number(fd, static_cast<T>(si->bm.system_offset)))
         return false;
-    if(!put_number(fd, static_cast<T>(si->bm.application_offset)))
+    for(int i=0; i<8; i++){
+        if(!put_number(fd, static_cast<T>(si->bm.application_offset[i])))                 
+            return false;
+    }
+    if(!put_number(fd, static_cast<T>(si->bm.n_apps)))
         return false;
     if(!put_number(fd, static_cast<T>(si->bm.extras_offset)))
         return false;
@@ -512,7 +590,7 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
 //=============================================================================
 bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
 {
-    if (!strcmp(mach, "pc")) { // PC
+    if(!strcmp(mach, "pc")) { // PC
         const unsigned int floppy_size   = 1474560;
         const unsigned int secrets_offset   = CONFIG.boot_length_min - 6;
         const unsigned short boot_id        = 0xaa55;
@@ -552,7 +630,7 @@ bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
         char key_string[] = ":020000040027D3\r\n:0CFFD400FFFFFFEF000000000000200015\r\n:00000001FF\r\n"; // Bootloader Disabled
         const int key_offset = -strlen(":00000001FF\r\n");
 
-        // Write key string to unlock epos
+        // Write key string to unlock EPOS
         if(lseek(fd,key_offset,SEEK_END) < 0) {
             fprintf(err, "Error: can't seek the boot image!\n");
             return false;
