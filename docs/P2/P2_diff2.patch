diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..6ee3754
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,9 @@
+{
+    "files.associations": {
+        "makeinc": "makefile",
+        "makedefs": "makefile",
+        "*.cfg": "plaintext",
+        "atomic": "cpp",
+        "vector": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/app/hello/hello.cc b/app/hello_usr/hello_usr.cc
similarity index 88%
rename from app/hello/hello.cc
rename to app/hello_usr/hello_usr.cc
index 40c7c05..2246846 100644
--- a/app/hello/hello.cc
+++ b/app/hello_usr/hello_usr.cc
@@ -1,4 +1,5 @@
 #include <utility/ostream.h>
+#include <time.h>
 
 using namespace EPOS;
 
@@ -7,6 +8,5 @@ OStream cout;
 int main()
 {
     cout << "Hello world!" << endl;
-
     return 0;
 }
diff --git a/app/hello_usr/hello_usr_traits.h b/app/hello_usr/hello_usr_traits.h
new file mode 100644
index 0000000..0c80155
--- /dev/null
+++ b/app/hello_usr/hello_usr_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/hello/makefile b/app/hello_usr/makefile
similarity index 100%
rename from app/hello/makefile
rename to app/hello_usr/makefile
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 6661b46..0c80155 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -9,19 +9,19 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = BUILTIN;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
     static const bool monitored = false;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool hysterically_debugged = true;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
@@ -106,7 +106,7 @@ template<> struct Traits<System>: public Traits<Build>
     static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
     static const bool multitask = (mode != Traits<Build>::LIBRARY);
     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
-    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 6661b46..bdd7794 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -9,7 +9,7 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = BUILTIN;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/test_rm1/makefile b/app/test_rm1/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_rm1/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_rm1/test_rm1.cc b/app/test_rm1/test_rm1.cc
new file mode 100644
index 0000000..09b22e0
--- /dev/null
+++ b/app/test_rm1/test_rm1.cc
@@ -0,0 +1,73 @@
+#include <system.h>
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+typedef unsigned int Tick;
+
+int function_periodic_a(){
+    // CPU::int_enable_for_test(); // ints were disabled
+    for(int i=0;i<5;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin a tick: " << begin << endl;
+        while(tot <= 100){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ a is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end a tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+int function_periodic_b(){
+    // CPU::int_enable_for_test();
+    for(int i=0;i<5;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin b tick: " << begin << endl;
+        while(tot <= 1000){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ b is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end b tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+
+int main()
+{
+    cout << "\n\n\n\n============ Hello world!" << endl;
+
+
+    Periodic_Thread * a = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 500, 5) , &function_periodic_a);
+    Periodic_Thread * b = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 1600, 5) , &function_periodic_b);
+
+    a->join();
+    b->join();
+    cout << "============ Goodbye world!\n\n\n\n" << endl;
+
+    return 0;
+}
\ No newline at end of file
diff --git a/app/test_rm1/test_rm1_traits.h b/app/test_rm1/test_rm1_traits.h
new file mode 100644
index 0000000..86e9470
--- /dev/null
+++ b/app/test_rm1/test_rm1_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/app/test_rm2/makefile b/app/test_rm2/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_rm2/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_rm2/test_rm2.cc b/app/test_rm2/test_rm2.cc
new file mode 100644
index 0000000..6f8f368
--- /dev/null
+++ b/app/test_rm2/test_rm2.cc
@@ -0,0 +1,97 @@
+// A reference to this test is in this directory (RM-example.png). Here, the values are multiplied by 5.
+
+#include <system.h>
+#include <utility/ostream.h>
+#include <process.h>
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+typedef unsigned int Tick;
+
+int function_periodic_a(){
+    for(int i=0;i<4;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin a tick: " << begin << endl;
+        while(tot <= 100){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();    
+                cout << "============ a is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end a tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+int function_periodic_b(){
+    for(int i=0;i<3;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin b tick: " << begin << endl;
+        while(tot <= 200){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ b is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end b tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+int function_periodic_c(){
+    for(int i=0;i<2 ;i++){
+        Tick begin = Alarm::elapsed();
+        Tick last = Alarm::elapsed();
+        Tick tot = 0;
+        cout << "============ begin c tick: " << begin << endl;
+        while(tot <= 500){
+            CPU::int_disable();
+            if (Alarm::elapsed() - last > 5) {
+                last = Alarm::elapsed();
+                cout << "============ c is back tick: " << Alarm::elapsed() << endl;
+            }
+            tot += Alarm::elapsed() - last;
+            last = Alarm::elapsed();
+            CPU::int_enable();
+        }
+        cout << "============ end c tick: " << Alarm::elapsed() << endl;
+        Periodic_Thread::wait_next();
+    }
+    return 0;
+}
+
+
+int main()
+{
+    cout << "\n\n\n\n============ Hello world!" << endl;
+
+
+    Periodic_Thread * a = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 500,  4) , &function_periodic_a);
+    Periodic_Thread * b = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 750,  3) , &function_periodic_b);
+    Periodic_Thread * c = new Periodic_Thread(Periodic_Thread::Configuration(Alarm::timer_period() * 1750, 2) , &function_periodic_c);
+
+    a->join();
+    b->join();
+    c->join();
+    cout << "============ Goodbye world!\n\n\n\n" << endl;
+
+    return 0;
+}
\ No newline at end of file
diff --git a/app/test_rm2/test_rm2_traits.h b/app/test_rm2/test_rm2_traits.h
new file mode 100644
index 0000000..b9053c9
--- /dev/null
+++ b/app/test_rm2/test_rm2_traits.h
@@ -0,0 +1,156 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = BUILTIN;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    // typedef RR Criterion;
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/app/test_worst_fit/makefile b/app/test_worst_fit/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_worst_fit/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_worst_fit/test_worst_fit.cc b/app/test_worst_fit/test_worst_fit.cc
new file mode 100644
index 0000000..4fd6bb2
--- /dev/null
+++ b/app/test_worst_fit/test_worst_fit.cc
@@ -0,0 +1,34 @@
+// We show the Worst Fit behavior by allocating 3 blocks (one large, two small), and then
+// freeing the outer blocks (b1, b3). This will fragment the Heap into two blocks: b1, b3.
+// Then, we alloc something in b3, which is the biggest block (but last in the underlying Grouping_List).
+// 
+// Traits<Application>::HEAP_SIZE = 16KB
+// For comparision purposes, we print how First Fit would have handled each allocation.
+
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+char * alloc(int bytes) {
+    return new char[bytes];
+}
+
+int main()
+{
+    // Terminal output is important after the following line
+    cout << "Testing Worst-Fit..." << endl;
+    CPU::int_disable();
+
+    char * b1 = alloc(15*1024);
+    char * b2 = alloc(128);
+    char * b3 = alloc(128);
+    
+    free(b3);
+    free(b1);
+
+    char * a1 = alloc(16);
+
+    return 0;
+}
diff --git a/app/test_worst_fit/test_worst_fit_traits.h b/app/test_worst_fit/test_worst_fit_traits.h
new file mode 100644
index 0000000..0fad2b3
--- /dev/null
+++ b/app/test_worst_fit/test_worst_fit_traits.h
@@ -0,0 +1,156 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = 16*1024;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    // typedef RR Criterion;
+    typedef FCFS Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/etc/makefile b/etc/makefile
index 1e29432..45d0fcd 100644
--- a/etc/makefile
+++ b/etc/makefile
@@ -31,7 +31,7 @@ eposcc.conf: FORCE
 		@echo "APP_DATA=$(shell $(BIN)/eposcfg APP_DATA)" >> $@
 		@echo "SETUP=$(shell $(BIN)/eposcfg SETUP)" >> $@
 		@echo "BOOT_STACK=$(shell $(BIN)/eposcfg BOOT_STACK)" >> $@
-		@echo "MACH_CC_FLAGS='$(MACH_CC_FLAGS)'" >> $@
+		@echo "MACH_CC_FLAGS='$(MACH_CXX_FLAGS)'" >> $@
 		@echo "MACH_LD_FLAGS='$(MACH_LD_FLAGS)'" >> $@
 		@echo "MACH_CODE_NAME='$(MACH_CODE_NAME)'" >> $@
 		@echo "MACH_DATA_NAME='$(MACH_DATA_NAME)'" >> $@
@@ -47,6 +47,8 @@ eposmkbi.conf:	FORCE
 		@echo "ENDIANESS=$(shell $(BIN)/eposcfg ENDIANESS)" >> $@
 		@echo "MEM_BASE=$(shell $(BIN)/eposcfg MEM_BASE)" >> $@
 		@echo "MEM_TOP=$(shell $(BIN)/eposcfg MEM_TOP)" >> $@
+		@echo "MIO_BASE=$(shell $(BIN)/eposcfg MIO_BASE)" >> $@
+		@echo "MIO_TOP=$(shell $(BIN)/eposcfg MIO_TOP)" >> $@
 		@echo "BOOT_LENGTH_MIN=$(shell $(BIN)/eposcfg BOOT_LENGTH_MIN)" >> $@
 		@echo "BOOT_LENGTH_MAX=$(shell $(BIN)/eposcfg BOOT_LENGTH_MAX)" >> $@
 		@echo "NODE_ID=$(NODE_ID)" >> $@
diff --git a/img/INTS b/img/INTS
new file mode 100644
index 0000000..e69de29
diff --git a/img/makefile b/img/makefile
index f048773..e630418 100644
--- a/img/makefile
+++ b/img/makefile
@@ -20,14 +20,14 @@ endif
 
 DEBUGGER	:= $(MACH_DEBUGGER)
 ifeq ($(DEBUG),1)
-ifneq ($(wildcard $(IMG)/$(MACH)_setup),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/$(MACH)_setup,.text)"
+ifneq ($(wildcard $(IMG)/setup_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/setup_$(MMOD),.text)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_init),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/$(MACH)_init,.text)"
+ifneq ($(wildcard $(IMG)/init_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/init_$(MMOD),.text)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_system),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
+ifneq ($(wildcard $(IMG)/system_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/system_$(MMOD),.text)"
 endif
 DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
 PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
@@ -45,7 +45,7 @@ all:		strip $(IMAGE)
 
 else
 
-all:		strip $(IMAGE) $(PEER_IMAGE)
+all:	 	$(IMAGE) $(PEER_IMAGE)
 
 $(IMAGE):	$(APPLICATION)
 		$(MKBI) -x 0 -y 0 -z 0 $@ $<
@@ -83,7 +83,7 @@ endif
 
 debug:		$(IMAGE)
 ifeq ($(NODES),1)
-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
+		$(EMULATOR)$(IMAGE) &
 		$(DEBUGGER)
 else
 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
@@ -104,7 +104,7 @@ strip:		$(SYSTEM) $(APPLICATION)
 		@for file in $^; do $(STRIP) "$${file}"; done;
 
 clean:		FORCE
-		$(CLEAN) $(SYSTEM) $(APPLICATION) $(IMAGE)
+		$(CLEAN) $(SYSTEM) $(APPLICATION) $(IMAGE) setup_sifive_e
 ifneq ($(NODES),1)
 		$(CLEAN) $(PEER_IMAGE)
 endif
@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
 		@echo "Running $(APPLICATION) ..."
 posrun_$(APPLICATION):
 		@echo "done!"
-		
+
 FORCE:
diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
index 5735fcf..ea8a03e 100644
--- a/include/architecture/mmu.h
+++ b/include/architecture/mmu.h
@@ -37,15 +37,19 @@ public:
     {
     public:
         enum {
-            PRE = 0x001, // Presence (0=not-present, 1=present)
-            RW  = 0x002, // Write (0=read-only, 1=read-write)
-            USR = 0x004, // Access Control (0=supervisor, 1=user)
-            CWT = 0x008, // Cache Mode (0=write-back, 1=write-through)
-            CD  = 0x010, // Cache Disable (0=cacheable, 1=non-cacheable)
-            CT  = 0x020, // Contiguous (0=non-contiguous, 1=contiguous)
-            IO  = 0x040, // Memory Mapped I/O (0=memory, 1=I/O)
-            SYS = (PRE | RW ),
-            APP = (PRE | RW | USR)
+            PRE  = 0x001, // Presence (0=not-present, 1=present)
+            RW   = 0x002, // Write (0=read-only, 1=read-write)
+            USR  = 0x004, // Access Control (0=supervisor, 1=user)
+            CWT  = 0x008, // Cache Mode (0=write-back, 1=write-through)
+            CD   = 0x010, // Cache Disable (0=cacheable, 1=non-cacheable)
+            CT   = 0x020, // Contiguous (0=non-contiguous, 1=contiguous)
+            IO   = 0x040, // Memory Mapped I/O (0=memory, 1=I/O)
+            SYS = (PRE | RW),
+            APP = (PRE | RW | USR),
+            EXEC  = 0x080,
+            KCODE = (PRE | EXEC),
+            KDATA = (PRE | RW),
+            ALL = (PRE | RW | EXEC),
         };
 
     public:
@@ -67,8 +71,8 @@ public:
 
 public:
     static unsigned int pages(unsigned int bytes) { return (bytes + sizeof(Page) - 1) / sizeof(Page); }
-    static unsigned int page_tables(unsigned int pages) { return (pages + PT_ENTRIES - 1) / PT_ENTRIES; }
-
+    static unsigned int page_tables(unsigned int pages) { return sizeof(Page) > sizeof(int) ? (pages + PT_ENTRIES - 1) / PT_ENTRIES : 0; } // merged
+    
     static unsigned int offset(const Log_Addr & addr) { return addr & (sizeof(Page) - 1); }
     static unsigned int indexes(const Log_Addr & addr) { return addr & ~(sizeof(Page) - 1); }
 
@@ -76,7 +80,7 @@ public:
     static unsigned int directory(const Log_Addr & addr) { return addr >> DIRECTORY_SHIFT; }
 
     static Log_Addr align_page(const Log_Addr & addr) { return (addr + sizeof(Page) - 1) & ~(sizeof(Page) - 1); }
-    static Log_Addr align_directory(const Log_Addr & addr) { return (addr + sizeof(Page) * sizeof(Page) - 1) &  ~(sizeof(Page) * sizeof(Page) - 1); }
+    static Log_Addr align_directory(const Log_Addr & addr) { return (addr + PT_ENTRIES * sizeof(Page) - 1) &  ~(PT_ENTRIES * sizeof(Page) - 1); } // merged
 };
 
 __END_SYS
diff --git a/include/architecture/rv32/rv32_cpu.h b/include/architecture/rv32/rv32_cpu.h
index 55a077e..1956a0a 100644
--- a/include/architecture/rv32/rv32_cpu.h
+++ b/include/architecture/rv32/rv32_cpu.h
@@ -27,24 +27,26 @@ public:
 
     // Control and Status Register (CSR) for machine mode
     // Status Register (mstatus)
+    typedef Reg32 Flags;
     enum {
         MIE             = 1 << 3,      // Machine Interrupts Enabled
         SIE             = 1 << 1,      // Supervisor Interrupts Enabled
         SPIE            = 1 << 5,      // Supervisor Previous Interrupts Enabled
         MPIE            = 1 << 7,      // Machine Previous Interrupts Enabled
-        MPP             = 3 << 11,     // Machine Previous Privilege
-        SPP             = 3 << 12,     // Supervisor Previous Privilege
+        MPP             = 3 << 11,     // Machine Previous Privilege=Machine
+        MPP_S           = 1 << 11,     // Machine Previous Privilege=Supervisor
+        // SPP             = 3 << 8,     // Supervisor Previous Privilege=Machine
+        SPP_S           = 1 << 8,       // Supervisor Previous Privilege=Supervisor
         MPRV            = 1 << 17,     // Memory Priviledge
-        TVM             = 1 << 20,     // Trap Virtual Memory //not allow MMU
-        MSTATUS_DEFAULTS= (MIE | MPIE | MPP)
+        TVM             = 1 << 20      // Trap Virtual Memory //not allow MMU
     };
 
     // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers (mie, mip, and mcause when interrupt bit is set)
     enum {
         SSI             = 1 << 1,   // Supervisor Software Interrupt
         MSI             = 1 << 3,   // Machine Software Interrupt
-        STI             = 1 << 5,   // Supervisor Software Interrupt
-        MTI             = 1 << 7,   // Machine Software Interrupt
+        STI             = 1 << 5,   // Supervisor Timer Interrupt
+        MTI             = 1 << 7,   // Machine Timer Interrupt
         SEI             = 1 << 9,   // Supervisor External Interrupt
         MEI             = 1 << 11   // Machine External Interrupt
     };
@@ -62,15 +64,16 @@ public:
         EXC_DWFAULT     = 7,    // Store/AMO access fault
         EXC_ENVU        = 8,    // Environment call from U-mode
         EXC_ENVS        = 9,    // Environment call from S-mode
-        EXC_ENVH        = 10,   // Environment call from H-mode
-        EXC_ENVM        = 11    // Environment call from M-m
+        // EXC_ENVH        = 10,   // Environment call from H-mode
+        EXC_ENVM        = 11    // Environment call from M-mode
     };
 
     // Context
     class Context
     {
     public:
-        Context(const Log_Addr & entry, const Log_Addr & exit): _pc(entry), _x1(exit) {
+        // Contexts are loaded with mret, which gets pc from mepc and updates some bits of mstatus, that's why _st is initialized with MPIE and MPP
+        Context(const Log_Addr & entry, const Log_Addr & exit): _st(SPIE | SPP_S), _pc(entry), _x1(exit) {
             if(Traits<Build>::hysterically_debugged || Traits<Thread>::trace_idle) {
                                                                         _x5 =  5;  _x6 =  6;  _x7 =  7;  _x8 =  8;  _x9 =  9;
                 _x10 = 10; _x11 = 11; _x12 = 12; _x13 = 13; _x14 = 14; _x15 = 15; _x16 = 16; _x17 = 17; _x18 = 18; _x19 = 19;
@@ -84,8 +87,9 @@ public:
 
         friend Debug & operator<<(Debug & db, const Context & c) {
             db << hex
-               << "{pc="   << c._pc
-               << ",sp="   << &c
+               << "{sp="   << &c
+               << ",st="   << c._st
+			   << ",pc="   << c._pc
                << ",lr="   << c._x1
                << ",x5="   << c._x5
                << ",x6="   << c._x6
@@ -119,6 +123,7 @@ public:
         }
 
     public:
+        Reg32  _st; // mstatus
         Reg32  _pc; // pc
     //  Reg32  _x0; // zero
         Reg32  _x1; // ra, ABI Link Register
@@ -164,24 +169,31 @@ public:
     CPU() {};
 
 public:
-    // Register access
+    static Reg32 flags() { return mstatus(); }
+    static void flags(const Flags st) { mstatus(st); }
+    
+    static Reg32 tp() {
+        Reg32 value;
+        ASM("mv %0, tp" : "=r"(value) :);
+        return value;
+    }
+
+    static void tp(const Reg32 & tp) { ASM("mv tp, %0" : : "r"(tp) :); }
+
     static Reg32 sp() {
         Reg32 value;
         ASM("mv %0, sp" : "=r"(value) :);
         return value;
     }
-    static void sp(const Reg32 & sp) {
-        ASM("mv sp, %0" : : "r"(sp) :);
-    }
+
+    static void sp(const Reg32 & sp) { ASM("mv sp, %0" : : "r"(sp) :); }
 
     static Reg32 fr() {
         Reg32 value;
         ASM("mv %0, x10" : "=r"(value)); // x10 is a0
         return value;
     }
-    static void fr(const Reg32 & fr) {
-        ASM("mv x10, %0" : : "r"(fr) :); // x10 is a0
-    }
+    static void fr(const Reg32 & fr) { ASM("mv x10, %0" : : "r"(fr) :); } // x10 is a0
 
     static Log_Addr ip() {
         Reg32 value;
@@ -242,14 +254,21 @@ public:
     static void halt() { ASM("wfi"); }
 
     static unsigned int id() {
+        return tp();
+        // return 0;
+    }
+
+    static unsigned int mhartid() {
         int id;
         ASM("csrr %0, mhartid" : "=r"(id) : : "memory", "cc");
         return id & 0x3;
     }
 
-    static void mstatus(Reg value) {
-        ASM("csrs mstatus, %0" : : "r"(value) : "cc");
-    }
+    //================ status
+
+    static void mstatus(Reg value) {       ASM("csrs mstatus, %0" : : "r"(value) : "cc"); }
+    static void mstatus_write(Reg value) { ASM("csrw mstatus, %0" : : "r"(value) : "cc"); }
+    static void mstatus_clear(Reg value) { ASM("csrc mstatus, %0" : : "r"(value) : "cc"); }
 
     static Reg mstatus() {
         Reg value;
@@ -257,37 +276,89 @@ public:
         return value;
     }
 
-    static void mie(Reg value) {
-        ASM("csrs mie, %0" : : "r"(value) : "cc");
+    static Reg sstatus() {
+        Reg value;
+        ASM("csrr %0, sstatus" : "=r"(value) : : );
+        return value;
     }
 
-    static void mie_clear(Reg value) {
-        ASM("csrc mie, %0" : : "r"(value) : "cc");
+    static Reg rdtime() {
+        Reg value;
+        ASM("rdtime %0" : "=r"(value) : : );
+        return value;
     }
 
+    //================ exceptions
+
+    static void mepc(Reg value) { ASM("csrw mepc, %0" : : "r"(value) : "cc"); }
+
+    static void mtvec(Reg value) { ASM("csrw mtvec, %0" : : "r"(value) : "cc"); }
+
+    static void mie(Reg value) {       ASM("csrs mie, %0" : : "r"(value) : "cc"); }
+    static void mie_clear(Reg value) { ASM("csrc mie, %0" : : "r"(value) : "cc"); }
+    static void mie_write(Reg value) { ASM("csrw mie, %0" : : "r"(value) : "cc"); }
+
     static Reg mie() {
         Reg value;
         ASM("csrr %0, mie" : "=r"(value) : : );
         return value;
     }
 
+    static void mip(Reg value) {       ASM("csrs mip, %0" : : "r"(value) : "cc"); }
+    static void mip_write(Reg value) { ASM("csrw mip, %0" : : "r"(value) : "cc"); }
+    static void mip_clear(Reg value) { ASM("csrc mip, %0" : : "r"(value) : "cc"); }
+
     static Reg mcause() {
         Reg value;
         ASM("csrr %0, mcause" : "=r"(value) : : );
         return value;
     }
 
+    static Reg scause() {
+        Reg value;
+        ASM("csrr %0, scause" : "=r"(value) : : );
+        return value;
+    }
+
+    //================ supervisor mode
+    
+    static void satp(Reg value) {       ASM("csrw satp, %0" : : "r"(value) : "cc"); }
+    
+    static void mideleg_write(Reg value) { ASM("csrw mideleg, %0" : : "r"(value) : "cc"); }
+    static void medeleg_write(Reg value) { ASM("csrw medeleg, %0" : : "r"(value) : "cc"); }
+
+    static void sstatus_write(Reg value) { ASM("csrw sstatus, %0" : : "r"(value) : "cc"); }
+
+    static void sie(Reg value) {       ASM("csrs sie, %0" : : "r"(value) : "cc"); }
+    static void sie_write(Reg value) { ASM("csrw sie, %0" : : "r"(value) : "cc"); }
+    static void sie_clear(Reg value) { ASM("csrc sie, %0" : : "r"(value) : "cc"); }
+
+    static Reg sie() {
+        Reg value;
+        ASM("csrr %0, sie" : "=r"(value) : : );
+        return value;
+    }
+
+    static void sip(Reg value) {       ASM("csrs sip, %0" : : "r"(value) : "cc"); }
+    static void sip_clear(Reg value) { ASM("csrc sip, %0" : : "r"(value) : "cc"); }
+
+    static void stvec_write(Reg value) { ASM("csrw stvec, %0" : : "r"(value) : "cc"); }
+
+    static void sepc_write(Reg value) { ASM("csrw sepc, %0" : : "r"(value) : "cc"); }
+
     static unsigned int cores() {
         return Traits<Build>::CPUS;
     }
 
     static void smp_barrier(unsigned long cores = cores()) { CPU_Common::smp_barrier<&finc>(cores, id()); }
 
-    static void int_enable() { ASM("csrs mstatus, %0" : :"r"(MSTATUS_DEFAULTS)); }
-    static void int_disable() { ASM("csrc mstatus, %0" : :"r"(MIE)); }
-    static bool int_enabled() { return (mstatus() & MIE) ; }
+    static void mmode_int_disable() { ASM("csrc mstatus, %0" : :"r"(MIE)); }
+    static void int_enable() {        ASM("csrs sstatus, %0" : :"r"(SIE)); }
+    static void int_disable() {       ASM("csrc sstatus, %0" : :"r"(SIE)); }
+    static bool int_enabled() { return (sstatus() & SIE) ; }
     static bool int_disabled() { return !int_enabled(); }
-
+    
+    //!SMODE: Where is this being used?
     static void csrr31() { ASM("csrr x31, mstatus" : : : "x31"); }
     static void csrw31() { ASM("csrs mstatus, x31" : : : "cc"); }
 
@@ -370,4 +441,4 @@ inline CPU::Reg16 ntohs(CPU::Reg16 v) { return CPU::ntohs(v); }
 
 __END_SYS
 
-#endif
+#endif
\ No newline at end of file
diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
index 1c809b2..4283306 100644
--- a/include/architecture/rv32/rv32_mmu.h
+++ b/include/architecture/rv32/rv32_mmu.h
@@ -12,43 +12,127 @@
 
 __BEGIN_SYS
 
-class MMU: public MMU_Common<0, 0, 0>
+class MMU: public MMU_Common<10, 10, 12>
 {
     friend class CPU;
-
+    friend class Setup_SifiveE;
 private:
-    typedef Grouping_List<unsigned int> List;
-
+    typedef Grouping_List<Frame> List;
     static const unsigned int PHY_MEM = Memory_Map::PHY_MEM;
 
 public:
     // Page Flags
-    typedef MMU_Common<0, 0, 0>::Flags RV32_Flags;
+    class RV32_Flags
+    {
+    public:
+        enum {
+            VALID    = 1 << 0,
+            READ     = 1 << 1,
+            WRITE    = 1 << 2,
+            EXEC     = 1 << 3,
+            USR      = 1 << 4,
+            ACCESSED = 1 << 6,
+            DIRTY    = 1 << 7,
+            SYS      = VALID | READ | WRITE | EXEC,
+            KCODE    = VALID | READ | EXEC,
+            KDATA    = VALID | READ | WRITE,
+            UCODE    = VALID | READ | EXEC | USR,
+            UDATA    = VALID | READ | WRITE | USR,
+        };
+
+        RV32_Flags() {}
+        RV32_Flags(const RV32_Flags & f): _flags(f) {}
+        RV32_Flags(unsigned int f): _flags(f) {}
+        RV32_Flags(const Flags & f): _flags(((f & Flags::PRE)  ? VALID : 0) | 
+                                            ((f & Flags::RW)   ? (READ | WRITE) : READ) |
+                                            ((f & Flags::USR)  ? USR : 0) | 
+                                            ((f & Flags::EXEC) ? EXEC : 0)) {}
+        operator unsigned int() const { return _flags; }
+
+    private:
+        unsigned int _flags;
+
+    };
 
     // Page_Table
-    class Page_Table {};
+    class Page_Table
+    {
+
+    friend class Setup_SifiveE;
+
+    private:
+        typedef unsigned int PTE;
+        PTE ptes[1024];
+
+    public:
+        Page_Table() {}
+
+        PTE & operator[](unsigned int i) { return ptes[i]; }
+
+        void map(const RV32_Flags & flags, int from, int to) {
+            Phy_Addr * addr = alloc(to - from);
+            // Try to alloc contiguous
+            if (addr) {
+                remap(addr, flags, from , to);
+            } else {
+                for(; from < to; from++){
+                    ptes[from] = ((alloc(1) >> 12) << 10) | flags ;
+                }
+            }
+        }
+
+        void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
+            for(int i = from; i < to; i++) {
+                unsigned int pte = phy_addr >> 12;
+                pte = pte << 10;
+                pte += ((i) << 10);
+                pte = pte | flags;
+                ptes[i] = pte;
+            }
+        }
+    };
 
     // Chunk (for Segment)
     class Chunk
     {
     public:
         Chunk() {}
-        Chunk(unsigned int bytes, Flags flags): _phy_addr(alloc(bytes)), _bytes(bytes), _flags(flags) {}
-        Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags): _phy_addr(phy_addr), _bytes(bytes), _flags(flags) {}
+        // Chunk(unsigned int bytes, Flags flags): _phy_addr(alloc(bytes)), _bytes(bytes), _flags(flags) {}
+        // Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags): _phy_addr(phy_addr), _bytes(bytes), _flags(flags) {}
+
+        Chunk(unsigned int bytes, const Flags & flags)
+        : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _bytes(bytes), _flags(RV32_Flags(flags)), _pt(calloc(_pts)) {
+            _pt->map(_flags, _from, _to);
+        }
 
-        ~Chunk() { free(_phy_addr, _bytes); }
+        // Chunk(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags)
+        // : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _flags(RV32_Flags(flags)), _pt(calloc(_pts)) {
+        //     _pt->remap(phy_addr, flags);
+        // }
 
-        unsigned int pts() const { return 0; }
-        Flags flags() const { return _flags; }
-        Page_Table * pt() const { return 0; }
+        // ~Chunk() { free(_phy_addr, _bytes); }
+        ~Chunk() {
+            for( ; _from < _to; _from++)
+                free((*static_cast<Page_Table *>(phy2log(_pt)))[_from]);
+            free(_pt, _pts);
+        }
+
+        unsigned int pts() const { return _pts; }
+        // Flags flags() const { return Flags(_flags); }
+        Page_Table * pt() const { return _pt; }
         unsigned int size() const { return _bytes; }
-        Phy_Addr phy_address() const { return _phy_addr; } // always CT
+        // Phy_Addr phy_address() const { return _phy_addr; } // always CT
         int resize(unsigned int amount) { return 0; } // no resize in CT
 
     private:
-        Phy_Addr _phy_addr;
+        unsigned int _from;
+        unsigned int _to;
+        unsigned int _pts;
+        // Phy_Addr _phy_addr;
         unsigned int _bytes;
         RV32_Flags _flags;
+        Page_Table * _pt;
+
     };
 
     // Page Directory
@@ -58,74 +142,82 @@ public:
     class Directory
     {
     public:
-        Directory() {}
-        Directory(Page_Directory * pd) {}
+        Directory() : _pd(calloc(1)) {
+            for(unsigned int i = 0; i < 544; i++){
+                (*_pd)[i] = (*_master)[i];
+            }
+        }
+        Directory(Page_Directory * pd) : _pd(pd) {}
+
+        Phy_Addr pd() const { return _pd; }
 
-        Page_Table * pd() const { return 0; }
+        void activate() {
+            CPU::satp((0x1 << 31) | (Phy_Addr)_pd >> 12);
+            ASM("sfence.vma");
+        }
 
-        void activate() {}
+        Log_Addr attach(const Chunk & chunk, unsigned int from = 0) {
+            for(unsigned int i = from; i < PD_ENTRIES - chunk.pts(); i++)
+                if(attach(i, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                    return i << DIRECTORY_SHIFT;
+            return false;
+        }
+
+        // Used to create non-relocatable segments such as code
+        Log_Addr attach(const Chunk & chunk, const Log_Addr & addr) {
+            unsigned int from = directory(addr);
+            if(!attach(from, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                return Log_Addr(false);
+            return from << DIRECTORY_SHIFT;
+        }
 
-        Log_Addr attach(const Chunk & chunk) { return chunk.phy_address(); }
-        Log_Addr attach(const Chunk & chunk, Log_Addr addr) { return (addr == chunk.phy_address())? addr : Log_Addr(false); }
         void detach(const Chunk & chunk) {}
         void detach(const Chunk & chunk, Log_Addr addr) {}
 
         Phy_Addr physical(Log_Addr addr) { return addr; }
-    };
 
-    // DMA_Buffer (straightforward without paging)
-    class DMA_Buffer: public Chunk
-    {
-    public:
-        DMA_Buffer(unsigned int s): Chunk(s, Flags::CT) {
-            db<MMU>(TRC) << "MMU::DMA_Buffer() => " << *this << endl;
+    private:
+        bool attach(unsigned int from, const Page_Table * pt, unsigned int n, RV32_Flags flags) {
+            for(unsigned int i = from; i < from + n; i++)
+                if((*static_cast<Page_Directory *>(phy2log(_pd)))[i]) // it has already been used
+                    return false;
+            for(unsigned int i = from; i < from + n; i++, pt++)
+                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = ((Phy_Addr(pt) >> 12) << 10) | flags; // is pt the correct value?
+            return true;
         }
 
-        Log_Addr log_address() const { return phy_address(); }
-
-        friend Debug & operator<<(Debug & db, const DMA_Buffer & b) {
-            db << "{phy=" << b.phy_address()
-               << ",log=" << b.log_address()
-               << ",size=" << b.size()
-               << ",flags=" << b.flags() << "}";
-            return db;
-        }
+    private:
+        Page_Directory * _pd;
     };
 
 public:
     MMU() {}
 
-    static Phy_Addr alloc(unsigned int bytes = 1) {
+    static Phy_Addr alloc(unsigned int frames = 1) {
         Phy_Addr phy(false);
-        if(bytes) {
-            List::Element * e = _free.search_decrementing(bytes);
+        if(frames) {
+            List::Element * e = _free.search_decrementing(frames);
             if(e)
-                phy = reinterpret_cast<unsigned int>(e->object()) + e->size();
+                phy = reinterpret_cast<unsigned int>(e->object()) + e->size() * PAGE_SIZE;
             else
                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
         }
-        db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+        db<MMU>(TRC) << "MMU::alloc(frames=" << frames << ") => " << phy << endl;
 
         return phy;
     };
 
-    static Phy_Addr calloc(unsigned int bytes = 1) {
-        Phy_Addr phy = alloc(bytes);
-        memset(phy, 0, bytes);
+    static Phy_Addr calloc(unsigned int frames = 1) {
+        Phy_Addr phy = alloc(frames);
+        memset(phy2log(phy), 0, frames*PAGE_SIZE);
         return phy;
     }
 
-    static void free(Phy_Addr addr, unsigned int n = 1) {
-        db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
-
-        // No unaligned addresses if the CPU doesn't support it
-        assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
+    static void free(Phy_Addr frame, unsigned int n = 1) {
+        db<MMU>(TRC) << "MMU::free(frame=" << frame << ",n=" << n << ")" << endl;
 
-        // Free blocks must be large enough to contain a list element
-        assert(n > sizeof (List::Element));
-
-        if(addr && n) {
-            List::Element * e = new (addr) List::Element(addr, n);
+        if(frame && n) {
+            List::Element * e = new (frame) List::Element(frame, n);
             List::Element * m1, * m2;
             _free.insert_merging(e, &m1, &m2);
         }
@@ -133,7 +225,7 @@ public:
 
     static unsigned int allocable() { return _free.head() ? _free.head()->size() : 0; }
 
-    static Page_Directory * volatile current() { return 0; }
+    static Page_Directory * volatile current() { return _master; }
 
     static Phy_Addr physical(Log_Addr addr) { return addr; }
 
@@ -143,8 +235,11 @@ public:
 private:
     static void init();
 
+    static Log_Addr phy2log(const Phy_Addr & phy) { return phy ; }
+
 private:
     static List _free;
+    static Page_Directory * _master;
 };
 
 __END_SYS
diff --git a/include/machine/display.h b/include/machine/display.h
index 03a873c..f3599c7 100644
--- a/include/machine/display.h
+++ b/include/machine/display.h
@@ -34,6 +34,7 @@ public:
 class Serial_Display: public Display_Common
 {
     friend class PC_Setup;
+    friend class Setup_SifiveE;
     friend class Serial_Keyboard;
     friend class Machine;
 
diff --git a/include/machine/riscv/riscv_ic.h b/include/machine/riscv/riscv_ic.h
index c4ba106..e305efc 100644
--- a/include/machine/riscv/riscv_ic.h
+++ b/include/machine/riscv/riscv_ic.h
@@ -16,7 +16,7 @@ public:
     static const unsigned int IRQS = 16;
 
     // Interrupts (mcause with interrupt = 1)
-    enum {
+    enum : unsigned int {
         IRQ_USR_SOFT            = 0,
         IRQ_SUP_SOFT            = 1,
         IRQ_MAC_SOFT            = 3,
@@ -26,7 +26,8 @@ public:
         IRQ_USR_EXT             = 8,
         IRQ_SUP_EXT             = 9,
         IRQ_MAC_EXT             = 11,
-        INTERRUPT               = 1 << 31
+        INTERRUPT               = 1UL << 31,
+        INT_MASK                = ~INTERRUPT
     };
 
     // Registers offsets from CLINT_BASE
@@ -43,6 +44,7 @@ public:
 class IC: private IC_Common, private CLINT
 {
     friend class Machine;
+    friend class Setup_SifiveE;
 
 private:
     typedef CPU::Reg Reg;
@@ -55,8 +57,8 @@ public:
 
     enum {
         HARD_INT        = CPU::EXCEPTIONS,
-        INT_SYS_TIMER   = HARD_INT + IRQ_MAC_TIMER,
-        INT_RESCHEDULER = HARD_INT + IRQ_MAC_SOFT, // An IPI is mapped to the machine with mcause set to IRQ_MAC_SOFT
+        INT_SYS_TIMER   = HARD_INT + IRQ_SUP_TIMER,
+        INT_RESCHEDULER = HARD_INT + IRQ_SUP_SOFT, // An IPI is mapped to the machine with mcause set to IRQ_MAC_SOFT
         INT_MASK        = CPU::Reg32(1 << 31) - 1
     };
 
@@ -76,7 +78,7 @@ public:
 
     static void enable() {
         db<IC>(TRC) << "IC::enable()" << endl;
-        CPU::mie(CPU::MSI | CPU::MTI | CPU::MEI);
+        CPU::sie(CPU::SSI | CPU::STI | CPU::SEI);
     }
 
     static void enable(Interrupt_Id i) {
@@ -88,7 +90,7 @@ public:
 
     static void disable() {
         db<IC>(TRC) << "IC::disable()" << endl;
-        CPU::mie_clear(CPU::MSI | CPU::MTI | CPU::MEI);
+        CPU::sie_clear(CPU::SSI | CPU::STI | CPU::SEI);
     }
 
     static void disable(Interrupt_Id i) {
@@ -100,7 +102,7 @@ public:
 
     static Interrupt_Id int_id() {
         // Id is retrieved from mcause even if mip has the equivalent bit up, because only mcause can tell if it is an interrupt or an exception
-        Reg id = CPU::mcause();
+        Reg id = CPU::scause();
         if(id & INTERRUPT)
             return (id & INT_MASK) + HARD_INT;
         else
@@ -131,7 +133,7 @@ private:
     static void exception(Interrupt_Id i);
 
     // Physical handler
-    static void entry();
+    [[gnu::naked, gnu::aligned(4)]] static void entry();
 
     static void init();
 
diff --git a/include/machine/riscv/riscv_info.h b/include/machine/riscv/riscv_info.h
deleted file mode 100644
index f50bdda..0000000
--- a/include/machine/riscv/riscv_info.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// EPOS RISC-V Common Run-Time System Information
-
-#ifndef __riscv_info_h
-#define __riscv_info_h
-
-#include <system/info.h>
-
-__BEGIN_SYS
-
-struct System_Info
-{
-private:
-    typedef unsigned int LAddr;
-    typedef unsigned int PAddr;
-    typedef unsigned int Size;
-
-public:
-    // The information we have at boot time (built by MKBI)
-    // Modifications to this map requires adjustments at MKBI
-    struct Boot_Map
-    {
-        volatile unsigned int n_cpus;     // Number of CPUs in SMPs
-        PAddr mem_base;                   // Memory base address
-        PAddr mem_top;                    // Memory top address
-        PAddr io_base;                    // I/O Memory base address
-        PAddr io_top;                     // I/O Memory top address
-        int node_id;                      // Local node id in SAN (-1 => RARP)
-        int space_x;                      // Spatial coordinates of a node (-1 => mobile)
-        int space_y;                      //
-        int space_z;                      //
-        unsigned char uuid[8];            // EPOS image Universally Unique Identifier
-        Size img_size;                    // Boot image size (in bytes)
-        Size setup_offset;                // Image offsets (-1 => not present)
-        Size init_offset;
-        Size system_offset;
-        Size application_offset;
-        Size extras_offset;
-    };
-
-    // Load Map (not used in this machine, but kept for architectural transparency)
-    struct Load_Map
-    {
-        bool  has_ext;
-        LAddr app_entry;
-        Size  app_segments;
-        LAddr app_code;
-        Size  app_code_size;
-        LAddr app_data;
-        LAddr app_stack;
-        LAddr app_heap;
-        Size  app_data_size;
-        PAddr app_extra;
-        Size  app_extra_size;
-    };
-
-public:
-    Boot_Map bm;
-    Load_Map lm;
-};
-
-__END_SYS
-
-#endif
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index 18cca96..2b50117 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -17,13 +17,16 @@ class Timer: private Timer_Common, private CLINT
     friend Machine;
     friend IC;
     friend class Init_System;
-
 protected:
+    friend class Setup_SifiveE; // Timer::config will be called during setup
     static const unsigned int CHANNELS = 2;
     static const unsigned int FREQUENCY = Traits<Timer>::FREQUENCY;
-
     typedef IC_Common::Interrupt_Id Interrupt_Id;
 
+    static void config(const Hertz & frequency) {
+        reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
+    }
+
 public:
     using Timer_Common::Tick;
     using Timer_Common::Handler;
@@ -72,10 +75,6 @@ public:
 private:
     static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
 
-    static void config(const Hertz & frequency) {
-        reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
-    }
-
     static void int_handler(Interrupt_Id i);
 
     static void init();
diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
index f50bdda..4f9f592 100644
--- a/include/machine/riscv/sifive_e/sifive_e_info.h
+++ b/include/machine/riscv/sifive_e/sifive_e_info.h
@@ -1,12 +1,31 @@
 // EPOS RISC-V Common Run-Time System Information
 
-#ifndef __riscv_info_h
-#define __riscv_info_h
+#ifndef __riscv_sifive_e_info_h
+#define __riscv_sifive_e_info_h
 
 #include <system/info.h>
 
 __BEGIN_SYS
 
+
+struct App_Load_Map
+{
+private:
+    typedef unsigned int LAddr;
+    typedef unsigned int PAddr;
+    typedef unsigned int Size;
+
+public:
+    LAddr app_entry;
+    Size  app_segments;
+    LAddr app_code;
+    Size  app_code_size;
+    LAddr app_data;
+    LAddr app_stack;
+    LAddr app_heap;
+    Size  app_data_size;
+};
+
 struct System_Info
 {
 private:
@@ -22,8 +41,8 @@ public:
         volatile unsigned int n_cpus;     // Number of CPUs in SMPs
         PAddr mem_base;                   // Memory base address
         PAddr mem_top;                    // Memory top address
-        PAddr io_base;                    // I/O Memory base address
-        PAddr io_top;                     // I/O Memory top address
+        PAddr mio_base;                   // Memory-mapped I/O base address
+        PAddr mio_top;                    // Memory-mapped I/O top address
         int node_id;                      // Local node id in SAN (-1 => RARP)
         int space_x;                      // Spatial coordinates of a node (-1 => mobile)
         int space_y;                      //
@@ -33,25 +52,51 @@ public:
         Size setup_offset;                // Image offsets (-1 => not present)
         Size init_offset;
         Size system_offset;
-        Size application_offset;
+        Size application_offset[8];
+        unsigned int n_apps;
         Size extras_offset;
     };
 
-    // Load Map (not used in this machine, but kept for architectural transparency)
     struct Load_Map
     {
+        bool  has_stp;
+        bool  has_ini;
+        bool  has_sys;
+        bool  has_app;
         bool  has_ext;
-        LAddr app_entry;
-        Size  app_segments;
-        LAddr app_code;
-        Size  app_code_size;
-        LAddr app_data;
-        LAddr app_stack;
-        LAddr app_heap;
-        Size  app_data_size;
+        LAddr stp_entry;
+        Size  stp_segments;
+        LAddr stp_code;
+        Size  stp_code_size;
+        LAddr stp_data;
+        Size  stp_data_size;
+        LAddr ini_entry;
+        Size  ini_segments;
+        LAddr ini_code;
+        Size  ini_code_size;
+        LAddr ini_data;
+        Size  ini_data_size;
+        LAddr sys_entry;
+        Size  sys_segments;
+        LAddr sys_code;
+        Size  sys_code_size;
+        LAddr sys_data;
+        Size  sys_data_size;
+        LAddr sys_stack;
+        Size  sys_stack_size;
+        App_Load_Map app[8];
+        // LAddr app_entry;
+        // Size  app_segments;
+        // LAddr app_code;
+        // Size  app_code_size;
+        // LAddr app_data;
+        // LAddr app_stack;
+        // LAddr app_heap;
+        // Size  app_data_size;
         PAddr app_extra;
         Size  app_extra_size;
     };
+    
 
 public:
     Boot_Map bm;
diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
index 3ea43bd..f36d8b7 100644
--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
@@ -11,7 +11,9 @@ __BEGIN_SYS
 
 struct Memory_Map
 {
-    // Physical Memory
+    static const unsigned int NOT_USED = Traits<Machine>::NOT_USED;
+    
+    // Memory Mapped stuff
     enum {
         TEST_BASE                   = 0x00100000, // SiFive test engine
         RTC_BASE                    = 0x00101000, // goldfish_rtc
@@ -24,11 +26,21 @@ struct Memory_Map
     // Physical Memory
     enum {
         MEM_BASE        = Traits<Machine>::MEM_BASE,
-        MEM_TOP         = Traits<Machine>::MEM_TOP
+        MEM_TOP         = Traits<Machine>::MEM_TOP,
+        MIO_BASE        = Traits<Machine>::MIO_BASE,
+        MIO_TOP         = Traits<Machine>::MIO_TOP,
+        BOOT_STACK      = Traits<Machine>::BOOT_STACK,
+        PAGE_TABLES     = Traits<Machine>::PAGE_TABLES,
+        MMODE_F         = Traits<Machine>::MMODE_F,
     };
 
     // Logical Address Space
     enum {
+        BOOT            = Traits<Machine>::BOOT,
+        IMAGE           = Traits<Machine>::IMAGE,
+        SETUP           = Traits<Machine>::SETUP,
+        INIT            = Traits<Machine>::INIT,
+
         APP_LOW         = Traits<Machine>::APP_LOW,
         APP_CODE        = Traits<Machine>::APP_CODE,
         APP_DATA        = Traits<Machine>::APP_DATA,
@@ -37,10 +49,10 @@ struct Memory_Map
         PHY_MEM         = Traits<Machine>::PHY_MEM,
         IO              = Traits<Machine>::IO_BASE,
 
-        SYS             = Traits<Machine>::NOT_USED,
-        SYS_INFO        = unsigned(-1),                 // Dynamically built during initialization.
-        SYS_CODE        = Traits<Machine>::NOT_USED,
-        SYS_DATA        = Traits<Machine>::NOT_USED,
+        SYS             = Traits<Machine>::SYS,
+        SYS_INFO        = Traits<Machine>::SYS_INFO,
+        SYS_CODE        = Traits<Machine>::SYS_CODE,
+        SYS_DATA        = Traits<Machine>::SYS_DATA,
         SYS_HEAP        = Traits<Machine>::NOT_USED,
         SYS_STACK       = Traits<Machine>::NOT_USED
     };
diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
index 9fa9ce7..07662bf 100644
--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
+++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
@@ -10,6 +10,7 @@ __BEGIN_SYS
 class Machine_Common;
 template<> struct Traits<Machine_Common>: public Traits<Build> {};
 
+//!ECALL: When will we allocate a kernel stack? We may repurpose boot_stack by not freeing it.
 template <> struct Traits<Machine>: public Traits<Machine_Common>
 {
     static const bool cpus_use_local_timer      = false;
@@ -20,33 +21,40 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
     // Boot Image
     static const unsigned int BOOT_LENGTH_MIN   = NOT_USED;
     static const unsigned int BOOT_LENGTH_MAX   = NOT_USED;
+    static const unsigned int BOOT_STACK        = 0x87ffffff;
 
     // Physical Memory
     static const unsigned int MEM_BASE          = 0x80000000;
-    static const unsigned int VECTOR_TABLE      = NOT_USED;
-    static const unsigned int PAGE_TABLES       = NOT_USED; // No paging MMU
     static const unsigned int MEM_TOP           = 0x87ffffff; // 128 MB
-    static const unsigned int BOOT_STACK        = 0x87ffffff;
+    static const unsigned int MIO_BASE          = 0x00000000;
+    static const unsigned int MIO_TOP           = 0x100081ff;
 
+    static const unsigned int VECTOR_TABLE      = NOT_USED;
+    static const unsigned int PAGE_TABLES       = 0x87ffffff + 1 - 16*1024 - ((1024+1)*4*1024); // 0x87BFB000
+    static const unsigned int SYS_INFO          = PAGE_TABLES - 4096; 
+    static const unsigned int MMODE_F           = SYS_INFO - 4096;
+   
     // Logical Memory Map
     static const unsigned int BOOT              = NOT_USED;
-    static const unsigned int SETUP             = NOT_USED;
-    static const unsigned int INIT              = NOT_USED;
-
-    static const unsigned int APP_LOW           = 0x80000000;
-    static const unsigned int APP_CODE          = 0x80000000;
-    static const unsigned int APP_DATA          = 0x80000000;
+    static const unsigned int IMAGE             = NOT_USED;
+    // static const unsigned int SETUP             = 0x80000000 + 0x78; // This controls whether an ELF file is generated for setup; boot + elf header
+    static const unsigned int SETUP             = 0x80000000;
+    static const unsigned int INIT              = 0x80200000;
+
+    static const unsigned int APP_LOW           = 0x88000000;
+    static const unsigned int APP_CODE          = 0x88000000;
+    static const unsigned int APP_DATA          = 0xffc00000;
     static const unsigned int APP_HIGH          = 0x87ffffff;
 
-    static const unsigned int PHY_MEM           = NOT_USED; // No paging MMU
-    static const unsigned int IO_BASE           = NOT_USED; // No paging MMU
-    static const unsigned int IO_TOP            = NOT_USED; // No paging MMU
+    static const unsigned int PHY_MEM           = NOT_USED;
+    static const unsigned int IO_BASE           = NOT_USED;
+    static const unsigned int IO_TOP            = NOT_USED;
 
-    static const unsigned int SYS               = NOT_USED; // No paging MMU
-    static const unsigned int SYS_CODE          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_DATA          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_HEAP          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_STACK         = NOT_USED; // No paging MMU
+    static const unsigned int SYS               = 0x80300000;
+    static const unsigned int SYS_CODE          = SYS;
+    static const unsigned int SYS_DATA          = 0x80400000;
+    static const unsigned int SYS_HEAP          = NOT_USED;
+    static const unsigned int SYS_STACK         = NOT_USED;
 
     // Default Sizes and Quantities
     static const unsigned int STACK_SIZE        = 16 * 1024;
@@ -60,6 +68,7 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
 template <> struct Traits<IC>: public Traits<Machine_Common>
 {
     static const bool debugged = hysterically_debugged;
+    static const bool enabled = true;
 
     static const unsigned int IRQS = 1024; // PLIC
     static const unsigned int INTS = 1056; // Exceptions + Software + Local + Timer + External
@@ -68,6 +77,7 @@ template <> struct Traits<IC>: public Traits<Machine_Common>
 template <> struct Traits<Timer>: public Traits<Machine_Common>
 {
     static const bool debugged = hysterically_debugged;
+    static const bool enabled = true;
 
     static const unsigned int UNITS = 1;
 
@@ -104,7 +114,7 @@ template<> struct Traits<Serial_Display>: public Traits<Machine_Common>
 
 template<> struct Traits<Scratchpad>: public Traits<Machine_Common>
 {
-    static const bool enabled = false;
+    static const bool enabled = true;
 };
 
 __END_SYS
diff --git a/include/memory.h b/include/memory.h
index b2f8be5..ed73b23 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -9,10 +9,6 @@ __BEGIN_SYS
 
 class Address_Space: private MMU::Directory
 {
-
-private:
-    using MMU::Directory::activate;
-
 public:
     typedef CPU::Phy_Addr Phy_Addr;
     typedef CPU::Log_Addr Log_Addr;
@@ -23,6 +19,7 @@ public:
     ~Address_Space();
 
     using MMU::Directory::pd;
+    using MMU::Directory::activate;
 
     Log_Addr attach(Segment * seg);
     Log_Addr attach(Segment * seg, const Log_Addr & addr);
@@ -43,8 +40,8 @@ public:
     typedef MMU::Flags Flags;
 
 public:
-    Segment(unsigned int bytes, const Color & color = Color::WHITE, const Flags & flags = Flags::APP);
-    Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
+    Segment(unsigned int bytes, const Flags & flags);
+    // Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
     ~Segment();
 
     unsigned int size() const;
diff --git a/include/process.h b/include/process.h
index 5978227..65a4f44 100644
--- a/include/process.h
+++ b/include/process.h
@@ -7,6 +7,7 @@
 #include <machine.h>
 #include <utility/queue.h>
 #include <utility/handler.h>
+#include <scheduler.h>
 
 extern "C" { void __exit(); }
 
@@ -16,12 +17,14 @@ class Thread
 {
     friend class Init_First;            // context->load()
     friend class Init_System;           // for init() on CPU != 0
+    friend class Scheduler<Thread>;     // for link()
     friend class Synchronizer_Common;   // for lock() and sleep()
     friend class Alarm;                 // for lock()
     friend class System;                // for init()
+    friend class IC;                    // for link() for priority ceiling
 
 protected:
-    static const bool preemptive = Traits<Thread>::preemptive;
+    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
     static const bool reboot = Traits<System>::reboot;
 
     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
@@ -40,26 +43,26 @@ public:
         FINISHING
     };
 
-    // Thread Priority
-    typedef unsigned int Priority;
+    // Thread Scheduling Criterion
+    typedef Traits<Thread>::Criterion Criterion;
     enum {
-        MAIN   = 0,
-        HIGH   = 1,
-        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 4,
-        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
-        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2
+        HIGH    = Criterion::HIGH,
+        NORMAL  = Criterion::NORMAL,
+        LOW     = Criterion::LOW,
+        MAIN    = Criterion::MAIN,
+        IDLE    = Criterion::IDLE
     };
 
     // Thread Queue
-    typedef Ordered_Queue<Thread, Priority> Queue;
+    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
 
     // Thread Configuration
     struct Configuration {
-        Configuration(const State & s = READY, const Priority & p = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), priority(p), stack_size(ss) {}
+        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+        : state(s), criterion(c), stack_size(ss) {}
 
         State state;
-        Priority priority;
+        Criterion criterion;
         unsigned int stack_size;
     };
 
@@ -78,8 +81,8 @@ public:
 
     int join();
     void pass();
-    void suspend() { suspend(false); }
-    void resume() { resume(false); }
+    void suspend();
+    void resume();
 
     static Thread * volatile self() { return running(); }
     static void yield();
@@ -89,15 +92,15 @@ protected:
     void constructor_prologue(unsigned int stack_size);
     void constructor_epilogue(const Log_Addr & entry, unsigned int stack_size);
 
-    static Thread * volatile running() { return _running; }
+    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
+    Queue::Element * link() { return &_link; }
+
+    static Thread * volatile running() { return _scheduler.chosen(); }
 
     static void lock() { CPU::int_disable(); }
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
 
-    void suspend(bool locked);
-    void resume(bool unpreemptive);
-
     static void sleep(Queue * q);
     static void wakeup(Queue * q);
     static void wakeup_all(Queue * q);
@@ -105,7 +108,7 @@ protected:
     static void reschedule();
     static void time_slicer(IC::Interrupt_Id interrupt);
 
-    static void dispatch(Thread * prev, Thread * next);
+    static void dispatch(Thread * prev, Thread * next, bool charge = true);
 
     static int idle();
 
@@ -119,14 +122,12 @@ protected:
     Queue * _waiting;
     Thread * volatile _joining;
     Queue::Element _link;
+    
+    volatile Task * _task;
 
     static volatile unsigned int _thread_count;
     static Scheduler_Timer * _timer;
-
-private:
-    static Thread * volatile _running;
-    static Queue _ready;
-    static Queue _suspended;
+    static Scheduler<Thread> _scheduler;
 };
 
 
@@ -141,7 +142,7 @@ inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
 
 template<typename ... Tn>
 inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.priority)
+: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
     constructor_prologue(conf.stack_size);
     _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
@@ -149,6 +150,22 @@ inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ...
 }
 
 
+// A Java-like Active Object
+class Active: public Thread
+{
+public:
+    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
+    virtual ~Active() {}
+
+    virtual int run() = 0;
+
+    void start() { resume(); }
+
+private:
+    static int entry(Active * runnable) { return runnable->run(); }
+};
+
+
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
@@ -162,6 +179,53 @@ private:
     Thread * _handler;
 };
 
+
+class Task
+{
+private:
+    static const bool multitask = Traits<System>::multitask;
+    typedef CPU::Log_Addr Log_Addr;
+
+public:
+    static volatile Task * _active;
+    Task(Segment * cs, Segment * ds)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    Task(Address_Space * as, Segment * cs, Segment * ds)
+    : _as(as), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    ~Task();
+    
+    static void activate(volatile Task * t) {
+        Task::_active = t;
+        t->_as->activate();
+    }
+
+    // void activate() {
+    //     Task::_active = this;
+    //     _as->activate();
+    // }
+    
+    Address_Space * address_space() const { return _as; }
+
+    Segment * code_segment() const { return _cs; }
+    Segment * data_segment() const { return _ds; }
+
+    Log_Addr code() const { return _code; }
+    Log_Addr data() const { return _data; }
+
+
+private:
+    Address_Space * _as;
+    Segment * _cs;
+    Segment * _ds;
+    Log_Addr _code;
+    Log_Addr _data;
+    
+};
+
 __END_SYS
 
 #endif
diff --git a/include/real-time.h b/include/real-time.h
new file mode 100644
index 0000000..4b2b0c8
--- /dev/null
+++ b/include/real-time.h
@@ -0,0 +1,138 @@
+// EPOS Real-time Declarations
+
+#ifndef __real_time_h
+#define __real_time_h
+
+#include <utility/handler.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+#include <time.h>
+#include <process.h>
+#include <synchronizer.h>
+
+__BEGIN_SYS
+
+// Aperiodic Thread
+typedef Thread Aperiodic_Thread;
+
+// Periodic threads are achieved by programming an alarm handler to invoke
+// p() on a control semaphore after each job (i.e. task activation). Base
+// threads are created in BEGINNING state, so the scheduler won't dispatch
+// them before the associate alarm and semaphore are created. The first job
+// is dispatched by resume() (thus the _state = SUSPENDED statement)
+
+// Periodic Thread
+class Periodic_Thread: public Thread
+{
+
+protected:
+    // Alarm Handler for periodic threads under static scheduling policies
+    class Static_Handler: public Semaphore_Handler
+    {
+    public:
+        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
+        ~Static_Handler() {}
+    };
+
+    // Alarm Handler for periodic threads under dynamic scheduling policies
+    class Dynamic_Handler: public Semaphore_Handler
+    {
+    public:
+        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
+        ~Dynamic_Handler() {}
+
+        void operator()() {
+            _thread->criterion().update();
+
+            Semaphore_Handler::operator()();
+        }
+
+    private:
+        Periodic_Thread * _thread;
+    };
+
+    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
+
+public:
+    // struct Configuration: public Thread::Configuration {
+    //     Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+    //     : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
+
+    //     Microsecond period;
+    //     Microsecond deadline;
+    //     Microsecond capacity;
+    //     Microsecond activation;
+    //     unsigned int times;
+    // };
+
+//!SMODE: 
+struct Configuration {
+        Configuration(const Microsecond & p, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = HIGH, unsigned int ss = STACK_SIZE)
+        : period(p), times(n), state(s), criterion(p, c), stack_size(ss) {}
+
+        Microsecond period;
+        unsigned int times;
+        State state;
+        Criterion criterion;
+        unsigned int stack_size;
+};
+
+public:
+    // template<typename ... Tn>
+    // Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+    // typedef Alarm::Tick Tick;
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Tick & t, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(t)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(t * Alarm::timer_period(), &_handler, INFINITE) { resume(); }
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+    //     if((conf.state == READY) || (conf.state == RUNNING)) {
+    //         _state = SUSPENDED;
+    //         resume();
+    //     } else
+    //         _state = conf.state;
+    // }
+
+    template<typename ... Tn>
+    Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    : Thread(Thread::Configuration(SUSPENDED, conf.criterion, conf.stack_size), entry, an ...),
+      _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+        if((conf.state == READY) || (conf.state == RUNNING)) {
+            _state = SUSPENDED;
+            resume();
+        } else
+            _state = conf.state;
+    }
+
+    const Microsecond & period() const { return _alarm.period(); }
+    void period(const Microsecond & p) { _alarm.period(p); }
+
+    static volatile bool wait_next() {
+        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
+
+        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
+
+        if(t->_alarm.times())
+            t->_semaphore.p();
+
+        return t->_alarm.times();
+    }
+
+protected:
+    Semaphore _semaphore;
+    Handler _handler;
+    Alarm _alarm;
+};
+
+typedef Periodic_Thread::Configuration RTConf;
+
+__END_SYS
+
+#endif
diff --git a/include/scheduler.h b/include/scheduler.h
new file mode 100644
index 0000000..8e8a512
--- /dev/null
+++ b/include/scheduler.h
@@ -0,0 +1,229 @@
+// EPOS Scheduler Component Declarations
+
+#ifndef __scheduler_h
+#define __scheduler_h
+
+#include <architecture/cpu.h>
+#include <architecture/pmu.h>
+#include <architecture/tsc.h>
+#include <utility/scheduling.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+
+__BEGIN_SYS
+
+// All scheduling criteria, or disciplines, must define operator int() with
+// the semantics of returning the desired order of a given object within the
+// scheduling list
+class Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+    friend class _SYS::Clerk<System>;         // for _statistics
+
+public:
+    // Priorities
+    enum : int {
+        MAIN   = 0,
+        HIGH   = 1,
+        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
+        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2,
+        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+    };
+
+    // Constructor helpers
+    enum : unsigned int {
+        SAME        = 0,
+        NOW         = 0,
+        UNKNOWN     = 0,
+        ANY         = -1U
+    };
+
+    // Policy types
+    enum : int {
+        PERIODIC    = HIGH,
+        APERIODIC   = NORMAL,
+        SPORADIC    = NORMAL
+    };
+
+    // Policy traits
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+    static const bool collecting = false;
+    static const bool charging = false;
+    static const bool awarding = false;
+    static const bool migrating = false;
+    static const bool track_idle = false;
+    static const bool task_wide = false;
+    static const bool cpu_wide = false;
+    static const bool system_wide = false;
+    static const unsigned int QUEUES = 1;
+
+    // Runtime Statistics (for policies that don't use any; thats why its a union)
+    union Statistics {
+        // Thread Execution Time
+        TSC::Time_Stamp thread_execution_time;  // accumulated thread execution time
+        TSC::Time_Stamp last_thread_dispatch;   // time stamp of last dispatch
+
+        // Deadline Miss count - Used By Clerk
+        Alarm * alarm_times;                    // pointer to RT_Thread private alarm (for monitoring purposes)
+        unsigned int finished_jobs;             // number of finished jobs given by the number of times alarm->p() was called for this thread
+        unsigned int missed_deadlines;          // number of missed deadlines given by the number of finished jobs (finished_jobs) minus the number of dispatched jobs (alarm_times->times)
+
+        // CPU Execution Time (capture ts)
+        static TSC::Time_Stamp _cpu_time[Traits<Build>::CPUS];              // accumulated CPU time in the current hyperperiod for each CPU
+        static TSC::Time_Stamp _last_dispatch_time[Traits<Build>::CPUS];    // time Stamp of last dispatch in each CPU
+        static TSC::Time_Stamp _last_activation_time;                       // global time stamp of the last heuristic activation
+    };
+
+protected:
+    Scheduling_Criterion_Common() {}
+
+public:
+    const Microsecond period() { return 0;}
+    void period(const Microsecond & p) {}
+
+    unsigned int queue() const { return 0; }
+    void queue(unsigned int q) {}
+
+    bool update() { return false; }
+
+    bool collect(bool end = false) { return false; }
+    bool charge(bool end = false) { return true; }
+    bool award(bool end = false) { return true; }
+
+    volatile Statistics & statistics() { return _statistics; }
+
+    static void init() {}
+
+protected:
+    Statistics _statistics;
+};
+
+// Priority (static and dynamic)
+class Priority: public Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+
+public:
+    template <typename ... Tn>
+    Priority(int p = NORMAL, Tn & ... an): _priority(p) {}
+
+    operator const volatile int() const volatile { return _priority; }
+
+protected:
+    volatile int _priority;
+};
+
+// Round-Robin
+class RR: public Priority
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    template <typename ... Tn>
+    RR(int p = NORMAL, Tn & ... an): Priority(p) {}
+};
+
+// First-Come, First-Served (FIFO)
+class FCFS: public Priority
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = false;
+
+public:
+    template <typename ... Tn>
+    FCFS(int p = NORMAL, Tn & ... an);
+};
+
+
+// Real-time Algorithms
+class Real_Time_Scheduler_Common: public Priority
+{
+protected:
+    Real_Time_Scheduler_Common(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {} // aperiodic
+    Real_Time_Scheduler_Common(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
+    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
+
+public:
+    const Microsecond period() { return _period; }
+    void period(const Microsecond & p) { _period = p; }
+
+public:
+    Microsecond _deadline;
+    Microsecond _period;
+    Microsecond _capacity;
+};
+
+// Rate Monotonic
+// class RM:public Real_Time_Scheduler_Common
+// {
+// public:
+//     static const bool timed = false;
+//     static const bool dynamic = false;
+//     static const bool preemptive = true;
+
+// public:
+//     RM(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+//     RM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+//     : Real_Time_Scheduler_Common(p ? p : d, d, p, c) {}
+// };
+
+//!SMODE:
+// Rate Monotonic
+class RM: public Priority
+{
+public:
+    static const bool preemptive = true;
+    static const bool timed = true;
+
+public:
+    // used for aperiodic threads
+    RM(int priority): Priority(priority) {}
+
+    // used for periodic threads
+    template <typename ... Tn>
+    RM(const Microsecond & period, int priority, Tn & ... an);
+};
+
+// Deadline Monotonic
+class DM: public Real_Time_Scheduler_Common
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    DM(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+    : Real_Time_Scheduler_Common(d, d, p, c) {}
+};
+
+// Earliest Deadline First
+class EDF: public Real_Time_Scheduler_Common
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = true;
+    static const bool preemptive = true;
+
+public:
+    EDF(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+    EDF(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY);
+
+    void update();
+};
+
+__END_SYS
+
+#endif
diff --git a/include/time.h b/include/time.h
index a024cb7..7e9e0e0 100644
--- a/include/time.h
+++ b/include/time.h
@@ -31,7 +31,9 @@ class Alarm
 {
     friend class System;                        // for init()
     friend class Alarm_Chronometer;             // for elapsed()
+    friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
     friend class FCFS;                          // for ticks() and elapsed()
+    friend class EDF;                           // for ticks() and elapsed()
 
 private:
     typedef Timer_Common::Tick Tick;
@@ -47,22 +49,22 @@ public:
     void reset();
 
     static Hertz frequency() { return _timer->frequency(); }
+    static Microsecond timer_period() { return 1000000 / frequency(); }
+    static volatile Tick & elapsed() { return _elapsed; }
+    static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
 
     static void delay(const Microsecond & time);
 
 private:
-    static void init();
-
-    static volatile Tick & elapsed() { return _elapsed; }
-
-    static Microsecond timer_period() { return 1000000 / frequency(); }
-    static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
+    unsigned int times() const { return _times; }
 
     static void lock();
     static void unlock();
 
     static void handler(IC::Interrupt_Id i);
 
+    static void init();
+
 private:
     Microsecond _time;
     Handler * _handler;
@@ -102,8 +104,6 @@ public:
     void stop() { lap(); }
 
     Microsecond read() { return ticks() * 1000000 / frequency(); }
-
-private:
     Time_Stamp ticks() {
         if(_start == 0)
             return 0;
@@ -112,6 +112,8 @@ private:
         return _stop - _start;
     }
 
+private:
+
 private:
     TSC tsc;
     Time_Stamp _start;
diff --git a/include/utility/elf.h b/include/utility/elf.h
index 0ef4158..df2b4b5 100644
--- a/include/utility/elf.h
+++ b/include/utility/elf.h
@@ -31,7 +31,7 @@ public:
         : seg(i)->p_align ? seg(i)->p_vaddr
         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
     }
-
+    
     int segment_size(int i) {
         return (i > segments()) ? -1 : (int)(
             ((seg(i)->p_offset % seg(i)->p_align)
diff --git a/include/utility/heap.h b/include/utility/heap.h
index f377454..57fd84b 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -18,6 +18,9 @@ protected:
 public:
     using Grouping_List<char>::empty;
     using Grouping_List<char>::size;
+    using Grouping_List<char>::search_decrementing;
+    using Grouping_List<char>::find_first;
+    using Grouping_List<char>::find_worst;
 
     Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
@@ -30,8 +33,7 @@ public:
     }
 
     void * alloc(unsigned int bytes) {
-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
         if(!bytes)
             return 0;
 
@@ -45,6 +47,8 @@ public:
         if(bytes < sizeof(Element))
             bytes = sizeof(Element);
 
+        db<Heaps>(TRC) << "First Fit: " << find_first(bytes) << endl;
+        db<Heaps>(TRC) << "Worst Fit: " << find_worst(bytes) << endl;
         Element * e = search_decrementing(bytes);
         if(!e) {
             out_of_memory();
@@ -65,7 +69,7 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
-        if(ptr && (bytes >= sizeof(Element))) {
+        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
diff --git a/include/utility/list.h b/include/utility/list.h
index ccc8954..eca1174 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -1348,7 +1348,7 @@ public:
 
     Element * search_size(unsigned int s) {
         Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
+        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
         else
             for(; e && (e->size() < s); e = e->next());
@@ -1381,7 +1381,7 @@ public:
         print_head();
         print_tail();
 
-        Element * e = search_size(s);
+        Element * e = find_worst(s);
         if(e) {
             e->shrink(s);
             _grouped_size -= s;
@@ -1392,6 +1392,33 @@ public:
         return e;
     }
 
+    // Used by Heap/Worst-Fit
+    // for empty lists, return 0
+    // for nonempty lists,
+    //      return 0 if there is no element big enough to fit s
+    //      return the element with biggest size otherwise
+    // precons:
+    //  1. s >= sizeof(Element) [s >= 16]
+    Element * find_worst(unsigned int s) {
+        Element * max = 0;
+        unsigned max_size = 0;
+        for(Element * e = head(); e; e = e->next()) {
+            if (e->size() > max_size) {
+                max_size = e->size();
+                max = e;
+            }
+        }
+
+        if (max_size < s)
+            return 0;
+
+        return max;
+    }
+
+    Element * find_first(unsigned int s) {
+        return search_size(s);
+    }
+
 private:
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
diff --git a/makedefs b/makedefs
index 21674d9..62deb60 100644
--- a/makedefs
+++ b/makedefs
@@ -86,6 +86,7 @@ MEM_SIZE                = $(shell $(BIN)/eposcfg MEM_SIZE_KB 2> /dev/null)
 BOOT_ADDR               = $(shell $(BIN)/eposcfg BOOT 2> /dev/null)
 SETUP_ADDR              = $(shell $(BIN)/eposcfg SETUP 2> /dev/null)
 INIT_ADDR               = $(shell $(BIN)/eposcfg INIT 2> /dev/null)
+MMODE_F                 = $(shell $(BIN)/eposcfg MMODE_F 2> /dev/null)
 SYS_CODE_ADDR           = $(shell $(BIN)/eposcfg SYS_CODE 2> /dev/null)
 SYS_DATA_ADDR           = $(shell $(BIN)/eposcfg SYS_DATA 2> /dev/null)
 UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g')
@@ -103,7 +104,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
 pc_AS_FLAGS		:= --32
 pc_LD_FLAGS		:= -m elf_i386
 pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
-pc_DEBUGGER		:= gdb
+pc_DEBUGGER		:= gdb -tui
 pc_FLASHER		:=
 pc_MAGIC		:= --nmagic
 pc_CODE_NAME		:= .init
@@ -114,7 +115,7 @@ ifeq ($(MMOD),realview_pbx)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -126,7 +127,7 @@ endif
 ifeq ($(MMOD),zynq)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -139,7 +140,7 @@ ifeq ($(MMOD),raspberry_pi3)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -149,7 +150,7 @@ cortex_IMG_SUFFIX	:= .bin
 endif
 
 ifeq ($(MMOD),lm3s811)
-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -162,7 +163,7 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),emote3)
-cortex_EMULATOR		= 
+cortex_EMULATOR		=
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -175,25 +176,26 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),sifive_e)
-riscv_CC_FLAGS          := -Wl, -mno-relax
-riscv_AS_FLAGS          := 
+riscv_CC_FLAGS          := -Wl, -mno-relax -march='rv32g'
+riscv_AS_FLAGS          :=
 riscv_LD_FLAGS          := --no-relax
-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_EMULATOR			= qemu-system-riscv32 -d int -D INTS -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --nmagic
-riscv_CODE_NAME := .init
-riscv_DATA_NAME :=
+riscv_CODE_NAME 		:= .init
+riscv_DATA_NAME 		:= .sdata
 riscv_IMG_SUFFIX        := .img
 endif
 
 ifeq ($(MMOD),sifive_u)
 riscv_CC_FLAGS          := -mcmodel=medany
-riscv_AS_FLAGS          := 
-riscv_LD_FLAGS          := 
-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_AS_FLAGS          :=
+riscv_LD_FLAGS          :=
+riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --omagic
 riscv_CODE_NAME := .init
 riscv_DATA_NAME :=
@@ -212,13 +214,13 @@ atmega_DATA_NAME	:= .data
 atmega_IMG_SUFFIX	:= .hex
 
 MACH_CC_FLAGS           := $($(MACH)_CC_FLAGS) -O -nostdinc -fno-stack-protector -fno-pie -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-address-of-packed-member
-MACH_CXX_FLAGS          := $($(MACH)_CC_FLAGS) -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit --no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-attribute-alias -Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member
+MACH_CXX_FLAGS          := $($(MACH)_CC_FLAGS) -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit --no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-attribute-alias -Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member -Wattributes
 MACH_AS_FLAGS           := $($(MACH)_AS_FLAGS)
 MACH_LD_FLAGS           := $($(MACH)_LD_FLAGS)
 MACH_CODE_NAME          := $($(MACH)_CODE_NAME)
 MACH_DATA_NAME          := $($(MACH)_DATA_NAME)
-MACH_EMULATOR           := $($(MACH)_EMULATOR)
-MACH_DEBUGGER           := $(TERM) $($(MACH)_DEBUGGER) -ex "target remote:1235" -ex "set confirm off"
+MACH_EMULATOR           := $(TERM) $($(MACH)_EMULATOR)
+MACH_DEBUGGER           := $(TERM) $($(MACH)_DEBUGGER) -ex "target remote:1236" -ex "set confirm off"
 MACH_FLASHER            := $($(MACH)_FLASHER)
 MACH_MAGIC              := $($(MACH)_MAGIC)
 MACH_IMGSUFF            := $($(MACH)_IMG_SUFFIX)
@@ -227,7 +229,7 @@ ifeq ($(DEBUG),1)
 MACH_CC_FLAGS		:= -g -feliminate-unused-debug-symbols $(MACH_CC_FLAGS)
 MACH_CXX_FLAGS          := -g -feliminate-unused-debug-symbols $(MACH_CXX_FLAGS)
 MACH_AS_FLAGS		:= -g $(MACH_AS_FLAGS)
-MACH_EMULATOR           := $(subst -m ,-gdb tcp::1235 -S -m ,$(MACH_EMULATOR))
+MACH_EMULATOR           := $(subst -m ,-gdb tcp::1236 -S -m ,$(MACH_EMULATOR))
 endif
 
 # Architecture specifics
@@ -251,10 +253,10 @@ TLD		:= gcc
 TLDFLAGS	:= -m32
 
 # Tools and flags to compile applications
-ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
@@ -306,7 +308,7 @@ OBJDUMPFLAGS	:=
 
 SHELL		:= bash
 
-STRIP		= $(COMP_PREFIX)strip -R .note -R .comment
+STRIP		= $(COMP_PREFIX)strip -R .note -R .comment --strip-debug
 
 TCPDUMP		:= tcpdump -tttttennvvvXXr
 
@@ -315,7 +317,7 @@ TEE		:= tee
 ifndef DISPLAY
 TERM        := sh -c
 else
-TERM        := xterm -e
+TERM        := konsole -e
 endif
 
 TOUCH		:= touch
@@ -360,8 +362,11 @@ lib%.o: lib%.cc
 (%.o): %.o
 		$(AR) $(ARFLAGS) $@ $^
 
+# %.img: %
+# 		$(MKBI) $@ $<
+
 %.img: %
-		$(MKBI) $@ $<
+		$(MKBI) $@  philosophers_dinner hello_usr
 
 %.hex: %
 		$(OBJCOPY) -I elf32-$(ARCH_ENDIANESS) -O ihex $< $<.tmp
diff --git a/makefile b/makefile
index a35fe1f..2a8e03b 100644
--- a/makefile
+++ b/makefile
@@ -2,7 +2,16 @@
 
 include makedefs
 
+ifndef APPS
 SUBDIRS	:= etc tools src app img
+else
+SUBDIRS := etc tools src
+export APPS
+ifndef APPLICATION
+export APPLICATION=$(word 1, $(APPS))
+endif
+endif
+
 
 all: FORCE
 ifndef APPLICATION
@@ -12,6 +21,9 @@ else
 endif
 
 all1: $(SUBDIRS)
+ifdef APPS
+	$(foreach app,$(APPS), (cd $(APP) && $(MAKE) APPLICATION=$(app));)
+endif
 
 $(SUBDIRS): FORCE
 		(cd $@ && $(MAKE))
@@ -23,6 +35,7 @@ else
 		$(MAKE) run1
 endif
 
+#!P2: needs fix
 run1: etc img/$(APPLICATION)$(MACH_IMGSUFF)
 		(cd img && $(MAKE) run1)
 		
@@ -36,7 +49,8 @@ else
 		$(MAKE) DEBUG=1 all1 debug1
 endif
 
-debug1: etc img/$(APPLICATION)$(MACH_IMGSUFF)
+debug1: FORCE
+		(cd img && $(MKBI) $(word 1, $(APPS)).img $(addprefix $(IMG)/,$(APPS)))
 		(cd img && $(MAKE) DEBUG=1 debug)
 
 flash: FORCE
diff --git a/src/api/alarm.cc b/src/api/alarm.cc
index 3352a3a..f01ee94 100644
--- a/src/api/alarm.cc
+++ b/src/api/alarm.cc
@@ -25,6 +25,7 @@ Alarm::Alarm(const Microsecond & time, Handler * handler, unsigned int times)
         _request.insert(&_link);
         unlock();
     } else {
+        assert(times == 1);
         unlock();
         (*handler)();
     }
@@ -120,6 +121,7 @@ void Alarm::handler(IC::Interrupt_Id i)
     }
 
     unlock();
+    // kout << "*";
 
     if(alarm) {
         db<Alarm>(TRC) << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
new file mode 100644
index 0000000..c0e3513
--- /dev/null
+++ b/src/api/scheduler.cc
@@ -0,0 +1,36 @@
+// EPOS CPU Scheduler Component Implementation
+
+#include <process.h>
+#include <time.h>
+
+__BEGIN_SYS
+
+// The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
+template <typename ... Tn>
+FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
+
+EDF::EDF(const Microsecond & d, const Microsecond & p, const Microsecond & c, unsigned int): Real_Time_Scheduler_Common(Alarm::ticks(d), Alarm::ticks(d), p, c) {}
+
+void EDF::update() {
+    if((_priority >= PERIODIC) && (_priority < APERIODIC))
+        _priority = Alarm::elapsed() + _deadline;
+}
+
+// Since the definition of FCFS above is only known to this unit, forcing its instantiation here so it gets emitted in scheduler.o for subsequent linking with other units is necessary.
+template FCFS::FCFS<>(int p);
+
+//!SMODE:
+template <typename ... Tn>
+RM::RM(const Microsecond & period, int priority, Tn & ... an) {
+    if(priority == HIGH) {
+        _priority = HIGH + Alarm::ticks(period);
+    }else {
+        _priority = priority;
+    }
+
+     db<Init>(TRC) << "_priority=" << _priority << endl;
+}
+
+template RM::RM<>(const Microsecond & period, int priority);
+
+__END_SYS
diff --git a/src/api/segment.cc b/src/api/segment.cc
index 9ae9b96..8ef60ff 100644
--- a/src/api/segment.cc
+++ b/src/api/segment.cc
@@ -5,19 +5,25 @@
 __BEGIN_SYS
 
 // Methods
-Segment::Segment(unsigned int bytes, const Color & color, const Flags & flags): Chunk(bytes, flags, color)
+Segment::Segment(unsigned int bytes, const Flags & flags): Chunk(bytes, flags)
 {
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",color=" << color << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
 }
 
 
-Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags | Flags::IO)
-// The MMU::IO flag signalizes the MMU that the attached memory shall
-// not be released when the chunk is deleted
-{
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
-}
+// Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags | Flags::IO)
+// // The MMU::IO flag signalizes the MMU that the attached memory shall
+// // not be released when the chunk is deleted
+// {
+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+// }
 
+// Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags)
+// // The MMU::IO flag signalizes the MMU that the attached memory shall
+// // not be released when the chunk is deleted
+// {
+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+// }
 
 Segment::~Segment()
 {
@@ -31,10 +37,10 @@ unsigned int Segment::size() const
 }
 
 
-Segment::Phy_Addr Segment::phy_address() const
-{
-    return Chunk::phy_address();
-}
+// Segment::Phy_Addr Segment::phy_address() const
+// {
+//     return Chunk::phy_address();
+// }
 
 
 int Segment::resize(int amount)
diff --git a/src/api/thread.cc b/src/api/thread.cc
index fdd0583..0813c90 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -11,20 +11,19 @@ __END_UTIL
 
 __BEGIN_SYS
 
-extern "C" { void __epos_app_entry(); }
-
 volatile unsigned int Thread::_thread_count;
+volatile Task * Task::_active;
 Scheduler_Timer * Thread::_timer;
+Scheduler<Thread> Thread::_scheduler;
 
-Thread* volatile Thread::_running;
-Thread::Queue Thread::_ready;
-Thread::Queue Thread::_suspended;
 
 void Thread::constructor_prologue(unsigned int stack_size)
 {
     lock();
-
+    
+    _task = Task::_active;
     _thread_count++;
+    _scheduler.insert(this);
 
     _stack = new (SYSTEM) char[stack_size];
 }
@@ -42,13 +41,8 @@ void Thread::constructor_epilogue(const Log_Addr & entry, unsigned int stack_siz
 
     assert((_state != WAITING) && (_state != FINISHING)); // Invalid states
 
-    switch(_state) {
-        case RUNNING: assert(entry == __epos_app_entry); break;
-        case READY: _ready.insert(&_link); break;
-        case SUSPENDED: _suspended.insert(&_link); break;
-        case WAITING: break;   // invalid state, for switch completion only
-        case FINISHING: break; // invalid state, for switch completion only
-    }
+    if((_state != READY) && (_state != RUNNING))
+        _scheduler.suspend(this);
 
     if(preemptive && (_state == READY) && (_link.rank() != IDLE))
         reschedule();
@@ -76,15 +70,18 @@ Thread::~Thread()
         exit(-1);
         break;
     case READY:
-        _ready.remove(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case SUSPENDED:
-        _suspended.remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case WAITING:
         _waiting->remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case FINISHING: // Already called exit()
@@ -100,6 +97,26 @@ Thread::~Thread()
 }
 
 
+void Thread::priority(const Priority & c)
+{
+    lock();
+
+    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+
+    _link.rank(Criterion(c));
+
+    if(_state != RUNNING) { // reorder the scheduling queue
+        _scheduler.remove(this);
+        _scheduler.insert(this);
+    }
+
+    if(preemptive)
+        reschedule();
+
+    unlock();
+}
+
+
 int Thread::join()
 {
     lock();
@@ -113,10 +130,18 @@ int Thread::join()
     assert(!_joining);
 
     if(_state != FINISHING) {
-        _joining = running();
-        _joining->suspend(true);
-    } else
-        unlock();
+        Thread * prev = running();
+
+        _joining = prev;
+        prev->_state = SUSPENDED;
+        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+
+        Thread * next = _scheduler.chosen();
+
+        dispatch(prev, next);
+    }
+
+    unlock();
 
     return *reinterpret_cast<int *>(_stack);
 }
@@ -128,56 +153,48 @@ void Thread::pass()
 
     db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
-
-    _ready.remove(this);
-    _state = RUNNING;
-    _running = this;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose(this);
 
-    dispatch(prev, this);
+    if(next)
+        dispatch(prev, next, false);
+    else
+        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
 
     unlock();
 }
 
 
-void Thread::suspend(bool locked)
+void Thread::suspend()
 {
-    if(!locked)
-        lock();
+    lock();
 
     db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    if(_running != this)
-        _ready.remove(this);
+    Thread * prev = running();
 
     _state = SUSPENDED;
-    _suspended.insert(&_link);
+    _scheduler.suspend(this);
 
-    if(_running == this) {
-        _running = _ready.remove()->object();
-        _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-        dispatch(this, _running);
-    }
+    dispatch(prev, next);
 
     unlock();
 }
 
 
-void Thread::resume(bool unpreemptive)
+void Thread::resume()
 {
     lock();
 
     db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
 
     if(_state == SUSPENDED) {
-        _suspended.remove(this);
         _state = READY;
-        _ready.insert(&_link);
+        _scheduler.resume(this);
 
-        if(preemptive && !unpreemptive)
+        if(preemptive)
             reschedule();
     } else
         db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
@@ -191,16 +208,12 @@ void Thread::yield()
 {
     lock();
 
-    db<Thread>(TRC) << "Thread::yield(running=" << _running << ")" << endl;
-
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
+    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose_another();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -212,23 +225,22 @@ void Thread::exit(int status)
 
     db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    Thread * prev = _running;
+    Thread * prev = running();
+    _scheduler.remove(prev);
     prev->_state = FINISHING;
     *reinterpret_cast<int *>(prev->_stack) = status;
 
     _thread_count--;
 
     if(prev->_joining) {
-        Thread * joining = prev->_joining;
+        prev->_joining->_state = READY;
+        _scheduler.resume(prev->_joining);
         prev->_joining = 0;
-        joining->resume(true);
-        lock();
     }
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.choose(); // at least idle will always be there
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -241,14 +253,14 @@ void Thread::sleep(Queue * q)
     assert(locked()); // locking handled by caller
 
     Thread * prev = running();
+    _scheduler.suspend(prev);
     prev->_state = WAITING;
     prev->_waiting = q;
     q->insert(&prev->_link);
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 }
 
 
@@ -262,7 +274,7 @@ void Thread::wakeup(Queue * q)
         Thread * t = q->remove()->object();
         t->_state = READY;
         t->_waiting = 0;
-        _ready.insert(&t->_link);
+        _scheduler.resume(t);
 
         if(preemptive)
             reschedule();
@@ -281,7 +293,7 @@ void Thread::wakeup_all(Queue * q)
             Thread * t = q->remove()->object();
             t->_state = READY;
             t->_waiting = 0;
-            _ready.insert(&t->_link);
+            _scheduler.resume(t);
         }
 
         if(preemptive)
@@ -292,25 +304,47 @@ void Thread::wakeup_all(Queue * q)
 
 void Thread::reschedule()
 {
-    yield();
-}
+    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
+        db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
+    assert(locked()); // locking handled by caller
+
+    Thread * prev = running();
+    Thread * next = _scheduler.choose();
+
+    dispatch(prev, next);
+}
 
 void Thread::time_slicer(IC::Interrupt_Id i)
 {
+    lock();
     reschedule();
+    unlock();
 }
 
 
-void Thread::dispatch(Thread * prev, Thread * next)
+void Thread::dispatch(Thread * prev, Thread * next, bool charge)
 {
+    // "next" is not in the scheduler's queue anymore. It's already "chosen"
+
+    if(charge) {
+        if(Criterion::timed)
+            _timer->restart();
+    }
+
     if(prev != next) {
-        assert(prev->_state != RUNNING);
-        assert(next->_state == RUNNING);
+        if(prev->_state == RUNNING)
+            prev->_state = READY;
+        next->_state = RUNNING;
 
         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
         db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
         db<Thread>(INF) << "next={" << next << ",ctx=" << *next->_context << "}" << endl;
+        
+        
+        if(prev->_task != next->_task){
+            Task::activate(next->_task);
+        }
 
         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
         // and necessary because of context switches, but here, we are locked() and
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index db05478..7ce6e89 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -1,9 +1,13 @@
 // EPOS Thread Initialization
 
+#include <utility/elf.h>
+#include <architecture/mmu.h>
 #include <machine/timer.h>
 #include <machine/ic.h>
 #include <system.h>
 #include <process.h>
+#include <memory.h>
+
 
 __BEGIN_SYS
 
@@ -12,12 +16,42 @@ extern "C" { void __epos_app_entry(); }
 void Thread::init()
 {
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
-
-    // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
-    // which will directly call main(). In this case, _init will have already been called,
-    // before Init_Application to construct MAIN's global objects.
-    Thread::_running = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
-
+    typedef int (Main)();
+    System_Info * si = System::info();
+    
+    if(Traits<System>::multitask) {
+        char * bi = reinterpret_cast<char*>(Memory_Map::MEM_BASE);
+        
+        for(unsigned i = 0; i < si->bm.n_apps; i++) {
+             // We need W permission to load the segment
+            Segment * code_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL);
+            Segment * data_seg = new (SYSTEM) Segment(64*4096, MMU::Flags::ALL);
+            Task * app_task =  new (SYSTEM) Task(code_seg, data_seg);
+            
+            db<Setup>(TRC) << "app_task = " << hex << app_task << endl;
+            Task::activate(app_task);
+            
+            if(si->lm.has_app) {
+                ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
+                db<Setup>(TRC) << "Setup_SifiveE::load_app()" << endl;
+                if(app_elf->load_segment(0) < 0) {
+                    db<Setup>(ERR) << "Application code segment was corrupted during INIT!" << endl;
+                    Machine::panic();
+                }
+                for(int i = 1; i < app_elf->segments(); i++)
+                    if(app_elf->load_segment(i) < 0) {
+                        db<Setup>(ERR) << "Application data segment was corrupted during INIT!" << endl;
+                        Machine::panic();
+                    }
+            }
+            
+            new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<Main *>(si->lm.app[i].app_entry));
+        }
+        
+        // We need to be in the AS of the first thread.
+        Task::activate(Thread::self()->_task);
+    }
+   
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
 
@@ -27,7 +61,7 @@ void Thread::init()
     // Letting reschedule() happen during thread creation is also harmless, since MAIN is
     // created first and dispatch won't replace it nor by itself neither by IDLE (which
     // has a lower priority)
-    if(preemptive)
+    if(Criterion::timed)
         _timer = new (SYSTEM) Scheduler_Timer(QUANTUM, time_slicer);
 
     // No more interrupts until we reach init_first
diff --git a/src/architecture/armv7/armv7_crtend.c b/src/architecture/armv7/armv7_crtend.c
index 84ae9b3..78a6b11 100644
--- a/src/architecture/armv7/armv7_crtend.c
+++ b/src/architecture/armv7/armv7_crtend.c
@@ -16,5 +16,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/ia32/ia32_crtend.c b/src/architecture/ia32/ia32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/ia32/ia32_crtend.c
+++ b/src/architecture/ia32/ia32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_cpu.cc b/src/architecture/rv32/rv32_cpu.cc
index 2e5830e..7773356 100644
--- a/src/architecture/rv32/rv32_cpu.cc
+++ b/src/architecture/rv32/rv32_cpu.cc
@@ -12,8 +12,10 @@ unsigned int CPU::_bus_clock;
 // Class methods
 void CPU::Context::save() volatile
 {
-    ASM("       la       x4,      pc            \n"
-        "       sw       x4, -116(sp)           \n"     // push pc
+    ASM("       csrr     gp,  sstatus           \n"
+        "       sw       gp, -120(sp)           \n"     // push sstatus
+        "       auipc    gp, 0                  \n" 
+        "       sw       gp, -116(sp)           \n"     // push pc
         "       sw       x1, -112(sp)           \n"     // push ra
         "       sw       x5, -108(sp)           \n"     // push x5-x31
         "       sw       x6, -104(sp)           \n"
@@ -43,17 +45,18 @@ void CPU::Context::save() volatile
         "       sw      x30,   -8(sp)           \n"
         "       sw      x31,   -4(sp)           \n");
 
-    ASM("       addi     sp, sp, -116           \n"                     // complete the pushes above by adjusting the SP
+    ASM("       addi     sp, sp, -120           \n"                     // complete the pushes above by adjusting the SP
         "       sw       sp, 0(%0)              \n" : : "r"(this));     // update the this pointer to match the context saved on the stack
 }
 
+// Context load does not verify if interrupts were previously enabled by the Context's constructor
+// We are setting sstatus to SPP_S | SPIE, therefore, interrupts will be enabled only after sret
 void CPU::Context::load() const volatile
 {
     ASM("       mv      sp, %0                  \n"                     // load the stack pointer with the this pointer
-        "       addi    sp, sp, 116             \n" : : "r"(this));     // adjust the stack pointer to match the subsequent series of pops
+        "       addi    sp, sp, 120             \n" : : "r"(this));     // adjust the stack pointer to match the subsequent series of pops
 
-    ASM("       lw       x4, -116(sp)           \n"     // pop pc
-        "       lw       x1, -112(sp)           \n"     // pop ra
+    ASM("       lw       x1, -112(sp)           \n"     // pop ra
         "       lw       x5, -108(sp)           \n"     // pop x5-x31
         "       lw       x6, -104(sp)           \n"
         "       lw       x7, -100(sp)           \n"
@@ -81,14 +84,20 @@ void CPU::Context::load() const volatile
         "       lw      x29,  -12(sp)           \n"
         "       lw      x30,   -8(sp)           \n"
         "       lw      x31,   -4(sp)           \n"
-        "       jalr     x0,     (x4)           \n");   // jump to pc stored in x4 (jalr with x0 is equivalent to jr)
+        "       lw       gp, -120(sp)           \n"     // pop sstatus
+        "       csrs    sstatus,   gp           \n"     // set sstatus for sret
+        "       lw       gp, -116(sp)           \n"     // pop pc
+        "       csrw     sepc,     gp           \n"     // move pc to sepc for sret
+        "       sret                            \n");
 }
 
+// NOTE:
+// during the first time switch context is called for a thread, the stack may be dirty
+// what will set the registers with random values, is this a problem?
 void CPU::switch_context(Context ** o, Context * n)
 {   
     // Push the context into the stack and update "o"
-    ASM("       la       x4,    .ret            \n"     // get the return address in a temporary
-        "       sw       x4, -116(sp)           \n"     // push the return address as pc
+    ASM("       sw       x1, -116(sp)           \n"     // push the return address as pc
         "       sw       x1, -112(sp)           \n"     // push ra
         "       sw       x5, -108(sp)           \n"     // push x5-x31
         "       sw       x6, -104(sp)           \n"
@@ -117,13 +126,18 @@ void CPU::switch_context(Context ** o, Context * n)
         "       sw      x29,  -12(sp)           \n"
         "       sw      x30,   -8(sp)           \n"
         "       sw      x31,   -4(sp)           \n"
-        "       addi     sp,      sp,   -116    \n"     // complete the pushes above by adjusting the SP
+        "       csrr    x31,  sstatus           \n"     // get mstatus
+        "       sw      x31, -120(sp)           \n"     // push sstatus
+        "       addi     sp,      sp,   -120    \n"     // complete the pushes above by adjusting the SP
         "       sw       sp,    0(a0)           \n");   // update Context * volatile * o
+        
+    
 
     // Set the stack pointer to "n" and pop the context from the stack
     ASM("       mv       sp,      a1            \n"     // get Context * volatile n into SP
-        "       addi     sp,      sp,    116    \n"     // adjust stack pointer as part of the subsequent pops
-        "       lw       x4, -116(sp)           \n"     // pop pc to a temporary
+        "       addi     sp,      sp,    120    \n"     // adjust stack pointer as part of the subsequent pops
+        "       lw      x31, -116(sp)           \n"     // pop pc to a temporary
+        "       csrw    sepc, x31               \n"
         "       lw       x1, -112(sp)           \n"     // pop ra
         "       lw       x5, -108(sp)           \n"     // pop x5-x31
         "       lw       x6, -104(sp)           \n"
@@ -150,10 +164,15 @@ void CPU::switch_context(Context ** o, Context * n)
         "       lw      x27,  -20(sp)           \n"
         "       lw      x28,  -16(sp)           \n"
         "       lw      x29,  -12(sp)           \n"
+        "       lw      x31, -120(sp)           \n"     // pop sstatus
+        // As we are not handling an interrupt, we need to manually configure SPP_S to avoid
+        // going to user mode.
+        "       li      x30, 0b1 << 8           \n"
+        "       or      x31, x31, x30           \n"   
+        "       csrw     sstatus, x31           \n"
         "       lw      x30,   -8(sp)           \n"
         "       lw      x31,   -4(sp)           \n"
-        "       jalr     x0,     (x4)           \n"     // return (for the thread entering the CPU)
-        ".ret:  jalr     x0,     (x1)           \n");   // return (for the thread leaving the CPU)
+        "       sret                            \n");
 }
 
 __END_SYS
diff --git a/src/architecture/rv32/rv32_crt0.S b/src/architecture/rv32/rv32_crt0.S
index 22159d3..3c53ac9 100644
--- a/src/architecture/rv32/rv32_crt0.S
+++ b/src/architecture/rv32/rv32_crt0.S
@@ -10,19 +10,6 @@
 _start:
         // Temporary stack(s) for INIT are created and configure by SETUP
 
-        // Only hart (core) 0 cleans cache
-        csrr    t0, mhartid
-        bnez    t0, 2f
-
-        // Set all bytes in the BSS section to zero.
-        la      a0, __bss_start
-        la      a1, _end
-        bgeu    a0, a1, 2f
-1:
-        sw      zero, (a0)
-        addi    a0, a0, 4
-        bltu    a0, a1, 1b
-2:
         // Call _init
         call      _init
 
diff --git a/src/architecture/rv32/rv32_crtend.c b/src/architecture/rv32/rv32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv32/rv32_crtend.c
+++ b/src/architecture/rv32/rv32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_mmu.cc b/src/architecture/rv32/rv32_mmu.cc
index 1008524..fa3a7d7 100644
--- a/src/architecture/rv32/rv32_mmu.cc
+++ b/src/architecture/rv32/rv32_mmu.cc
@@ -6,5 +6,6 @@ __BEGIN_SYS
 
 // Class attributes
 MMU::List MMU::_free;
+MMU::Page_Directory * MMU::_master;
 
 __END_SYS
diff --git a/src/architecture/rv32/rv32_mmu_init.cc b/src/architecture/rv32/rv32_mmu_init.cc
index 127200c..fcad04e 100644
--- a/src/architecture/rv32/rv32_mmu_init.cc
+++ b/src/architecture/rv32/rv32_mmu_init.cc
@@ -1,26 +1,30 @@
 // EPOS RISC-V 32 MMU Mediator Initialization
 
 #include <architecture/mmu.h>
-
-extern "C" void * _edata;
-extern "C" void * __bss_start;
-extern "C" void * _end;
+#include <system.h>
 
 __BEGIN_SYS
 
 void MMU::init()
 {
-    db<Init, MMU>(TRC) << "MMU::init()" << endl;
-
-    db<Init, MMU>(INF) << "MMU::init::dat.e=" << &_edata << ",bss.b=" << &__bss_start << ",bss.e=" << &_end << endl;
-
     // For machines that do not feature a real MMU, frame size = 1 byte
     // Allocations (using Grouping_List<Frame>::search_decrementing() start from the end
     // To preserve the BOOT stacks until the end of INIT, the free memory list initialization is split in two sections
     // with allocations (from the end) of the first section taking place first
-    free(&_end, pages(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS - reinterpret_cast<unsigned int>(&_end)));
+    db<Init, MMU>(TRC) << "MMU::init()" << endl;
+
+    System_Info * si = System::info();
+    unsigned sys_data_end = si->lm.sys_data + si->lm.sys_data_size + 1;
+    MMU::_master = reinterpret_cast<Page_Directory*>(Memory_Map::PAGE_TABLES);
+
+    db<Init, MMU>(TRC) << "sys_data= " << si->lm.sys_data << ", begin_free= " << sys_data_end << endl; 
+
+    // Worst-Fit guarantees this will work
+    free(align_page(sys_data_end), pages(Memory_Map::MMODE_F - align_page(sys_data_end))); // [align_page(&_end), 0x87bf9000]
     free(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS, pages(Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS));
+    
+    // Free init/setup memory
+    free(Memory_Map::MEM_BASE, pages(Memory_Map::SYS - Memory_Map::MEM_BASE));
 }
 
-__END_SYS
-
+__END_SYS
\ No newline at end of file
diff --git a/src/architecture/rv64/rv64_crtend.c b/src/architecture/rv64/rv64_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv64/rv64_crtend.c
+++ b/src/architecture/rv64/rv64_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/init/init_application.cc b/src/init/init_application.cc
index c3c4b15..52bb7f5 100644
--- a/src/init/init_application.cc
+++ b/src/init/init_application.cc
@@ -5,7 +5,7 @@
 #include <machine.h>
 #include <system.h>
 
-extern "C" { char _end; } // defined by GCC
+extern "C" char _end; // defined by GCC
 
 __BEGIN_SYS
 
@@ -22,13 +22,11 @@ public:
         // Initialize Application's heap
         db<Init>(INF) << "Initializing application's heap: " << endl;
         if(Traits<System>::multiheap) { // heap in data segment arranged by SETUP
-            char * heap = MMU::align_page(&_end);
-            if(Traits<Build>::MODE != Traits<Build>::KERNEL) // if not a kernel, then use the stack allocated by SETUP, otherwise make that part of the heap
-                heap += MMU::align_page(Traits<Application>::STACK_SIZE);
-            Application::_heap = new (&Application::_preheap[0]) Heap(heap, HEAP_SIZE);
-        } else
+            Application::_heap = new (&Application::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+        } else {
             for(unsigned int frames = MMU::allocable(); frames; frames = MMU::allocable())
                 System::_heap->free(MMU::alloc(frames), frames * sizeof(MMU::Page));
+        }
         db<Init>(INF) << "done!" << endl;
     }
 };
diff --git a/src/init/init_first.cc b/src/init/init_first.cc
index cef9299..ecbbe4a 100644
--- a/src/init/init_first.cc
+++ b/src/init/init_first.cc
@@ -18,13 +18,17 @@ public:
 
         db<Init>(INF) << "INIT ends here!" << endl;
 
-        db<Init, Thread>(INF) << "Dispatching the first thread: " << Thread::running() << endl;
+        // Thread::self() and Task::self() can be safely called after the construction of MAIN
+        // even if no reschedule() was called (running is set by the Scheduler at each insert())
+        Thread * first = Thread::self();
+
+        db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
 
         // Interrupts have been disable at Thread::init() and will be reenabled by CPU::Context::load()
         // but we first reset the timer to avoid getting a time interrupt during load()
-        Timer::reset();
-        CPU::int_enable();
-        Thread::running()->_context->load();
+        if (Traits<Timer>::enabled)
+            Timer::reset();
+        first->_context->load();
     }
 };
 
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index d3c373f..bc19699 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -6,6 +6,8 @@
 #include <system.h>
 #include <process.h>
 
+extern "C" void _int_entry();
+
 __BEGIN_SYS
 
 class Init_System
@@ -17,6 +19,8 @@ public:
     Init_System() {
         db<Init>(TRC) << "Init_System()" << endl;
 
+        Machine::pre_init(System::info());
+
         // Initialize the processor
         db<Init>(INF) << "Initializing the CPU: " << endl;
         CPU::init();
@@ -24,12 +28,7 @@ public:
 
         // Initialize System's heap
         db<Init>(INF) << "Initializing system's heap: " << endl;
-        if(Traits<System>::multiheap) {
-            Segment * tmp = reinterpret_cast<Segment *>(&System::_preheap[0]);
-            System::_heap_segment = new (tmp) Segment(HEAP_SIZE, WHITE, Segment::Flags::SYS);
-            System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
-        } else
-            System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+        System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
         db<Init>(INF) << "done!" << endl;
 
         // Initialize the machine
diff --git a/src/machine/riscv/riscv_ic.cc b/src/machine/riscv/riscv_ic.cc
index 96a53c3..35362cc 100644
--- a/src/machine/riscv/riscv_ic.cc
+++ b/src/machine/riscv/riscv_ic.cc
@@ -3,21 +3,21 @@
 #include <machine/machine.h>
 #include <machine/ic.h>
 
-extern "C" { void _int_entry() __attribute__ ((alias("_ZN4EPOS1S2IC5entryEv"))); }
-
 __BEGIN_SYS
 
+extern "C" { [[gnu::alias("_ZN4EPOS1S2IC5entryEv"), gnu::nothrow]] void _int_entry(); }
+
 // Class attributes
 IC::Interrupt_Handler IC::_int_vector[IC::INTS];
 
 // Class methods
 void IC::entry()
 {
-    // Handle interrupts in machine mode
+    // Handle interrupts in supervisor mode
     ASM("        .align 4                                               \n"
         "                                                               \n"
         "# Save context                                                 \n"
-        "        addi        sp,     sp,   -140                         \n"          // 32 regs of 4 bytes each = 128 Bytes
+        "        addi        sp,     sp,   -136                         \n"          // 32 regs of 4 bytes each = 128 Bytes
         "        sw          x1,   4(sp)                                \n"
         "        sw          x2,   8(sp)                                \n"
         "        sw          x3,  12(sp)                                \n"
@@ -49,12 +49,10 @@ void IC::entry()
         "        sw         x29, 116(sp)                                \n"
         "        sw         x30, 120(sp)                                \n"
         "        sw         x31, 124(sp)                                \n"
-        "        csrr       x31, mie                                    \n"
+        "        csrr       x31, sstatus                                \n"
         "        sw         x31, 128(sp)                                \n"
-        "        csrr       x31, mstatus                                \n"
+        "        csrr       x31, sepc                                   \n"
         "        sw         x31, 132(sp)                                \n"
-        "        csrr       x31, mepc                                   \n"
-        "        sw         x31, 136(sp)                                \n"
         "        la          ra, .restore                               \n" // Set LR to restore context before returning
         "        j          %0                                          \n"
         "                                                               \n"
@@ -90,15 +88,13 @@ void IC::entry()
         "        lw         x28, 112(sp)                                \n"
         "        lw         x29, 116(sp)                                \n"
         "        lw         x30, 120(sp)                                \n"
-        "        lw         x31, 124(sp)                                \n"
         "        lw         x31, 128(sp)                                \n"
-        "        csrs       mie, x31                                    \n"
+        "        csrw   sstatus, x31                                    \n"
         "        lw         x31, 132(sp)                                \n"
-        "        csrs   mstatus, x31                                    \n"
-        "        lw         x31, 136(sp)                                \n"
-        "        csrw      mepc, x31                                    \n"
-        "        addi        sp, sp,    140                             \n"
-        "        mret                                                   \n" : : "i"(&dispatch));
+        "        csrw      sepc, x31                                    \n"
+        "        lw         x31, 124(sp)                                \n"
+        "        addi        sp, sp,    136                             \n"
+        "        sret                                                   \n" : : "i"(&dispatch));
 }
 
 void IC::dispatch()
@@ -108,8 +104,8 @@ void IC::dispatch()
     if((id != INT_SYS_TIMER) || Traits<IC>::hysterically_debugged)
         db<IC>(TRC) << "IC::dispatch(i=" << id << ")" << endl;
 
-    if(id == INT_RESCHEDULER)
-        IC::ipi_eoi(id);
+    if(id == INT_SYS_TIMER)
+        CPU::sie_clear(CPU::STI);
 
     _int_vector[id](id);
 }
@@ -125,17 +121,13 @@ void IC::int_not(Interrupt_Id id)
 
 void IC::exception(Interrupt_Id id)
 {
-    CPU::Reg mstatus = CPU::mstatus();
-    CPU::Reg mcause = CPU::mcause();
+    CPU::Reg sstatus = CPU::sstatus();
+    CPU::Reg scause = CPU::scause();
     CPU::Reg mhartid = CPU::id();
-    CPU::Reg mepc;
-    ASM("csrr %0, mepc" : "=r"(mepc) : :);
     CPU::Reg sepc;
     ASM("csrr %0, sepc" : "=r"(sepc) : :);
-    CPU::Reg mtval;
-    ASM("csrr %0, mtval" : "=r"(mtval) : :);
 
-    db<IC>(WRN) << "IC::Exception(" << id << ") => {" << hex << "mstatus=" << mstatus << ",mcause=" << mcause << ",mhartid=" << mhartid << ",mepc=" << hex << mepc << ",sepc=" << sepc << ",mtval=" << mtval << "}" << dec;
+    db<IC>(WRN) << "IC::Exception(" << id << ") => {" << hex << "sstatus=" << sstatus << ",scause=" << scause << ",mhartid=" << mhartid << ",sepc=" << sepc  << "}" << dec;
 
     switch(id) {
         case 0: // unaligned Instruction
diff --git a/src/machine/riscv/riscv_ic_init.cc b/src/machine/riscv/riscv_ic_init.cc
index 8904a70..0422e41 100644
--- a/src/machine/riscv/riscv_ic_init.cc
+++ b/src/machine/riscv/riscv_ic_init.cc
@@ -4,6 +4,8 @@
 #include <machine/ic.h>
 #include <machine/timer.h>
 
+extern "C" void _int_entry();
+
 __BEGIN_SYS
 
 // Class methods
@@ -11,9 +13,9 @@ void IC::init()
 {
     db<Init, IC>(TRC) << "IC::init()" << endl;
 
-    CPU::int_disable(); // will be reenabled at Thread::init() by Context::load()
-
-    disable(); // will be enabled on demand as handlers are registered
+    // CPU::int_disable();
+    // Will be enabled on demand as handlers are registered
+    disable();
 
     // Set all exception handlers to exception()
     for(Interrupt_Id i = 0; i < CPU::EXCEPTIONS; i++)
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index 1e5be41..859442f 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -6,21 +6,8 @@ __BEGIN_SYS
 
 void Machine::pre_init(System_Info * si)
 {
-    if(CPU::id() == 0)
-        Display::init();
-
-    db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
-
-    if(CPU::id() == 0) {
-        if(Traits<IC>::enabled) {
-            IC::init();
-
-            // Wake up remaining CPUs
-            // si->bm.n_cpus = Traits<Build>::CPUS;
-            if(Traits<System>::multicore)
-                smp_barrier_init(Traits<Build>::CPUS);
-        }
-    }
+    CPU::stvec_write((unsigned)&IC::entry & 0xfffffffc);
+    IC::init();
 }
 
 void Machine::init()
diff --git a/src/machine/riscv/riscv_timer.cc b/src/machine/riscv/riscv_timer.cc
index 1773715..fa57b41 100644
--- a/src/machine/riscv/riscv_timer.cc
+++ b/src/machine/riscv/riscv_timer.cc
@@ -11,6 +11,7 @@ Timer * Timer::_channels[CHANNELS];
 // Class methods
 void Timer::int_handler(Interrupt_Id i)
 {
+    // kout << "ESTOU DE SACANAGEM" << endl;
     config(FREQUENCY);
     if(_channels[SCHEDULER] && (--_channels[SCHEDULER]->_current[CPU::id()] <= 0)) {
         _channels[SCHEDULER]->_current[CPU::id()] = _channels[SCHEDULER]->_initial;
diff --git a/src/machine/riscv/riscv_timer_init.cc b/src/machine/riscv/riscv_timer_init.cc
index 6013906..c634bc7 100644
--- a/src/machine/riscv/riscv_timer_init.cc
+++ b/src/machine/riscv/riscv_timer_init.cc
@@ -9,6 +9,7 @@ __BEGIN_SYS
 void Timer::init()
 {
     db<Init, Timer>(TRC) << "Timer::init()" << endl;
+    db<Init, Timer>(TRC) << "Time=" << CPU::rdtime() << endl;
 
     CPU::int_disable();
 
@@ -18,7 +19,7 @@ void Timer::init()
     config(FREQUENCY);
     IC::enable(IC::INT_SYS_TIMER);
 
-    CPU::int_enable();
+    // CPU::int_enable();
 
 }
 
diff --git a/src/setup/makefile b/src/setup/makefile
index b5ead57..fe0620a 100644
--- a/src/setup/makefile
+++ b/src/setup/makefile
@@ -7,10 +7,11 @@ TARGET := $(if $(shell find setup_$(MMOD)* 2> /dev/null), $(if $(SETUP_ADDR), in
 all:	$(TARGET)
 
 setup_$(MMOD):	setup_$(MMOD).o
-		$(LD) $(LDFLAGS) -L$(CCLIB) --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
+		$(LD) $(LDFLAGS) -L$(CCLIB) --trace --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
 
 install:	setup_$(MMOD)
-		$(INSTALL) $< $(IMG)
+		$(OBJCOPY) $< $<_raw -O binary
+		mv $<_raw $(IMG)/$<
 
 install.o:	setup_$(MMOD).o
 		$(INSTALL) $< $(LIB)
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index 67287a6..369f5e9 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -1,74 +1,400 @@
 // EPOS RISC-V sifive SETUP
 
-#include <system/config.h>
+#include <utility/ostream.h>
+#include <utility/elf.h>
+#include <utility/debug.h>
+#include <system/info.h>
+#include <architecture.h>
+#include <machine.h>
 
-extern "C" { void _setup() __attribute__ ((used, naked, section(".init"))); }
+using namespace EPOS::S;
+typedef unsigned int Reg;
 
-// Interrupt Vector Table
-void _setup()
+extern "C"
 {
-    ASM("\t\n\
-        j       .reset                                                          \t\n\
-                                                                                \t\n\
-.reset:                                                                         \t\n\
-        # Disable interrupts                                                    \t\n\
-        csrs    mstatus, 1 << 3                                                 \t\n\
-                                                                                \t\n\
-        # Disable paging                                                        \t\n\
-        csrw    sptbr, zero                                                     \t\n\
-                                                                                \t\n\
-        # Put CLINT in direct mode (mtvec.mode = 0) and set mtvec to _int_entry \t\n\
-        la      t0, _int_entry                                                  \t\n\
-        andi    t0, t0, 0xfffffffe  # mtvec.mode = 0                            \t\n\
-        csrw    mtvec, t0                                                       \t\n\
-                                                                                \t\n\
-        # Get the hart's id                                                     \t\n\
-        csrr    a0, mhartid                                                     \t\n\
-                                                                                \t\n\
-        # Set a 16KB stack for each hart (#0 at __boot_stack__)                 \t\n\
-        la      sp, __boot_stack__                                              \t\n\
-        li      t0, 1                                                           \t\n\
-        slli    t0, t0, 14                                                      \t\n\
-        mul     t0, t0, a0                                                      \t\n\
-        sub     sp, sp, t0                                                      \t\n\
-                                                                                \t\n\
-        # Non-bootstrapping harts wait for an IPI                               \t\n\
-        bnez    a0, .secondary                                                  \t\n\
-                                                                                \t\n\
-        # Set mstatus to machine mode with interrupts disabled                  \t\n\
-        # 0b11 << 11: Machine's previous protection mode is 3 (MPP=3)           \t\n\
-        #    1 <<  7: Machine's previous interrupt-enable bit is 1 (MPIE=1)     \t\n\
-        li      t0, (0b11 << 11) | (1 << 7)                                     \t\n\
-        csrw    mstatus, t0                                                     \t\n\
-                                                                                \t\n\
-        # Set mepc to `_start` (will be used by mret)                           \t\n\
-        la      t0, _start                                                      \t\n\
-        csrw    mepc, t0                                                        \t\n\
-                                                                                \t\n\
-        # Go to _start and update mstatus accordingly by returning to mepc      \t\n\
-        mret                                                                    \t\n\
-                                                                                \t\n\
-.secondary:                                                                     \t\n\
-        # Set mstatus to machine mode with interrupts enabled                   \t\n\
-        # 0b11 << 11: Machine's previous protection mode is 3 (MPP=3)           \t\n\
-        #    1 <<  7: Machine's previous interrupt-enable bit is 1 (MPIE=1)     \t\n\
-        #    1 <<  3: Machine's interrupt-enable bit is 1 (MIE=1)               \t\n\
-        li      t0, (0b11 << 11) | (1 << 7) | (1 << 3)                          \t\n\
-        csrw    mstatus, t0                                                     \t\n\
-                                                                                \t\n\
-        # Enable software interrupts so hart #0 can latter wake up this hart    \t\n\
-        li      t0, (1 << 3) | (1 << 7) | (1 << 11)                             \t\n\
-        csrw    mie, t0                                                         \t\n\
-                                                                                \t\n\
-        # Set mepc to `_wait` (will be used by mret)                            \t\n\
-        la  t0, .wait                                                           \t\n\
-        csrw mepc, t0                                                           \t\n\
-                                                                                \t\n\
-        # Go to _wait and update mstatus accordingly by returning to mepc       \t\n\
-        mret                                                                    \t\n\
-                                                                                \t\n\
-.wait:                                                                          \t\n\
-        wfi                                                                     \t\n\
-        j _start                                                                \t\n\
-        ");
+    [[gnu::naked, gnu::section(".init")]] void _setup();
+    void _print(const char * s) { Display::puts(s); }
+    void _panic() { Machine::panic(); }
 }
+
+char placeholder[sizeof(System_Info)] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+System_Info * si;
+
+extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
+    Reg id = CPU::mcause();
+    if((id & IC::INT_MASK) == CLINT::IRQ_MAC_TIMER) {
+        Timer::reset();
+        CPU::sie(CPU::STI);
+    }
+    Reg interrupt_id = 1 << ((id & IC::INT_MASK) - 2);
+    if(CPU::int_enabled() && (CPU::sie() & (interrupt_id)))
+        CPU::mip(interrupt_id);
+}
+
+__BEGIN_SYS
+EPOS::S::U::OStream kout, kerr;
+char * bi;
+
+class Setup_SifiveE {
+private:
+    // Physical memory map
+    static const unsigned int SYS_INFO = Memory_Map::SYS_INFO;
+    static const unsigned int PAGE_TABLES = Memory_Map::PAGE_TABLES;
+    static const unsigned int MMODE_F = Memory_Map::MMODE_F;
+    static const unsigned int MEM_BASE = Memory_Map::MEM_BASE;
+    static const unsigned int MEM_TOP = Memory_Map::MEM_TOP;
+    
+    typedef CPU::Reg Reg;
+    typedef MMU::RV32_Flags RV32_Flags;
+    typedef MMU::Page Page;
+    typedef MMU::Page_Table Page_Table;
+    typedef MMU::Page_Directory Page_Directory;
+    typedef MMU::PT_Entry PT_Entry;
+
+public:
+    static void init() { setup_machine_environment(); }
+    static void setup_machine_environment();
+    static void setup_supervisor_environment();
+    static void build_page_tables();
+    static void clean_bss();
+    static void build_lm();
+    static void load_parts();
+};
+
+void Setup_SifiveE::load_parts()
+{
+    // Relocate System_Info
+    if(sizeof(System_Info) > sizeof(Page)) {
+        db<Setup>(ERR) << "System_Info is bigger than a page (" << sizeof(System_Info) << ")!" << endl;
+        _panic();
+    }
+    memcpy(reinterpret_cast<void *>(SYS_INFO), si, sizeof(System_Info));
+    
+    // Load INIT
+    ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+    ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+    
+    if(si->lm.has_ini) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_init()" << endl;
+        if(ini_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "INIT code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        
+        for(int i = 1; i < ini_elf->segments(); i++)
+            if(ini_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "INIT data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    
+    if((long unsigned int)ini_elf->segment_size(0) > sys_elf->segment_address(0) - ini_elf->segment_address(0)) {
+        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "init has " << hex << sys_elf->segment_address(0) - ini_elf->segment_address(0) - ini_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    // Load SYSTEM
+    if(si->lm.has_sys) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_system()" << endl;
+        if(sys_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "system code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        for(int i = 1; i < sys_elf->segments(); i++)
+            if(sys_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "system data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    
+    if((long unsigned int)sys_elf->segment_size(0) > sys_elf->segment_address(1) - sys_elf->segment_address(0)) {
+        db<Setup>(ERR) << "sys code is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "sys code has " << hex << sys_elf->segment_address(1) - sys_elf->segment_address(0) - sys_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    if((long unsigned int)ini_elf->segment_size(1) > sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1)) {
+        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "sys data has " << hex << sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1) - ini_elf->segment_size(1) << " unused bytes of memory" << endl;
+}
+
+
+void Setup_SifiveE::build_lm()
+{
+    // Get boot image structure
+    si->lm.has_stp = (si->bm.setup_offset != -1u);
+    si->lm.has_ini = (si->bm.init_offset != -1u);
+    si->lm.has_sys = (si->bm.system_offset != -1u);
+    si->lm.has_app = (si->bm.application_offset[0] != -1u);
+    si->lm.has_ext = (si->bm.extras_offset != -1u);
+
+    // Check SETUP integrity and get the size of its segments
+    si->lm.stp_entry = 0;
+    si->lm.stp_segments = 0;
+    si->lm.stp_code = ~0U;
+    si->lm.stp_code_size = 0;
+    si->lm.stp_data = ~0U;
+    si->lm.stp_data_size = 0;
+
+    bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE); // bi is loaded at MEM_BASE
+    if(si->lm.has_stp) {
+        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
+        if(!stp_elf->valid()) {
+            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.stp_entry = stp_elf->entry();
+        si->lm.stp_segments = stp_elf->segments();
+        si->lm.stp_code = stp_elf->segment_address(0);
+        si->lm.stp_code_size = stp_elf->segment_size(0);
+        if(stp_elf->segments() > 1) {
+            for(int i = 1; i < stp_elf->segments(); i++) {
+                if(stp_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(stp_elf->segment_address(i) < si->lm.stp_data)
+                    si->lm.stp_data = stp_elf->segment_address(i);
+                si->lm.stp_data_size += stp_elf->segment_size(i);
+            }
+        }
+    }
+
+    // Check INIT integrity and get the size of its segments
+    si->lm.ini_entry = 0;
+    si->lm.ini_segments = 0;
+    si->lm.ini_code = ~0U;
+    si->lm.ini_code_size = 0;
+    si->lm.ini_data = ~0U;
+    si->lm.ini_data_size = 0;
+    if(si->lm.has_ini) {
+        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+        if(!ini_elf->valid()) {
+            db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.ini_entry = ini_elf->entry();
+        si->lm.ini_segments = ini_elf->segments();
+        si->lm.ini_code = ini_elf->segment_address(0);
+        si->lm.ini_code_size = ini_elf->segment_size(0);
+        if(ini_elf->segments() > 1) {
+            for(int i = 1; i < ini_elf->segments(); i++) {
+                if(ini_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(ini_elf->segment_address(i) < si->lm.ini_data)
+                    si->lm.ini_data = ini_elf->segment_address(i);
+                si->lm.ini_data_size += ini_elf->segment_size(i);
+            }
+        }
+    }
+
+    // Check SYSTEM integrity and get the size of its segments
+    si->lm.sys_entry = 0;
+    si->lm.sys_segments = 0;
+    si->lm.sys_code = ~0U;
+    si->lm.sys_code_size = 0;
+    si->lm.sys_data = ~0U;
+    si->lm.sys_data_size = 0;
+    // si->lm.sys_stack = SYS_STACK;
+    // si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
+    if(si->lm.has_sys) {
+        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+        if(!sys_elf->valid()) {
+            db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.sys_entry = sys_elf->entry();
+        si->lm.sys_segments = sys_elf->segments();
+        si->lm.sys_code = sys_elf->segment_address(0);
+        si->lm.sys_code_size = sys_elf->segment_size(0);
+        if(sys_elf->segments() > 1) {
+            for(int i = 1; i < sys_elf->segments(); i++) {
+                if(sys_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(sys_elf->segment_address(i) < si->lm.sys_data)
+                    si->lm.sys_data = sys_elf->segment_address(i);
+                si->lm.sys_data_size += sys_elf->segment_size(i);
+            }
+        }
+
+        // if(si->lm.sys_code != SYS_CODE) {
+        //     db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
+        //     db<Setup>(ERR) << "OS code segment is too large!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_data != SYS_DATA) {
+        //     db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack) {
+        //     db<Setup>(ERR) << "OS data segment is too large!" << endl;
+        //     panic();
+        // }
+        // if(MMU::page_tables(MMU::pages(si->lm.sys_stack - SYS + si->lm.sys_stack_size)) > 1) {
+        //     db<Setup>(ERR) << "OS stack segment is too large!" << endl;
+        //     _panic();
+        // }
+    }
+
+    // Check APPLICATION integrity and get the size of its segments
+    for(unsigned i=0; i < si->bm.n_apps; i++){
+        si->lm.app[i].app_entry = 0;
+        si->lm.app[i].app_segments = 0;
+        si->lm.app[i].app_code = ~0U;
+        si->lm.app[i].app_code_size = 0;
+        si->lm.app[i].app_data = ~0U;
+        si->lm.app[i].app_data_size = 0;
+        if(si->lm.has_app) {
+            ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
+            if(!app_elf->valid()) {
+                db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
+                _panic();
+            }
+            si->lm.app[i].app_entry = app_elf->entry();
+            si->lm.app[i].app_segments = app_elf->segments();
+            si->lm.app[i].app_code = app_elf->segment_address(0);
+            si->lm.app[i].app_code_size = app_elf->segment_size(0);
+            if(app_elf->segments() > 1) {
+                for(int i = 1; i < app_elf->segments(); i++) {
+                    if(app_elf->segment_type(i) != PT_LOAD)
+                        continue;
+                    if(app_elf->segment_address(i) < si->lm.app[i].app_data)
+                        si->lm.app[i].app_data = app_elf->segment_address(i);
+                    si->lm.app[i].app_data_size += app_elf->segment_size(i);
+                }
+            }
+    }
+        // if(Traits<System>::multiheap) { // Application heap in data segment
+        //     si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
+        //     si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
+        //     si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
+        // }
+        // if(si->lm.has_ext) { // Check for EXTRA data in the boot image
+        //     si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
+        //     if(Traits<System>::multiheap)
+        //         si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
+        //     si->lm.app_data_size += si->lm.app_extra_size;
+        // }
+    }
+}
+
+void Setup_SifiveE::build_page_tables()
+{
+    // Address of the Directory
+    Reg page_tables = PAGE_TABLES;
+    MMU::_master = new ( (void *) page_tables ) Page_Directory();
+
+    // Number of kernel entries in each directory
+    unsigned sys_entries = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
+
+    MMU::_master->remap(page_tables + 4096, RV32_Flags::VALID, 0, sys_entries);
+
+    // Map logical addrs back to themselves; with this, the kernel may access any
+    // physical RAM address directly (as if paging wasn't there)
+    for(unsigned i = 0; i < sys_entries; i++)
+    {
+        Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1)) ) Page_Table();
+        pt->remap(i * 1024*4096, RV32_Flags::SYS);
+    }
+}
+
+extern "C" char __bss_start;
+extern "C" char _end;
+
+void Setup_SifiveE::clean_bss()
+{
+    unsigned * bss_start = reinterpret_cast<unsigned *>(&__bss_start);
+    unsigned * bss_end = reinterpret_cast<unsigned *>(&_end);
+    
+    db<Setup>(TRC) << "bss_start=" << bss_start << ", bss_end=" << bss_end << endl;
+    for (unsigned * word = bss_start; word < bss_end; word++) {
+        unsigned * t = new (word) unsigned;
+        *t = 0;
+    }
+}
+
+void Setup_SifiveE::setup_supervisor_environment()
+{
+    Display::init();
+    
+    // We must clean the bss before setting MMU::_master
+    clean_bss();
+
+    // This creates and configures the kernel page tables (which map logical==physical)
+    build_page_tables();
+
+    si = reinterpret_cast<System_Info*>(placeholder);
+    build_lm();
+    load_parts();
+
+    // forward everything
+    CPU::satp((0x1 << 31) | (PAGE_TABLES >> 12));
+    
+    CPU::sepc_write(si->lm.ini_entry);
+
+    // Interrupts will remain disable until the Context::load at Init_First
+    CPU::sstatus_write(CPU::SPP_S);
+    CPU::sie_write(CPU::SSI | CPU::STI | CPU::SEI);
+
+    ASM("sret");
+}
+
+void Setup_SifiveE::setup_machine_environment()
+{
+    // We first configure the M-mode CSRs and then switch to S-mode
+    // configure paging. After that, we won't return to M-mode; an exception
+    // is the forwarding of ints and excps to S-mode.
+    CPU::mie_write(CPU::MSI | CPU::MTI | CPU::MEI);
+    CPU::mmode_int_disable();
+
+    // We need to set:
+    //      MPP_S: to switch to S-mode after mret
+    //      MPIE:  otherwise we won't ever receive interrupts
+    CPU::mstatus_write(CPU::MPP_S | CPU::MPIE);
+
+    // We store mhartid at tp, since it becomes inaccessible while in S-mode.
+    Reg core = CPU::mhartid();
+    CPU::tp(core);
+
+    // Set stack for each core
+    CPU::sp(Traits<Machine>::BOOT_STACK - Traits<Machine>::STACK_SIZE * core);
+
+    // Guarantee that paging is off before going to S-mode.
+    CPU::satp(0);
+
+    // Forward all ints and excs to S-mode.
+    //!ECALLS: Not yet implemented.
+    CPU::mideleg_write(CPU::SSI | CPU::STI | CPU::SEI);
+    CPU::medeleg_write(0xffff);
+
+    // Relocate _mmode_forward - 1024 bytes are enough
+    char * src = reinterpret_cast<char *>(&_mmode_forward);
+    char * dst = reinterpret_cast<char *>(MMODE_F);
+    for(int i=0; i < 1024; i++){
+        *dst = *src;
+        src++;
+        dst++;
+    }
+    
+    // All ints received in M-mode are forwarded to S-mode.
+    // The first two bits indicate the mode: Direct or Vectored;
+    // we opted for Direct.
+    CPU::mtvec(MMODE_F & 0xfffffffc);
+    CPU::mepc((unsigned)&setup_supervisor_environment);
+
+    ASM("mret");
+}
+
+__END_SYS
+
+void _setup() { Setup_SifiveE::init(); }
diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
index cfb0d35..95f1ce4 100644
--- a/src/system/system_scaffold.cc
+++ b/src/system/system_scaffold.cc
@@ -15,7 +15,7 @@ class First_Object
 {
 public:
     First_Object() {
-        Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
+        // Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
     }
 };
 
diff --git a/tests/active_test/active_test.cc b/tests/active_test/active_test.cc
new file mode 100644
index 0000000..a7bd4cc
--- /dev/null
+++ b/tests/active_test/active_test.cc
@@ -0,0 +1,63 @@
+// EPOS Active Object Component Test Program
+
+#include <process.h>
+
+using namespace EPOS;
+
+const int iterations = 100;
+
+OStream cout;
+
+class A: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "a";
+            cout << endl;
+        }
+
+        return 'A';
+    }
+};
+
+class B: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "b";
+            cout << endl;
+        }
+
+        return 'B';
+    }
+};
+
+int main()
+{
+    cout << "Active Object Test" << endl;
+
+    A * a = new A;
+    B * b = new B;
+
+    a->start();
+    b->start();
+
+    cout << "Both threads are now done and have suspended themselves. I'll now wake them up so they can exit ..." << endl;
+
+    int status_a = a->join();
+    int status_b = b->join();
+
+    cout << "Thread A exited with status " << status_a
+ 	 << " and thread B exited with status " << status_b << endl;
+
+    delete a;
+    delete b;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
new file mode 100644
index 0000000..4642f73
--- /dev/null
+++ b/tests/active_test/active_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 1000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/active_test/makefile b/tests/active_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/active_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index 609d140..0f9a2d0 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = IA32;
-    static const unsigned int MACHINE = PC;
-    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/tests/scheduler_dm_test/makefile b/tests/scheduler_dm_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_dm_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_dm_test/scheduler_dm_test_traits.h b/tests/scheduler_dm_test/scheduler_dm_test_traits.h
new file mode 100644
index 0000000..9479846
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef DM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/scheduler_edf_test/makefile b/tests/scheduler_edf_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_edf_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_edf_test/scheduler_edf_test_traits.h b/tests/scheduler_edf_test/scheduler_edf_test_traits.h
new file mode 100644
index 0000000..186aaa6
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef EDF Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/scheduler_rm_test/makefile b/tests/scheduler_rm_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_rm_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_rm_test/scheduler_rm_test.cc b/tests/scheduler_rm_test/scheduler_rm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_rm_test/scheduler_rm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_rm_test/scheduler_rm_test_traits.h b/tests/scheduler_rm_test/scheduler_rm_test_traits.h
new file mode 100644
index 0000000..47e23e5
--- /dev/null
+++ b/tests/scheduler_rm_test/scheduler_rm_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/segment_test/makefile b/tests/segment_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/segment_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
new file mode 100644
index 0000000..67c0759
--- /dev/null
+++ b/tests/segment_test/segment_test.cc
@@ -0,0 +1,50 @@
+// EPOS Segment Test Program
+
+#include <memory.h>
+
+using namespace EPOS;
+
+const unsigned ES1_SIZE = 10000;
+const unsigned ES2_SIZE = 100000;
+
+int main()
+{
+    OStream cout;
+
+    cout << "Segment test" << endl;
+
+    cout << "My address space's page directory is located at "
+         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
+    Address_Space self(MMU::current());
+
+    cout << "Creating two extra data segments:" << endl;
+    Segment * es1 = new (SYSTEM) Segment(ES1_SIZE);
+    Segment * es2 = new (SYSTEM) Segment(ES2_SIZE);
+    cout << "  extra segment 1 => " << ES1_SIZE << " bytes, done!" << endl;
+    cout << "  extra segment 2 => " << ES2_SIZE << " bytes, done!" << endl;
+
+    cout << "Attaching segments:" << endl;
+    CPU::Log_Addr * extra1 = self.attach(es1);
+    CPU::Log_Addr * extra2 = self.attach(es2);
+    cout << "  extra segment 1 => " << extra1 << " done!" << endl;
+    cout << "  extra segment 2 => " << extra2 << " done!" << endl;
+
+    cout << "Clearing segments:";
+    memset(extra1, 0, ES1_SIZE);
+    memset(extra2, 0, ES2_SIZE);
+    cout << "  done!" << endl;
+
+    cout << "Detaching segments:";
+    self.detach(es1);
+    self.detach(es2);
+    cout << "  done!" << endl;
+
+    cout << "Deleting segments:";
+    delete es1;
+    delete es2;
+    cout << "  done!" << endl;
+
+    cout << "I'm done, bye!" << endl;
+
+    return 0;
+}
diff --git a/app/hello/hello_traits.h b/tests/segment_test/segment_test_traits.h
similarity index 99%
rename from app/hello/hello_traits.h
rename to tests/segment_test/segment_test_traits.h
index 6661b46..d1ca6d5 100644
--- a/app/hello/hello_traits.h
+++ b/tests/segment_test/segment_test_traits.h
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
index dbe3578..6a583c0 100644
--- a/tools/eposcc/eposcc
+++ b/tools/eposcc/eposcc
@@ -45,26 +45,26 @@ C_LINK_OBJS=
 C_LINK_LIBS=
 
 CPP_COMPILER="$TOOLS_PREFIX""g++"
-CPP_COMP_FLGS="--no-exceptions --no-rtti --no-use-cxa-atexit -std=c++14"
+CPP_COMP_FLGS="$MACH_CC_FLAGS"
 CPP_COMP_HDRS=
 CPP_LINK_FLGS="$MACH_LD_FLAGS"
 CPP_LINK_OBJS=
 CPP_LINK_LIBS=
 
-F77_COMPILER="$TOOLS_PREFIX""g77"
-F77_COMP_FLGS=
-F77_COMP_HDRS=
-F77_LINK_FLGS="$MACH_LD_FLAGS"
-F77_LINK_OBJS=
-F77_LINK_LIBS="f2c"
+# F77_COMPILER="$TOOLS_PREFIX""g77"
+# F77_COMP_FLGS=
+# F77_COMP_HDRS=
+# F77_LINK_FLGS="$MACH_LD_FLAGS"
+# F77_LINK_OBJS=
+# F77_LINK_LIBS="f2c"
 
 LINKER="$TOOLS_PREFIX""ld"
 
 LINKER_LIBRARY=$LINKER
 LINK_FLGS_LIBRARY="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE"
-if [ "$MACH_DATA_NAME" != "" ] ; then
-    LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=$APP_DATA"
-fi
+# if [ "$MACH_DATA_NAME" != "" ] ; then
+#     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=0x86000000"
+# fi
 if [ "$BOOT_STACK" != "" ] ; then
     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --defsym=__boot_stack__=$BOOT_STACK"
 fi
@@ -79,19 +79,19 @@ fi
 LINKER_BUILTIN=$LINKER
 LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
 LINK_OBJI_BUILTIN="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
-LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o -R$SRC/system/system_$MMOD"
-LINK_OBJL_BUILTIN="$LIB/crtend_$MMOD.o"
+LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o $LIB/crtend_$MMOD.o -R$SRC/system/system_$MMOD"
+# LINK_OBJL_BUILTIN=
 LINK_LIBS_BUILTIN="util_$MMOD gcc"
 if [ "$SETUP" = "" ] ; then
 LINK_OBJN_BUILTIN="$LIB/setup_$MMOD.o $LINK_OBJN_BUILTIN"
 fi
 
-LINKER_KERNEL=$LINKER
-LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
-LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
-LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
-LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
-LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
+# LINKER_KERNEL=$LINKER
+# LINK_FLGS_KERNEL="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
+# LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
+# LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
+# LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
+# LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
 
 #=========================================================================
 # VARIABLES
@@ -271,6 +271,7 @@ done
 #=========================================================================
 # COMMAND ISSUING
 #=========================================================================
+
 if [ "$language" = "F77" ] ; then
     compiler=$F77_COMPILER
     compile_flgs="$compile_flgs $F77_COMP_FLGS"
@@ -347,51 +348,54 @@ if [ $need_compile = 1 -a ! -f "$key_file" ] ; then
 fi
 
 # disabled for EPOS
-if [ $need_analyze = 5 ] ; then
-    analyze_flgs=$compile_flgs
+# if [ $need_analyze = 5 ] ; then
+#     analyze_flgs=$compile_flgs
 
-    if [ $has_dash_c = 0 ] ; then
-        analyze_flgs="-c $analyze_flgs"
-    fi
-    tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
-    analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
-    analyze_flgs="$analyze_flgs -o $tmp_file.o"
-    $do_echo $compiler $analyze_flgs $analyze_args $input_file
-    $do_exec $compiler $analyze_flgs $analyze_args $input_file
-    status=$?
-    if [ $status != 0 ] ; then
-        $do_echo rm -f "$tmp_file.*"
-        $do_exec rm -f "$tmp_file.*"
-        exit $status
-    fi
+#     if [ $has_dash_c = 0 ] ; then
+#         analyze_flgs="-c $analyze_flgs"
+#     fi
+#     tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
+#     analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
+#     analyze_flgs="$analyze_flgs -o $tmp_file.o"
+#     $do_echo $compiler $analyze_flgs $analyze_args $input_file
+#     $do_exec $compiler $analyze_flgs $analyze_args $input_file
+#     status=$?
+#     if [ $status != 0 ] ; then
+#         $do_echo rm -f "$tmp_file.*"
+#         $do_exec rm -f "$tmp_file.*"
+#         exit $status
+#     fi
 
-    $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
-    $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
-    status=$?
-    if [ $status != 0 ] ; then
-        $do_echo rm -f "$tmp_file.*"
-        $do_exec rm -f "$tmp_file.*"
-        exit $status
-    fi
+#     $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+#     $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+#     status=$?
+#     if [ $status != 0 ] ; then
+#         $do_echo rm -f "$tmp_file.*"
+#         $do_exec rm -f "$tmp_file.*"
+#         exit $status
+#     fi
 
-    if [ $only_analyze = 1 -a -n "$output_file" ] ; then
-        configurator_output_file=$output_file
-    else
-        configurator_output_file=$key_file
-    fi
-    $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
-    $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+#     if [ $only_analyze = 1 -a -n "$output_file" ] ; then
+#         configurator_output_file=$output_file
+#     else
+#         configurator_output_file=$key_file
+#     fi
+#     $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+#     $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
 
-    status=$?
-    $do_echo rm -f "$tmp_file.*"
-    $do_exec rm -f "$tmp_file.*"
+#     status=$?
+#     $do_echo rm -f "$tmp_file.*"
+#     $do_exec rm -f "$tmp_file.*"
 
-    if [ $only_analyze = 1 ] ; then
-        exit $status
-    fi
-fi
+#     if [ $only_analyze = 1 ] ; then
+#         exit $status
+#     fi
+# fi
 
 if [ $need_compile = 1 ] ; then
+    # echo $has_dash_c
+    # echo $language
+    # echo $compile_flgs
     if [ $has_dash_c = 0 ] ; then
         compile_flgs="-c $compile_flgs"
     fi
@@ -412,7 +416,7 @@ if [ $need_link = 1 ] ; then
         link_flgs="$link_flgs -o $output_file"
     fi
     $do_echo "$linker $link_flgs $link_objs $link_args $link_libs"
-    $do_exec $linker $link_flgs $link_objs $link_args $link_libs
+    $do_exec $linker --trace $link_flgs $link_objs $link_args $link_libs
     status=$?
 fi
 
diff --git a/tools/eposcfg/eposcfg.cc b/tools/eposcfg/eposcfg.cc
index 51b0f64..b0f48d5 100644
--- a/tools/eposcfg/eposcfg.cc
+++ b/tools/eposcfg/eposcfg.cc
@@ -10,6 +10,7 @@
 
 // Traits are included in config.h
 #include <system/config.h>
+#include <system/memory_map.h>
 
 // Using only bare C to avoid conflicts with EPOS
 #include <stdio.h>
@@ -21,7 +22,7 @@ using namespace EPOS::S;
 using namespace EPOS::S::U;
 
 // Constants
-const unsigned int TOKENS = 24;
+const unsigned int TOKENS = 32;
 const unsigned int COMPONENTS = 62;
 const unsigned int STRING_SIZE = 128;
 
@@ -40,14 +41,22 @@ char tokens[TOKENS][STRING_SIZE] = {
     "MEM_TOP",
     "MEM_SIZE",
     "MEM_SIZE_KB",
+    "MIO_BASE",
+    "MIO_TOP",
+    "MMODE_F",
+    "MIO_SIZE",
+    "MIO_SIZE_KB",
     "BOOT_STACK",
     "BOOT",
+    "IMAGE",
     "SETUP",
     "INIT",
     "APP_CODE",
     "APP_DATA",
     "SYS_CODE",
     "SYS_DATA",
+    "SYS_STACK",
+    "SYS_HEAP",
     "BOOT_LENGTH_MIN",
     "BOOT_LENGTH_MAX",
     "EXPECTED_SIMULATION_TIME"
@@ -192,66 +201,99 @@ void populate_strings()
     snprintf(string, STRING_SIZE, "%i", Traits<CPU>::WORD_SIZE);
     set_token_value("WORD_SIZE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_BASE);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_BASE);
     set_token_value("MEM_BASE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP);
     set_token_value("MEM_TOP", string);
+    
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MMODE_F);
+    set_token_value("MMODE_F", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE);
     set_token_value("MEM_SIZE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", (Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE) / 1024);
+    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE) / 1024);
     set_token_value("MEM_SIZE_KB", string);
 
-    if(Traits<Machine>::BOOT_STACK != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT_STACK);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_BASE);
+    set_token_value("MIO_BASE", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP);
+    set_token_value("MIO_TOP", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE);
+    set_token_value("MIO_SIZE", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE) / 1024);
+    set_token_value("MIO_SIZE_KB", string);
+
+    if(Memory_Map::BOOT_STACK != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT_STACK);
     else
         string[0] = '\0';
     set_token_value("BOOT_STACK", string);
 
-    if(Traits<Machine>::BOOT != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT);
+    if(Memory_Map::BOOT != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT);
     else
         string[0] = '\0';
     set_token_value("BOOT", string);
 
-    if(Traits<Machine>::SETUP != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SETUP);
+    if(Memory_Map::IMAGE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::IMAGE);
+    else
+        string[0] = '\0';
+    set_token_value("IMAGE", string);
+
+    if(Memory_Map::SETUP != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SETUP);
     else
         string[0] = '\0';
     set_token_value("SETUP", string);
 
-    if(Traits<Machine>::INIT != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::INIT);
+    if(Memory_Map::INIT != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::INIT);
     else
         string[0] = '\0';
     set_token_value("INIT", string);
 
-    if(Traits<Machine>::APP_CODE != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_CODE);
+    if(Memory_Map::APP_CODE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_CODE);
     else
         string[0] = '\0';
     set_token_value("APP_CODE", string);
 
-    if(Traits<Machine>::APP_DATA != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_DATA);
+    if(Memory_Map::APP_DATA != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_DATA);
     else
         string[0] = '\0';
     set_token_value("APP_DATA", string);
 
-    if(Traits<Machine>::SYS_CODE != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_CODE);
+    if(Memory_Map::SYS_CODE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_CODE);
     else
         string[0] = '\0';
     set_token_value("SYS_CODE", string);
 
-    if(Traits<Machine>::SYS_DATA != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_DATA);
+    if(Memory_Map::SYS_DATA != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_DATA);
     else
         string[0] = '\0';
     set_token_value("SYS_DATA", string);
 
+    if(Memory_Map::SYS_STACK != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_STACK);
+    else
+        string[0] = '\0';
+    set_token_value("SYS_STACK", string);
+
+    if(Memory_Map::SYS_HEAP != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_HEAP);
+    else
+        string[0] = '\0';
+    set_token_value("SYS_HEAP", string);
+
     if(Traits<Machine>::BOOT_LENGTH_MIN != Traits<Machine>::NOT_USED)
         snprintf(string, STRING_SIZE, "%i", Traits<Machine>::BOOT_LENGTH_MIN);
     else
diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
index c54f943..d0e99b2 100755
--- a/tools/eposctors/eposctors
+++ b/tools/eposctors/eposctors
@@ -6,14 +6,16 @@
 ELF=$1
 GDB=$2
 
-INIT_ARRAY_OFFSET=`objdump -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
-INIT_ARRAY_SIZE=`objdump -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
-FINI_ARRAY_OFFSET=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
-FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
+OBJDUMP=/usr/local/rv32/bin/riscv32-unknown-linux-gnu-objdump
+INIT_ARRAY_OFFSET=`$OBJDUMP -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
+INIT_ARRAY_SIZE=`$OBJDUMP -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
+FINI_ARRAY_OFFSET=`$OBJDUMP -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
+FINI_ARRAY_SIZE=`$OBJDUMP -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
 
 echo "CTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    dec=`printf "%d" 0x$INIT_ARRAY_SIZE`
+    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n $dec -v -e '1/4 "%08x\n"' $ELF`
     for item in $LIST; do
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
         echo 0x$item $sym
@@ -25,7 +27,8 @@ fi
 echo
 echo "DTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$FINI_ARRAY_OFFSET -n 0x$FINI_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    dec=`printf "%d" 0x$FINI_ARRAY_SIZE`
+    LIST=`hexdump -s 0x$FINI_ARRAY_OFFSET -n $dec -v -e '1/4 "%08x\n"' $ELF`
     for item in $LIST; do
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_D_//g"|c++filt`
         echo 0x$item $sym
diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
index da82176..9072761 100644
--- a/tools/eposmkbi/eposmkbi.cc
+++ b/tools/eposmkbi/eposmkbi.cc
@@ -38,6 +38,8 @@ struct Configuration
     bool           endianess;  // true => little, false => big
     unsigned int   mem_base;
     unsigned int   mem_top;
+    unsigned int   mio_base;
+    unsigned int   mio_top;
     unsigned int   boot_length_min;
     unsigned int   boot_length_max;
     short          node_id;   // nodes in SAN (-1 => dynamic)
@@ -52,13 +54,13 @@ typedef _SYS::System_Info System_Info;
 
 // PROTOTYPES
 bool parse_config(FILE * cfg_file, Configuration * cfg);
-void strtolower (char *dst,const char* src);
+void strtolower (char * dst,const char * src);
 bool add_machine_secrets(int fd_img, unsigned int i_size, char * mach, char * mmod);
 
 bool file_exist(char *file);
 
-int put_buf(int fd_out, void *buf, int size);
-int put_file(int fd_out, char *file);
+int put_buf(int fd_out, void * buf, int size);
+int put_file(int fd_out, char * file);
 int pad(int fd_out, int size);
 bool lil_endian();
 
@@ -140,7 +142,7 @@ int main(int argc, char **argv)
     }
 
     // Open destination file (rewrite)
-    int fd_img = open(argv[optind + 1], O_WRONLY | O_CREAT | O_TRUNC, 00644);
+    int fd_img = open(argv[optind + 1], O_RDWR | O_CREAT | O_TRUNC, 00644);
     if(fd_img < 0) {
         fprintf(err, "Error: can't create boot image \"%s\"!\n", argv[optind + 1]);
         return 1;
@@ -152,7 +154,8 @@ int main(int argc, char **argv)
     fprintf(out, "  Model: %s\n", CONFIG.mmod);
     fprintf(out, "  Processor: %s (%d bits, %s-endian)\n", CONFIG.arch, CONFIG.word_size, CONFIG.endianess ? "little" : "big");
     fprintf(out, "  Memory: %d KBytes\n", (CONFIG.mem_top - CONFIG.mem_base) / 1024);
-    fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
+    if((CONFIG.boot_length_min + CONFIG.boot_length_max) > 0)
+        fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
     if(CONFIG.space_x != -1)
         fprintf(out, "  Node location: (%d, %d, %d)\n", CONFIG.space_x, CONFIG.space_y, CONFIG.space_z);
     fprintf(out, "  UUID: ");
@@ -162,7 +165,7 @@ int main(int argc, char **argv)
     // Create the boot image
     unsigned int image_size = 0;
     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
-
+    
     // Add BOOT
     if(CONFIG.boot_length_max > 0) {
         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
@@ -179,38 +182,56 @@ int main(int argc, char **argv)
     }
     unsigned int boot_size = image_size;
 
+    // Determine if System_Info is needed and how it must be handled
+    bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
+    bool si_in_setup = (need_si && (boot_size == 0)); // If the image contains a boot sector, then SI will be on a separate disk sector. Otherwise, it will be inside SETUP.
+
     // Reserve space for System_Info if necessary
-    System_Info si;
-    bool need_si = true;
-    if(image_size == 0) {
-        need_si = false;
-    } else
-        if(sizeof(System_Info) > MAX_SI_LEN) {
+    if(need_si && !si_in_setup) {
+        if(sizeof(System_Info) <= MAX_SI_LEN) {
+            image_size += pad(fd_img, MAX_SI_LEN);
+        } else {
             fprintf(out, " failed!\n");
             fprintf(err, "System_Info structure is too large (%d)!\n", sizeof(System_Info));
             return 1;
-        } else
-            image_size += pad(fd_img, MAX_SI_LEN);
+        }
+    }
 
     // Initialize the Boot_Map in System_Info
-    si.bm.n_cpus   = CONFIG.n_cpus; // can be adjusted by SETUP in some machines
+    System_Info si;
+    si.bm.n_cpus   = CONFIG.n_cpus;     // can be adjusted by SETUP in some machines
     si.bm.mem_base = CONFIG.mem_base;
     si.bm.mem_top  = CONFIG.mem_top;
-    si.bm.io_base  = 0; // will be adjusted by SETUP
-    si.bm.io_top   = 0; // will be adjusted by SETUP
+    si.bm.mio_base = CONFIG.mio_base;   // can be adjusted by SETUP in some machines
+    si.bm.mio_top  = CONFIG.mio_top;    // can be adjusted by SETUP in some machines
     si.bm.node_id  = CONFIG.node_id;
     si.bm.space_x  = CONFIG.space_x;
     si.bm.space_y  = CONFIG.space_y;
     si.bm.space_z  = CONFIG.space_z;
+    si.bm.n_apps   = argc-3;
+
+    fprintf(out, "\nBoot Map:");
+    fprintf(out, "\n    si.bm.n_cpus %u", si.bm.n_cpus);
+    fprintf(out, "\n    si.bm.mem_base %08x", si.bm.mem_base);
+    fprintf(out, "\n    si.bm.mem_top %08x", si.bm.mem_top);
+    fprintf(out, "\n    si.bm.mio_base %08x", si.bm.mio_base);
+    fprintf(out, "\n    si.bm.mio_top %08x", si.bm.mio_top);
+    fprintf(out, "\n    si.bm.node_id %u", si.bm.node_id);
+    fprintf(out, "\n    si.bm.space_x %u", si.bm.space_x);
+    fprintf(out, "\n    si.bm.space_y %u", si.bm.space_y);
+    fprintf(out, "\n    si.bm.space_z %u\n\n", si.bm.space_z);
+
     for(unsigned int i = 0; i < 8; i++)
         si.bm.uuid[i]  = CONFIG.uuid[i];
 
     // Add SETUP
     sprintf(file, "%s/img/setup_%s", argv[optind], CONFIG.mmod);
     if(file_exist(file)) {
-        si.bm.setup_offset = image_size - boot_size;
+        // Setup is a raw binary file now; it has no Elf header to be read
+        si.bm.setup_offset = -1;
         fprintf(out, "    Adding setup \"%s\":", file);
         image_size += put_file(fd_img, file);
+        image_size += pad(fd_img, 4*4096 - (image_size % 4096));
     } else
         si.bm.setup_offset = -1;
 
@@ -233,22 +254,17 @@ int main(int argc, char **argv)
     }
 
     // Add application(s) and data
-    si.bm.application_offset = image_size - boot_size;
+    si.bm.application_offset[0] = image_size - boot_size;
     fprintf(out, "    Adding application \"%s\":", argv[optind + 2]);
     image_size += put_file(fd_img, argv[optind + 2]);
     if((argc - optind) == 3) // single APP
         si.bm.extras_offset = -1;
-    else { // multiple APPs or data
-        si.bm.extras_offset = image_size - boot_size;
-        struct stat file_stat;
-        for(int i = optind + 3; i < argc; i++) {
-            fprintf(out, "    Adding file \"%s\":", argv[i]);
-            stat(argv[i], &file_stat);
-            image_size += put_number(fd_img, file_stat.st_size);
+    else{
+        for(int i=4; i<argc; i++){
+            si.bm.application_offset[i-3] = image_size - boot_size;
+            fprintf(out, "    Adding application \"%s\":", argv[i]);
             image_size += put_file(fd_img, argv[i]);
         }
-        // Signalize last application by setting its size to 0
-        image_size += put_number(fd_img, 0);
     }
 
     // Add the size of the image to the Boot_Map in System_Info (excluding BOOT)
@@ -256,8 +272,42 @@ int main(int argc, char **argv)
 
     // Add System_Info
     if(need_si) {
-        fprintf(out, "    Adding system info:");
-        if(lseek(fd_img, boot_size, SEEK_SET) < 0) {
+        unsigned int si_offset = boot_size;
+        fprintf(out, "    Adding system info");
+        if(si_in_setup) {
+            fprintf(out, " to SETUP:");
+            struct stat stat;
+            if(fstat(fd_img, &stat) < 0)  {
+                fprintf(out, " failed! (stat)\n");
+                return 0;
+            }
+            char * buffer = (char *) malloc(stat.st_size);
+            if(!buffer) {
+                fprintf(out, " failed! (malloc)\n");
+                return 0;
+            }
+            memset(buffer, '\1', stat.st_size);
+            lseek(fd_img, 0, SEEK_SET);
+            if(read(fd_img, buffer, stat.st_size) < 0) {
+                fprintf(out, " failed! (read)\n");
+                free(buffer);
+                return 0;
+            }
+
+            char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+            char * setup_si = reinterpret_cast<char *>(memmem(buffer, stat.st_size, placeholder, strlen(placeholder)));
+            if(setup_si) {
+                si_offset = setup_si - buffer;
+            } else {
+                fprintf(out, " failed! (SETUP does not contain System_Info placeholder)\n");
+                free(buffer);
+                return 0;
+            }
+        } else {
+            fprintf(out, " to image:");
+            si_offset = boot_size;
+        }
+        if(lseek(fd_img, si_offset, SEEK_SET) < 0) {
             fprintf(err, "Error: can't seek the boot image!\n");
             return 1;
         }
@@ -279,7 +329,7 @@ int main(int argc, char **argv)
     }
     fprintf(out, " done.\n");
 
-    //Finish
+    // Finish
     close(fd_img);
     fprintf(out, "\n  Image successfully generated (%d bytes)!\n\n", image_size);
 
@@ -400,7 +450,7 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
         fprintf(err, "Error: no valid MEM_BASE in configuration!\n");
         return false;
     }
-    cfg->mem_base = strtol(token, 0, 16);
+    cfg->mem_base = strtoll(token, 0, 16);
 
     // Memory Top
     if(fgets(line, 256, cfg_file) != line) {
@@ -412,7 +462,31 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
         fprintf(err, "Error: no valid MEM_TOP in configuration!\n");
         return false;
     }
-    cfg->mem_top=strtol(token, 0, 16);
+    cfg->mem_top = strtoll(token, 0, 16);
+
+    // I/O Base
+    if(fgets(line, 256, cfg_file) != line) {
+        fprintf(err, "Error: failed to read MIO_BASE from configuration file!\n");
+        return false;
+    }
+    token = strtok(line, "=");
+    if(strcmp(token, "MIO_BASE") || !(token = strtok(NULL, "\n"))) {
+        fprintf(err, "Error: no valid MIO_BASE in configuration!\n");
+        return false;
+    }
+    cfg->mio_base = strtoll(token, 0, 16);
+
+    // I/O Top
+    if(fgets(line, 256, cfg_file) != line) {
+        fprintf(err, "Error: failed to read MIO_TOP from configuration file!\n");
+        return false;
+    }
+    token = strtok(line, "=");
+    if(strcmp(token, "MIO_TOP") || !(token = strtok(NULL, "\n"))) {
+        fprintf(err, "Error: no valid MIO_TOP in configuration!\n");
+        return false;
+    }
+    cfg->mio_top = strtoll(token, 0, 16);
 
     // Boot Length Min
     if(fgets(line, 256, cfg_file) != line)
@@ -474,9 +548,9 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
     if(!put_number(fd, static_cast<T>(si->bm.mem_top)))
         return false;
 
-    if(!put_number(fd, static_cast<T>(0))) // io_base
+    if(!put_number(fd, static_cast<T>(si->bm.mio_base)))
         return false;
-    if(!put_number(fd, static_cast<T>(0))) // io_top
+    if(!put_number(fd, static_cast<T>(si->bm.mio_top)))
         return false;
 
     if(!put_number(fd, si->bm.node_id))
@@ -499,7 +573,11 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
         return false;
     if(!put_number(fd, static_cast<T>(si->bm.system_offset)))
         return false;
-    if(!put_number(fd, static_cast<T>(si->bm.application_offset)))
+    for(int i=0; i<8; i++){
+        if(!put_number(fd, static_cast<T>(si->bm.application_offset[i])))                 
+            return false;
+    }
+    if(!put_number(fd, static_cast<T>(si->bm.n_apps)))
         return false;
     if(!put_number(fd, static_cast<T>(si->bm.extras_offset)))
         return false;
@@ -512,7 +590,7 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
 //=============================================================================
 bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
 {
-    if (!strcmp(mach, "pc")) { // PC
+    if(!strcmp(mach, "pc")) { // PC
         const unsigned int floppy_size   = 1474560;
         const unsigned int secrets_offset   = CONFIG.boot_length_min - 6;
         const unsigned short boot_id        = 0xaa55;
@@ -552,7 +630,7 @@ bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
         char key_string[] = ":020000040027D3\r\n:0CFFD400FFFFFFEF000000000000200015\r\n:00000001FF\r\n"; // Bootloader Disabled
         const int key_offset = -strlen(":00000001FF\r\n");
 
-        // Write key string to unlock epos
+        // Write key string to unlock EPOS
         if(lseek(fd,key_offset,SEEK_END) < 0) {
             fprintf(err, "Error: can't seek the boot image!\n");
             return false;
