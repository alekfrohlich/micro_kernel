diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 40c7c05..c935003 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -1,12 +1,36 @@
 #include <utility/ostream.h>
+#include <time.h>
 
 using namespace EPOS;
 
 OStream cout;
 
+int __attribute__((optimize("O0"))) dummy(int n) {
+    long long int a = 0;
+    for (int i = 0; i < n; i++) {
+        for (int j = 0; j < n; j++) {
+            a += i*j;
+        }
+    }
+    return a;
+}
+
+static unsigned ITERATIONS = 1000;
 int main()
 {
-    cout << "Hello world!" << endl;
-
+    Chronometer chron;
+    unsigned chron_freq = chron.frequency();
+    unsigned alarm_freq = Alarm::frequency();
+    cout << "Chron Frequency: " << chron_freq << endl;
+    cout << "Alarm Frequency: " << alarm_freq << endl;
+    unsigned int RESCALE = chron_freq / alarm_freq;
+    chron.reset();
+    chron.start();
+    for (int i = 0; i < ITERATIONS; i++) {
+        dummy(900);
+    }
+    chron.stop();
+    unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
+    cout << "T=" << avg << endl; 
     return 0;
 }
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 6661b46..9b52d33 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef FCFS Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 6661b46..ea0ed11 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef EDF Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 6661b46..d1ca6d5 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/test_edf/makefile b/app/test_edf/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_edf/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_edf/test_edf.cc b/app/test_edf/test_edf.cc
new file mode 100644
index 0000000..0bbba9e
--- /dev/null
+++ b/app/test_edf/test_edf.cc
@@ -0,0 +1,82 @@
+// Description:
+// In the current configuration, we have
+//  preemptive = true
+//  dynamic = true
+//  timed = false
+// We've decided to turn off timed preemptions since that increased the time
+// system spent in between job execution without any benefits.
+
+// Test scenario:
+// Two tasks,
+//  A: cap=1000, deadline=2000
+//  B: cap=1500, deadline=3000
+// CPU_Usage = 100%; to avoid missing deadlines due to system execution, we actualy
+// have A and B execute a little bit faster than their caps.
+// The idea is to obtain the following timeline:
+//
+// 0000-1000: A runs and finishes (wait_next())
+// 1000-2000: B runs until A's alarm (50 leftover)
+// 2000-2500: 300 < 400, so B runs and finishes (wait_next())
+// 2500-3000: A runs until B's alarm (50 leftover)
+// 3000-3500: 400 < 600, so A runs and finishes (wait_next())
+// 3500-4000: B runs until A's alarm (100 leftover)
+// Here, in practice, A runs before B due to the reschedule provoked by A's alarm (choose() will insert B at tail and so A will be returned from remove_head())
+// 4000-5000: B continues and finishes (wait_next())
+// 5000-6000: A runs and finishes (wait_next())
+// Then, the system repeats (at every 6000 ticks we reset _priority = _period to avoid overflow)
+
+// Observations:
+// The EDF time unit is Alarm::Tick
+
+#include <utility/ostream.h>
+#include <machine/display.h>
+#include <architecture.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+static const unsigned DEADLINE[] = {
+    2000,
+    3000,
+};
+
+int __attribute__((optimize("O0"))) work(int n) {
+    EPOS::S::CPU::int_enable(); // Join makes so that Task_A starts executing with interrupts disabled.
+    cout << "Begin: " << ((n == 0) ? 'A' : 'B') << ", Prio=" << Periodic_Thread::self()->priority() << " [" << Alarm::elapsed() << "]" << endl;
+    while (Alarm::elapsed() < 15000) {
+        unsigned last_time = Alarm::elapsed();
+        unsigned tot = 0;
+        while (tot < DEADLINE[n]/2 - 50) { // -50 to allow for system time
+            EPOS::S::CPU::int_disable();
+            if (Alarm::elapsed() - last_time < 500) // we might be interrupted, so only add if we werent
+                tot += Alarm::elapsed() - last_time;
+            last_time = Alarm::elapsed();
+            EPOS::S::CPU::int_enable();
+        }
+        cout << "End: " << ((n == 0) ? 'A' : 'B') << ", Prio=" << Periodic_Thread::self()->priority() << " [" << Alarm::elapsed() << "]" << endl;
+        Periodic_Thread::wait_next();
+        cout << "Begin: " << ((n == 0) ? 'A' : 'B') << ", Prio=" << Periodic_Thread::self()->priority() << " [" << Alarm::elapsed() << "]" << endl;
+    }
+    return 0;
+}
+
+Periodic_Thread * task[2];
+
+int main()
+{
+    Display::clear();;
+
+    task[0] = new Periodic_Thread(DEADLINE[0], &work, 0);
+    task[1] = new Periodic_Thread(DEADLINE[1], &work, 1);
+
+    // main will halt forever
+    for (int i = 0; i < 2; i++)
+        task[i]->join();
+
+    for (int i = 0; i < 2; i++)
+        delete task[i];
+
+    return 0;
+}
diff --git a/app/test_edf/test_edf_traits.h b/app/test_edf/test_edf_traits.h
new file mode 100644
index 0000000..cda0daa
--- /dev/null
+++ b/app/test_edf/test_edf_traits.h
@@ -0,0 +1,157 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    // typedef RR Criterion;
+    // typedef FCFS Criterion;
+    typedef EDF Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/app/test_worst_fit/makefile b/app/test_worst_fit/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_worst_fit/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_worst_fit/test_worst_fit.cc b/app/test_worst_fit/test_worst_fit.cc
new file mode 100644
index 0000000..0f20446
--- /dev/null
+++ b/app/test_worst_fit/test_worst_fit.cc
@@ -0,0 +1,47 @@
+// Description:
+// The Heap reaches main() containing two elements: E1 and E2.
+//    E1 begun from &_end to BOOT_STACK, but now has 32904 less bytes due to the allocations
+//  of System::init().
+//    E2 is still untouched and ranges from MEM_TOP to MEM_TOP-STACK_SIZE.
+// E1 is way larger than E2.
+//    In this test program, we allocate almost all of E1 so that Worst-Fit has to reach for E2
+//  in its second allocation (line 30).
+// For comparision purposes, we print how First Fit would have handled each allocation.
+
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+// for Single System Heap
+static const int REMAINING_SYS_HEAP = 134201064 - 32904 - 16*1024;
+// for Application Heap
+static const int REMAINING_APP_HEAP = 16777216;
+
+enum {
+    TEST_SINGLE_HEAP,
+    TEST_MULTI_HEAP,
+};
+
+static const unsigned int MODE = TEST_MULTI_HEAP;
+static const unsigned int REMAINING = (MODE==TEST_MULTI_HEAP)? REMAINING_APP_HEAP : REMAINING_SYS_HEAP;
+
+// TODO: test only multi-heap and do it right
+
+char * alloc(int bytes) {
+    return new char[bytes];
+}
+
+int main()
+{
+    // terminal output is important after the following line
+    cout << "Testing Worst-Fit..." << endl;
+
+    // leave less than a stack worth of memory on E1
+    alloc(REMAINING - 8*1024);
+    // this should go to E2
+    alloc(16); // will alloc 16+4 due to size
+
+    return 0;
+}
diff --git a/app/test_worst_fit/test_worst_fit_traits.h b/app/test_worst_fit/test_worst_fit_traits.h
new file mode 100644
index 0000000..e8d912b
--- /dev/null
+++ b/app/test_worst_fit/test_worst_fit_traits.h
@@ -0,0 +1,156 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    // typedef RR Criterion;
+    typedef FCFS Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/img/makefile b/img/makefile
index f048773..0799121 100644
--- a/img/makefile
+++ b/img/makefile
@@ -83,7 +83,7 @@ endif
 
 debug:		$(IMAGE)
 ifeq ($(NODES),1)
-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
+		$(EMULATOR)$(IMAGE) &
 		$(DEBUGGER)
 else
 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
 		@echo "Running $(APPLICATION) ..."
 posrun_$(APPLICATION):
 		@echo "done!"
-		
+
 FORCE:
diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
index 1c809b2..1fac9b9 100644
--- a/include/architecture/rv32/rv32_mmu.h
+++ b/include/architecture/rv32/rv32_mmu.h
@@ -117,7 +117,6 @@ public:
 
     static void free(Phy_Addr addr, unsigned int n = 1) {
         db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
-
         // No unaligned addresses if the CPU doesn't support it
         assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
 
diff --git a/include/memory.h b/include/memory.h
index b2f8be5..e6802aa 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -43,7 +43,7 @@ public:
     typedef MMU::Flags Flags;
 
 public:
-    Segment(unsigned int bytes, const Color & color = Color::WHITE, const Flags & flags = Flags::APP);
+    Segment(unsigned int bytes, const Flags & flags = Flags::APP);
     Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
     ~Segment();
 
diff --git a/include/process.h b/include/process.h
index 5978227..4c00514 100644
--- a/include/process.h
+++ b/include/process.h
@@ -7,6 +7,7 @@
 #include <machine.h>
 #include <utility/queue.h>
 #include <utility/handler.h>
+#include <scheduler.h>
 
 extern "C" { void __exit(); }
 
@@ -16,12 +17,14 @@ class Thread
 {
     friend class Init_First;            // context->load()
     friend class Init_System;           // for init() on CPU != 0
+    friend class Scheduler<Thread>;     // for link()
     friend class Synchronizer_Common;   // for lock() and sleep()
     friend class Alarm;                 // for lock()
     friend class System;                // for init()
+    friend class IC;                    // for link() for priority ceiling
 
 protected:
-    static const bool preemptive = Traits<Thread>::preemptive;
+    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
     static const bool reboot = Traits<System>::reboot;
 
     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
@@ -40,26 +43,26 @@ public:
         FINISHING
     };
 
-    // Thread Priority
-    typedef unsigned int Priority;
+    // Thread Scheduling Criterion
+    typedef Traits<Thread>::Criterion Criterion;
     enum {
-        MAIN   = 0,
-        HIGH   = 1,
-        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 4,
-        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
-        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2
+        HIGH    = Criterion::HIGH,
+        NORMAL  = Criterion::NORMAL,
+        LOW     = Criterion::LOW,
+        MAIN    = Criterion::MAIN,
+        IDLE    = Criterion::IDLE
     };
 
     // Thread Queue
-    typedef Ordered_Queue<Thread, Priority> Queue;
+    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
 
     // Thread Configuration
     struct Configuration {
-        Configuration(const State & s = READY, const Priority & p = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), priority(p), stack_size(ss) {}
+        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+        : state(s), criterion(c), stack_size(ss) {}
 
         State state;
-        Priority priority;
+        Criterion criterion;
         unsigned int stack_size;
     };
 
@@ -78,8 +81,8 @@ public:
 
     int join();
     void pass();
-    void suspend() { suspend(false); }
-    void resume() { resume(false); }
+    void suspend();
+    void resume();
 
     static Thread * volatile self() { return running(); }
     static void yield();
@@ -89,15 +92,15 @@ protected:
     void constructor_prologue(unsigned int stack_size);
     void constructor_epilogue(const Log_Addr & entry, unsigned int stack_size);
 
-    static Thread * volatile running() { return _running; }
+    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
+    Queue::Element * link() { return &_link; }
+
+    static Thread * volatile running() { return _scheduler.chosen(); }
 
     static void lock() { CPU::int_disable(); }
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
 
-    void suspend(bool locked);
-    void resume(bool unpreemptive);
-
     static void sleep(Queue * q);
     static void wakeup(Queue * q);
     static void wakeup_all(Queue * q);
@@ -105,7 +108,7 @@ protected:
     static void reschedule();
     static void time_slicer(IC::Interrupt_Id interrupt);
 
-    static void dispatch(Thread * prev, Thread * next);
+    static void dispatch(Thread * prev, Thread * next, bool charge = true);
 
     static int idle();
 
@@ -122,11 +125,7 @@ protected:
 
     static volatile unsigned int _thread_count;
     static Scheduler_Timer * _timer;
-
-private:
-    static Thread * volatile _running;
-    static Queue _ready;
-    static Queue _suspended;
+    static Scheduler<Thread> _scheduler;
 };
 
 
@@ -141,7 +140,7 @@ inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
 
 template<typename ... Tn>
 inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.priority)
+: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
     constructor_prologue(conf.stack_size);
     _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
@@ -149,6 +148,22 @@ inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ...
 }
 
 
+// A Java-like Active Object
+class Active: public Thread
+{
+public:
+    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
+    virtual ~Active() {}
+
+    virtual int run() = 0;
+
+    void start() { resume(); }
+
+private:
+    static int entry(Active * runnable) { return runnable->run(); }
+};
+
+
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
diff --git a/include/real-time.h b/include/real-time.h
new file mode 100644
index 0000000..f61c11b
--- /dev/null
+++ b/include/real-time.h
@@ -0,0 +1,122 @@
+// EPOS Real-time Declarations
+
+#ifndef __real_time_h
+#define __real_time_h
+
+#include <utility/handler.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+#include <time.h>
+#include <process.h>
+#include <synchronizer.h>
+
+__BEGIN_SYS
+
+// Aperiodic Thread
+typedef Thread Aperiodic_Thread;
+
+// Periodic threads are achieved by programming an alarm handler to invoke
+// p() on a control semaphore after each job (i.e. task activation). Base
+// threads are created in BEGINNING state, so the scheduler won't dispatch
+// them before the associate alarm and semaphore are created. The first job
+// is dispatched by resume() (thus the _state = SUSPENDED statement)
+
+// Periodic Thread
+class Periodic_Thread: public Thread
+{
+public:
+    // enum {
+    //     SAME,
+    //     NOW,
+    //     UNKNOWN,
+    //     ANY
+    // };
+
+protected:
+    // Alarm Handler for periodic threads under static scheduling policies
+    class Static_Handler: public Semaphore_Handler
+    {
+    public:
+        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
+        ~Static_Handler() {}
+    };
+
+    // Alarm Handler for periodic threads under dynamic scheduling policies
+    class Dynamic_Handler: public Semaphore_Handler
+    {
+    public:
+        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
+        ~Dynamic_Handler() {}
+
+        void operator()() {
+            _thread->criterion().update();
+
+            Semaphore_Handler::operator()();
+        }
+
+    private:
+        Periodic_Thread * _thread;
+    };
+
+    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
+
+public:
+    // struct Configuration: public Thread::Configuration {
+    //     Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+    //     : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
+
+    //     Microsecond period;
+    //     Microsecond deadline;
+    //     Microsecond capacity;
+    //     Microsecond activation;
+    //     unsigned int times;
+    // };
+
+public:
+    // template<typename ... Tn>
+    // Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+    typedef Alarm::Tick Tick;
+
+    template<typename ... Tn>
+    Periodic_Thread(const Tick & t, int (* entry)(Tn ...), Tn ... an)
+    : Thread(Thread::Configuration(SUSPENDED, Criterion(t)), entry, an ...),
+      _semaphore(0), _handler(&_semaphore, this), _alarm(t * Alarm::timer_period(), &_handler, INFINITE) { resume(); }
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+    //     if((conf.state == READY) || (conf.state == RUNNING)) {
+    //         _state = SUSPENDED;
+    //         resume();
+    //     } else
+    //         _state = conf.state;
+    // }
+
+    const Microsecond & period() const { return _alarm.period(); }
+    void period(const Microsecond & p) { _alarm.period(p); }
+
+    static volatile bool wait_next() {
+        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
+
+        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
+
+        if(t->_alarm.times())
+            t->_semaphore.p();
+
+        return t->_alarm.times();
+    }
+
+protected:
+    Semaphore _semaphore;
+    Handler _handler;
+    Alarm _alarm;
+};
+
+typedef Periodic_Thread::Configuration RTConf;
+
+__END_SYS
+
+#endif
diff --git a/include/scheduler.h b/include/scheduler.h
new file mode 100644
index 0000000..a1832a6
--- /dev/null
+++ b/include/scheduler.h
@@ -0,0 +1,174 @@
+// EPOS Scheduler Component Declarations
+
+#ifndef __scheduler_h
+#define __scheduler_h
+
+#include <architecture/cpu.h>
+#include <architecture/pmu.h>
+#include <architecture/tsc.h>
+#include <utility/scheduling.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+
+__BEGIN_SYS
+
+// All scheduling criteria, or disciplines, must define operator int() with
+// the semantics of returning the desired order of a given object within the
+// scheduling list
+class Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+    friend class _SYS::Clerk<System>;         // for _statistics
+
+public:
+    // Priorities
+    enum : int {
+        MAIN   = 0,
+        HIGH   = 1,
+        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
+        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2,
+        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+    };
+
+    // Constructor helpers
+    enum : unsigned int {
+        SAME        = 0,
+        NOW         = 0,
+        UNKNOWN     = 0,
+        ANY         = -1U
+    };
+
+    // Policy types
+    enum : int {
+        PERIODIC    = HIGH,
+        APERIODIC   = NORMAL,
+        SPORADIC    = NORMAL
+    };
+
+    // Policy traits
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+    static const bool collecting = false;
+    static const bool charging = false;
+    static const bool awarding = false;
+    static const bool migrating = false;
+    static const bool track_idle = false;
+    static const bool task_wide = false;
+    static const bool cpu_wide = false;
+    static const bool system_wide = false;
+    static const unsigned int QUEUES = 1;
+
+    // Runtime Statistics (for policies that don't use any; that´s why its a union)
+    union Statistics {
+        // Thread Execution Time
+        TSC::Time_Stamp thread_execution_time;  // accumulated thread execution time
+        TSC::Time_Stamp last_thread_dispatch;   // time stamp of last dispatch
+
+        // Deadline Miss count - Used By Clerk
+        Alarm * alarm_times;                    // pointer to RT_Thread private alarm (for monitoring purposes)
+        unsigned int finished_jobs;             // number of finished jobs given by the number of times alarm->p() was called for this thread
+        unsigned int missed_deadlines;          // number of missed deadlines given by the number of finished jobs (finished_jobs) minus the number of dispatched jobs (alarm_times->times)
+
+        // CPU Execution Time (capture ts)
+        static TSC::Time_Stamp _cpu_time[Traits<Build>::CPUS];              // accumulated CPU time in the current hyperperiod for each CPU
+        static TSC::Time_Stamp _last_dispatch_time[Traits<Build>::CPUS];    // time Stamp of last dispatch in each CPU
+        static TSC::Time_Stamp _last_activation_time;                       // global time stamp of the last heuristic activation
+    };
+
+protected:
+    Scheduling_Criterion_Common() {}
+
+public:
+    const Microsecond period() { return 0;}
+    void period(const Microsecond & p) {}
+
+    unsigned int queue() const { return 0; }
+    void queue(unsigned int q) {}
+
+    bool update() { return false; }
+
+    bool collect(bool end = false) { return false; }
+    bool charge(bool end = false) { return true; }
+    bool award(bool end = false) { return true; }
+
+    volatile Statistics & statistics() { return _statistics; }
+
+    static void init() {}
+
+protected:
+    Statistics _statistics;
+};
+
+// Priority (static and dynamic)
+class Priority: public Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+
+public:
+    template <typename ... Tn>
+    Priority(int p = NORMAL, Tn & ... an): _priority(p) {}
+
+    operator const volatile int() const volatile { return _priority; }
+
+protected:
+    volatile int _priority;
+};
+
+// Round-Robin
+class RR: public Priority
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    template <typename ... Tn>
+    RR(int p = NORMAL, Tn & ... an): Priority(p) {}
+};
+
+// First-Come, First-Served (FIFO)
+class FCFS: public Priority
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = false;
+
+public:
+    template <typename ... Tn>
+    FCFS(int p = NORMAL, Tn & ... an);
+};
+
+// Earliest Deadline First (EDF)
+class EDF: public Priority
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = true;
+    static const bool preemptive = true;
+
+    typedef int Tick;
+
+public:
+    EDF(int p = NORMAL): Priority(p), _period(p) {}
+    
+    bool update() {
+        if ((_priority % 6000) < 5)
+            _priority = _period;
+        else
+            _priority += _period;
+        return false;
+    }
+private:
+    Tick _period;
+};
+
+__END_SYS
+
+#endif
diff --git a/include/time.h b/include/time.h
index a024cb7..ff88b01 100644
--- a/include/time.h
+++ b/include/time.h
@@ -31,6 +31,7 @@ class Alarm
 {
     friend class System;                        // for init()
     friend class Alarm_Chronometer;             // for elapsed()
+    friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
     friend class FCFS;                          // for ticks() and elapsed()
 
 private:
@@ -47,15 +48,15 @@ public:
     void reset();
 
     static Hertz frequency() { return _timer->frequency(); }
+    static Microsecond timer_period() { return 1000000 / frequency(); }
+    static volatile Tick & elapsed() { return _elapsed; }
 
     static void delay(const Microsecond & time);
 
 private:
-    static void init();
+    unsigned int times() const { return _times; }
 
-    static volatile Tick & elapsed() { return _elapsed; }
 
-    static Microsecond timer_period() { return 1000000 / frequency(); }
     static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
 
     static void lock();
@@ -63,6 +64,8 @@ private:
 
     static void handler(IC::Interrupt_Id i);
 
+    static void init();
+
 private:
     Microsecond _time;
     Handler * _handler;
@@ -102,8 +105,6 @@ public:
     void stop() { lap(); }
 
     Microsecond read() { return ticks() * 1000000 / frequency(); }
-
-private:
     Time_Stamp ticks() {
         if(_start == 0)
             return 0;
@@ -112,6 +113,8 @@ private:
         return _stop - _start;
     }
 
+private:
+
 private:
     TSC tsc;
     Time_Stamp _start;
diff --git a/include/utility/heap.h b/include/utility/heap.h
index f377454..57fd84b 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -18,6 +18,9 @@ protected:
 public:
     using Grouping_List<char>::empty;
     using Grouping_List<char>::size;
+    using Grouping_List<char>::search_decrementing;
+    using Grouping_List<char>::find_first;
+    using Grouping_List<char>::find_worst;
 
     Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
@@ -30,8 +33,7 @@ public:
     }
 
     void * alloc(unsigned int bytes) {
-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
         if(!bytes)
             return 0;
 
@@ -45,6 +47,8 @@ public:
         if(bytes < sizeof(Element))
             bytes = sizeof(Element);
 
+        db<Heaps>(TRC) << "First Fit: " << find_first(bytes) << endl;
+        db<Heaps>(TRC) << "Worst Fit: " << find_worst(bytes) << endl;
         Element * e = search_decrementing(bytes);
         if(!e) {
             out_of_memory();
@@ -65,7 +69,7 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
-        if(ptr && (bytes >= sizeof(Element))) {
+        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
diff --git a/include/utility/list.h b/include/utility/list.h
index ccc8954..eca1174 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -1348,7 +1348,7 @@ public:
 
     Element * search_size(unsigned int s) {
         Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
+        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
         else
             for(; e && (e->size() < s); e = e->next());
@@ -1381,7 +1381,7 @@ public:
         print_head();
         print_tail();
 
-        Element * e = search_size(s);
+        Element * e = find_worst(s);
         if(e) {
             e->shrink(s);
             _grouped_size -= s;
@@ -1392,6 +1392,33 @@ public:
         return e;
     }
 
+    // Used by Heap/Worst-Fit
+    // for empty lists, return 0
+    // for nonempty lists,
+    //      return 0 if there is no element big enough to fit s
+    //      return the element with biggest size otherwise
+    // precons:
+    //  1. s >= sizeof(Element) [s >= 16]
+    Element * find_worst(unsigned int s) {
+        Element * max = 0;
+        unsigned max_size = 0;
+        for(Element * e = head(); e; e = e->next()) {
+            if (e->size() > max_size) {
+                max_size = e->size();
+                max = e;
+            }
+        }
+
+        if (max_size < s)
+            return 0;
+
+        return max;
+    }
+
+    Element * find_first(unsigned int s) {
+        return search_size(s);
+    }
+
 private:
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
diff --git a/makedefs b/makedefs
index 21674d9..9275107 100644
--- a/makedefs
+++ b/makedefs
@@ -103,7 +103,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
 pc_AS_FLAGS		:= --32
 pc_LD_FLAGS		:= -m elf_i386
 pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
-pc_DEBUGGER		:= gdb
+pc_DEBUGGER		:= gdb -tui
 pc_FLASHER		:=
 pc_MAGIC		:= --nmagic
 pc_CODE_NAME		:= .init
@@ -254,7 +254,7 @@ TLDFLAGS	:= -m32
 ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
@@ -315,7 +315,7 @@ TEE		:= tee
 ifndef DISPLAY
 TERM        := sh -c
 else
-TERM        := xterm -e
+TERM        := konsole -e
 endif
 
 TOUCH		:= touch
diff --git a/notes/diff_wf.txt b/notes/diff_wf.txt
new file mode 100644
index 0000000..71c8f8d
--- /dev/null
+++ b/notes/diff_wf.txt
@@ -0,0 +1,510 @@
+diff --git a/app/test/makefile b/app/test/makefile
+new file mode 100644
+index 0000000..8a6578a
+--- /dev/null
++++ b/app/test/makefile
+@@ -0,0 +1,17 @@
++# EPOS Application Makefile
++
++include ../../makedefs
++
++all: install
++
++$(APPLICATION):	$(APPLICATION).o $(LIB)/*
++		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
++
++$(APPLICATION).o: $(APPLICATION).cc $(SRC)
++		$(ACC) $(ACCFLAGS) -o $@ $<
++
++install: $(APPLICATION)
++		$(INSTALL) $(APPLICATION) $(IMG)
++
++clean:
++		$(CLEAN) *.o $(APPLICATION)
+diff --git a/app/test/notes_heap.txt b/app/test/notes_heap.txt
+new file mode 100644
+index 0000000..a11a5a3
+--- /dev/null
++++ b/app/test/notes_heap.txt
+@@ -0,0 +1,62 @@
++Machine:
++0x00020000k -> 128mb? (tah 128MB no traits)
++
++Heap:
++tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
++Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
++- Alarm_Timer (20 bytes)
++% Idle
++- Thread (36 bytes)
++- Stack (STACK_SIZE)
++% Main
++- Thread (36 bytes)
++- Stack (STACK_SIZE)
++- Scheduler_Timer(20 bytes)
++Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
++
++Allocs:
++MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
++MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
++MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
++Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
++Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
++% Idle
++Heap::alloc(this=0x80004064,bytes=36 (Thread)
++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
++% Main
++Heap::alloc(this=0x80004064,bytes=36 (Thread)
++Heap::alloc(this=0x80004064,bytes=16384 (Stack)
++Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
++MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
++Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
++MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
++Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
++
++Conclusoes:
++Quando chegamos na main(),
++
++1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
++2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
++3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
++4) A BOOT_STACK foi absorvida pela _heap
++5) A _free esta vazia (size=0; _grouped_size=0)
++6) So a _heap foi alocada em _free (em duas etapas)
++7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
++8) Tamanho inicial de _free=134201064
++9) sizeof(Page) = 1 e pages(x) = x  
++
++Desafios:
++A busca comeca em head e a insercao em tail?
++Aglutinacao e insert na lista?
++
++Matheus:
++explicar sequencia de inicializacao
++onde esta bootstack?
++onde eh inicializada a _free?
++quantos elementos tem _free antes de construir a heap de sistema?
++onde foram construidos?
++qnt retorna pages? (sizeof no gdb)
++algo foi alocado ah mais na MMU antes de criar a Heap?
++
++Teste:
++So precisa mostrar o algoritmo skippando um bloco que cabe?
+\ No newline at end of file
+diff --git a/app/test/notes_mmu.txt b/app/test/notes_mmu.txt
+new file mode 100644
+index 0000000..1239a86
+--- /dev/null
++++ b/app/test/notes_mmu.txt
+@@ -0,0 +1,3 @@
++Desafios:
++Em que momento liga paginacao na intel?
++Como que liga paginacao no rv32?
+diff --git a/app/test/test.cc b/app/test/test.cc
+new file mode 100644
+index 0000000..4a473a9
+--- /dev/null
++++ b/app/test/test.cc
+@@ -0,0 +1,34 @@
++// Description:
++// The Heap reaches main() containing two elements: E1 and E2.
++//    E1 begun from &_end to BOOT_STACK, but now has 32904 less bytes due to the allocations
++//  of System::init().
++//    E2 is still untouched and ranges from MEM_TOP to MEM_TOP-STACK_SIZE.
++// E1 is way larger than E2.
++//    In this test program, we allocate almost all of E1 so that Worst-Fit has to reach for E2
++//  in its second allocation (line 30).
++// For comparision purposes, we print how First Fit would have handled each allocation.
++
++#include <utility/ostream.h>
++
++using namespace EPOS;
++
++OStream cout;
++
++static const int SIZE_OF_E1 = 134201064 - 32904 - 16*1024;
++
++char * alloc(int bytes) {
++    return new char[bytes];
++}
++
++int main()
++{
++    // terminal output is important after the following line
++    cout << "Testing Worst-Fit..." << endl;
++
++    // leave less than a stack worth of memory on E1
++    alloc(SIZE_OF_E1 - 8*1024);
++    // this should go to E2
++    alloc(16); // will alloc 16+4 due to size
++
++    return 0;
++}
+diff --git a/app/test/test_traits.h b/app/test/test_traits.h
+new file mode 100644
+index 0000000..008c06f
+--- /dev/null
++++ b/app/test/test_traits.h
+@@ -0,0 +1,155 @@
++#ifndef __traits_h
++#define __traits_h
++
++#include <system/config.h>
++
++__BEGIN_SYS
++
++// Build
++template<> struct Traits<Build>: public Traits_Tokens
++{
++    // Basic configuration
++    static const unsigned int MODE = LIBRARY;
++    static const unsigned int ARCHITECTURE = RV32;
++    static const unsigned int MACHINE = RISCV;
++    static const unsigned int MODEL = SiFive_E;
++    static const unsigned int CPUS = 1;
++    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
++    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
++
++    // Default flags
++    static const bool enabled = true;
++    static const bool monitored = false;
++    static const bool debugged = true;
++    static const bool hysterically_debugged = false;
++
++    // Default aspects
++    typedef ALIST<> ASPECTS;
++};
++
++
++// Utilities
++template<> struct Traits<Debug>: public Traits<Build>
++{
++    static const bool error   = true;
++    static const bool warning = true;
++    static const bool info    = false;
++    static const bool trace   = false;
++};
++
++template<> struct Traits<Lists>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Spin>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Heaps>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++template<> struct Traits<Observers>: public Traits<Build>
++{
++    // Some observed objects are created before initializing the Display
++    // Enabling debug may cause trouble in some Machines
++    static const bool debugged = false;
++};
++
++
++// System Parts (mostly to fine control debugging)
++template<> struct Traits<Boot>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Setup>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Init>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Framework>: public Traits<Build>
++{
++};
++
++template<> struct Traits<Aspect>: public Traits<Build>
++{
++    static const bool debugged = hysterically_debugged;
++};
++
++
++__END_SYS
++
++// Mediators
++#include __ARCHITECTURE_TRAITS_H
++#include __MACHINE_TRAITS_H
++
++__BEGIN_SYS
++
++
++// API Components
++template<> struct Traits<Application>: public Traits<Build>
++{
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
++    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
++};
++
++template<> struct Traits<System>: public Traits<Build>
++{
++    static const unsigned int mode = Traits<Build>::MODE;
++    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
++    static const bool multitask = (mode != Traits<Build>::LIBRARY);
++    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
++    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
++
++    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
++    static const unsigned int DUTY_CYCLE = 1000000; // ppm
++
++    static const bool reboot = true;
++
++    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
++    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
++};
++
++template<> struct Traits<Task>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multitask;
++};
++
++template<> struct Traits<Thread>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++    static const bool smp = Traits<System>::multicore;
++    static const bool trace_idle = hysterically_debugged;
++    static const bool simulate_capacity = false;
++
++    static const bool preemptive = true;
++    static const unsigned int QUANTUM = 10000; // us
++};
++
++template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
++{
++    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
++};
++
++template<> struct Traits<Synchronizer>: public Traits<Build>
++{
++    static const bool enabled = Traits<System>::multithread;
++};
++
++template<> struct Traits<Alarm>: public Traits<Build>
++{
++    static const bool visible = hysterically_debugged;
++};
++
++
++
++__END_SYS
++
++#endif
+diff --git a/img/makefile b/img/makefile
+index f048773..0799121 100644
+--- a/img/makefile
++++ b/img/makefile
+@@ -83,7 +83,7 @@ endif
+ 
+ debug:		$(IMAGE)
+ ifeq ($(NODES),1)
+-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
++		$(EMULATOR)$(IMAGE) &
+ 		$(DEBUGGER)
+ else
+ 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
+@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
+ 		@echo "Running $(APPLICATION) ..."
+ posrun_$(APPLICATION):
+ 		@echo "done!"
+-		
++
+ FORCE:
+diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
+index 1c809b2..59fe619 100644
+--- a/include/architecture/rv32/rv32_mmu.h
++++ b/include/architecture/rv32/rv32_mmu.h
+@@ -105,6 +105,7 @@ public:
+                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
+         }
+         db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
++        kout << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+ 
+         return phy;
+     };
+@@ -117,7 +118,7 @@ public:
+ 
+     static void free(Phy_Addr addr, unsigned int n = 1) {
+         db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
+-
++        kout << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
+         // No unaligned addresses if the CPU doesn't support it
+         assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
+ 
+diff --git a/include/utility/heap.h b/include/utility/heap.h
+index f377454..0235644 100644
+--- a/include/utility/heap.h
++++ b/include/utility/heap.h
+@@ -18,6 +18,9 @@ protected:
+ public:
+     using Grouping_List<char>::empty;
+     using Grouping_List<char>::size;
++    using Grouping_List<char>::search_decrementing;
++    using Grouping_List<char>::find_first;
++    using Grouping_List<char>::find_worst;
+ 
+     Heap() {
+         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
+@@ -30,8 +33,8 @@ public:
+     }
+ 
+     void * alloc(unsigned int bytes) {
+-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
+-
++        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
++        kout << "Heap::alloc(this=" << this << ",bytes=" << bytes  << ")" << endl;
+         if(!bytes)
+             return 0;
+ 
+@@ -45,6 +48,8 @@ public:
+         if(bytes < sizeof(Element))
+             bytes = sizeof(Element);
+ 
++        kout << "First Fit: " << find_first(bytes) << endl;
++        kout << "Worst Fit: " << find_worst(bytes) << endl;
+         Element * e = search_decrementing(bytes);
+         if(!e) {
+             out_of_memory();
+@@ -65,11 +70,12 @@ public:
+     void free(void * ptr, unsigned int bytes) {
+         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
+ 
+-        if(ptr && (bytes >= sizeof(Element))) {
++        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
+             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
+             Element * m1, * m2;
+             insert_merging(e, &m1, &m2);
+         }
++        kout << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
+     }
+ 
+     static void typed_free(void * ptr) {
+diff --git a/include/utility/list.h b/include/utility/list.h
+index ccc8954..eca1174 100644
+--- a/include/utility/list.h
++++ b/include/utility/list.h
+@@ -1348,7 +1348,7 @@ public:
+ 
+     Element * search_size(unsigned int s) {
+         Element * e = head();
+-        if(sizeof(Object_Type) < sizeof(Element))
++        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
+             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
+         else
+             for(; e && (e->size() < s); e = e->next());
+@@ -1381,7 +1381,7 @@ public:
+         print_head();
+         print_tail();
+ 
+-        Element * e = search_size(s);
++        Element * e = find_worst(s);
+         if(e) {
+             e->shrink(s);
+             _grouped_size -= s;
+@@ -1392,6 +1392,33 @@ public:
+         return e;
+     }
+ 
++    // Used by Heap/Worst-Fit
++    // for empty lists, return 0
++    // for nonempty lists,
++    //      return 0 if there is no element big enough to fit s
++    //      return the element with biggest size otherwise
++    // precons:
++    //  1. s >= sizeof(Element) [s >= 16]
++    Element * find_worst(unsigned int s) {
++        Element * max = 0;
++        unsigned max_size = 0;
++        for(Element * e = head(); e; e = e->next()) {
++            if (e->size() > max_size) {
++                max_size = e->size();
++                max = e;
++            }
++        }
++
++        if (max_size < s)
++            return 0;
++
++        return max;
++    }
++
++    Element * find_first(unsigned int s) {
++        return search_size(s);
++    }
++
+ private:
+     Element * search_left(const Object_Type * obj) {
+         Element * e = head();
+diff --git a/makedefs b/makedefs
+index 21674d9..9275107 100644
+--- a/makedefs
++++ b/makedefs
+@@ -103,7 +103,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
+ pc_AS_FLAGS		:= --32
+ pc_LD_FLAGS		:= -m elf_i386
+ pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
+-pc_DEBUGGER		:= gdb
++pc_DEBUGGER		:= gdb -tui
+ pc_FLASHER		:=
+ pc_MAGIC		:= --nmagic
+ pc_CODE_NAME		:= .init
+@@ -254,7 +254,7 @@ TLDFLAGS	:= -m32
+ ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
+ AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
++ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
+ ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
+ 
+ # Tools and flags to compile the system
+@@ -315,7 +315,7 @@ TEE		:= tee
+ ifndef DISPLAY
+ TERM        := sh -c
+ else
+-TERM        := xterm -e
++TERM        := konsole -e
+ endif
+ 
+ TOUCH		:= touch
+diff --git a/src/api/thread.cc b/src/api/thread.cc
+index fdd0583..12cb8e7 100644
+--- a/src/api/thread.cc
++++ b/src/api/thread.cc
+@@ -295,7 +295,6 @@ void Thread::reschedule()
+     yield();
+ }
+ 
+-
+ void Thread::time_slicer(IC::Interrupt_Id i)
+ {
+     reschedule();
+diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
+index c54f943..fb06a1b 100755
+--- a/tools/eposctors/eposctors
++++ b/tools/eposctors/eposctors
+@@ -13,11 +13,13 @@ FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '
+ 
+ echo "CTOR_LIST:"
+ if [ "$GDB" = "" ] ; then
+-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
++    LIST=`hexdump -s $INIT_ARRAY_OFFSET -n $INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
++
+     for item in $LIST; do
++        # echo $item
+         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
+         echo 0x$item $sym
+-    done   
++    done
+ else
+     hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "break *0x%08x\n"' $ELF
+ fi
diff --git a/notes/notes_edf.txt b/notes/notes_edf.txt
new file mode 100644
index 0000000..5f9391c
--- /dev/null
+++ b/notes/notes_edf.txt
@@ -0,0 +1,150 @@
+Preemptive:
+Coisas que fazem reescalonar
+    1. Criacao de Thread READY com PRIO > IDLE
+    2. Thread::priority
+    3. Thread::resume
+    4. Thread::wakeup/wakeup_all (~resume)
+
+Periodic_Thread
+    wait_next() faz esperar no semaforo
+
+
+QUANTUM = 10000 us 
+FREQUENCY = 1000 Ticks/s
+PERIOD = 0.001 s => 1000 us => 1ms
+1 Quantum = 10 Ticks
+
+End: A, Prio=2000 [952]
+Begin: B, Prio=3000 [952]
+Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)
+End: B, Prio=3000 [2402]
+Begin: A, Prio=4000 [2402]
+Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)
+End: A, Prio=4000 [3352]
+Begin: B, Prio=6000 [3352]
+Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)
+Begin: A, Prio=6000 [4000]
+End: A, Prio=6000 [4950]
+End: B, Prio=6000 [5753]
+Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)
+Begin: B, Prio=3000 [6000]
+Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)
+Begin: A, Prio=2000 [6001]
+End: A, Prio=2000 [6951]
+Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)
+End: B, Prio=3000 [8401]
+Begin: A, Prio=4000 [8401]
+Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
+End: A, Prio=4000 [9351]
+Begin: B, Prio=6000 [9351]
+Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
+Begin: A, Prio=6000 [10001]
+End: A, Prio=6000 [10951]
+End: B, Prio=6000 [11752]
+Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
+Begin: B, Prio=3000 [12000]
+Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
+Begin: A, Prio=2000 [12001]
+End: A, Prio=2000 [12951]
+Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
+End: B, Prio=3000 [14401]
+Begin: A, Prio=4000 [14401]
+Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
+End: A, Prio=4000 [15351]
+Begin: B, Prio=6000 [15351]
+Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
+Begin: A, Prio=6000 [16001]
+The last thread has exited!
+
+2)
+End: A, Prio=2000 [952]                                                       �
+Begin: B, Prio=3000 [952]
+Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)                           �
+End: B, Prio=3000 [2402]
+Begin: A, Prio=4000 [2402]                                                    �
+Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)                           �
+End: A, Prio=4000 [3352]                                                      �
+Begin: B, Prio=6000 [3352]
+Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)                           �
+Begin: A, Prio=6000 [4000]
+End: A, Prio=6000 [4950]                                                      �
+End: B, Prio=6000 [5753]                                                      �
+Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)                           A
+Begin: B, Prio=3000 [6000]
+Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)                           �
+Begin: A, Prio=2000 [6001]                                                    �
+End: A, Prio=2000 [6951]
+Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)                           �
+End: B, Prio=3000 [8401]
+Begin: A, Prio=4000 [8401]
+Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
+End: A, Prio=4000 [9351]
+Begin: B, Prio=6000 [9351]
+Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
+Begin: A, Prio=6000 [10001]
+End: A, Prio=6000 [10951]
+End: B, Prio=6000 [11752]
+Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
+Begin: B, Prio=3000 [12000]
+Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
+Begin: A, Prio=2000 [12001]
+End: A, Prio=2000 [12951]
+Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
+End: B, Prio=3000 [14401]
+Begin: A, Prio=4000 [14401]
+Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
+End: A, Prio=4000 [15351]
+Begin: B, Prio=6000 [15351]
+Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
+Begin: A, Prio=6000 [16001]
+
+Comparing resets:
+
+1)
+
+End: A, Prio=2000 [952]                                                       �
+Begin: B, Prio=3000 [952]
+Alarm::handler(this=0x87ff3f44,e=2000,h=0x8000125c)                           �
+End: B, Prio=3000 [2402]
+Begin: A, Prio=4000 [2402]                                                    �
+Alarm::handler(this=0x87fefec4,e=3000,h=0x8000125c)                           �
+End: A, Prio=4000 [3352]                                                      �
+Begin: B, Prio=6000 [3352]
+Alarm::handler(this=0x87ff3f44,e=4000,h=0x8000125c)                           �
+Begin: A, Prio=6000 [4000]
+End: A, Prio=6000 [4950]                                                      �
+End: B, Prio=6000 [5753]     
+
+2)
+
+Alarm::handler(this=0x87fefec4,e=6000,h=0x8000125c)                           A
+Begin: B, Prio=3000 [6000]
+Alarm::handler(this=0x87ff3f44,e=6001,h=0x8000125c)                           �
+Begin: A, Prio=2000 [6001]                                                    �
+End: A, Prio=2000 [6951]
+Alarm::handler(this=0x87ff3f44,e=8001,h=0x8000125c)                           �
+End: B, Prio=3000 [8401]
+Begin: A, Prio=4000 [8401]
+Alarm::handler(this=0x87fefec4,e=9000,h=0x8000125c)
+End: A, Prio=4000 [9351]
+Begin: B, Prio=6000 [9351]
+Alarm::handler(this=0x87ff3f44,e=10001,h=0x8000125c)
+Begin: A, Prio=6000 [10001]
+End: A, Prio=6000 [10951]
+End: B, Prio=6000 [11752]
+
+3)
+
+Alarm::handler(this=0x87fefec4,e=12000,h=0x8000125c)
+Begin: B, Prio=3000 [12000]
+Alarm::handler(this=0x87ff3f44,e=12001,h=0x8000125c)
+Begin: A, Prio=2000 [12001]
+End: A, Prio=2000 [12951]
+Alarm::handler(this=0x87ff3f44,e=14001,h=0x8000125c)
+End: B, Prio=3000 [14401]
+Begin: A, Prio=4000 [14401]
+Alarm::handler(this=0x87fefec4,e=15000,h=0x8000125c)
+End: A, Prio=4000 [15351]
+Begin: B, Prio=6000 [15351]
+Alarm::handler(this=0x87ff3f44,e=16001,h=0x8000125c)
+Begin: A, Prio=6000 [16001]
\ No newline at end of file
diff --git a/notes/notes_heap.txt b/notes/notes_heap.txt
new file mode 100644
index 0000000..315169d
--- /dev/null
+++ b/notes/notes_heap.txt
@@ -0,0 +1,64 @@
+Machine:
+0x00020000k -> 128mb? (tah 128MB no traits)
+
+Heap:
+tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
+Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
+- Alarm_Timer (20 bytes)
+% Idle
+- Thread (36 bytes)
+- Stack (STACK_SIZE)
+% Main
+- Thread (36 bytes)
+- Stack (STACK_SIZE)
+- Scheduler_Timer(20 bytes)
+Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
+
+Allocs:
+MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
+MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
+MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
+Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
+Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
+% Idle
+Heap::alloc(this=0x80004064,bytes=36 (Thread)
+Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+% Main
+Heap::alloc(this=0x80004064,bytes=36 (Thread)
+Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
+MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
+Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
+MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
+Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
+
+Conclusoes:
+Quando chegamos na main(),
+
+1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
+2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
+3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
+4) A BOOT_STACK foi absorvida pela _heap
+5) A _free esta vazia (size=0; _grouped_size=0)
+6) So a _heap foi alocada em _free (em duas etapas)
+7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
+8) Tamanho inicial de _free=134201064
+9) sizeof(Page) = 1 e pages(x) = x  
+
+Desafios:
+Aglutinacao e insert na lista?
+
+Multiheap:
+Application::_heap tem 16Mb enquanto System::_heap tem 272Kb
+
+Matheus:
+explicar sequencia de inicializacao
+onde esta bootstack?
+onde eh inicializada a _free?
+quantos elementos tem _free antes de construir a heap de sistema?
+onde foram construidos?
+qnt retorna pages? (sizeof no gdb)
+algo foi alocado ah mais na MMU antes de criar a Heap?
+
+Teste:
+So precisa mostrar o algoritmo skippando um bloco que cabe?
\ No newline at end of file
diff --git a/notes/notes_mmu.txt b/notes/notes_mmu.txt
new file mode 100644
index 0000000..1239a86
--- /dev/null
+++ b/notes/notes_mmu.txt
@@ -0,0 +1,3 @@
+Desafios:
+Em que momento liga paginacao na intel?
+Como que liga paginacao no rv32?
diff --git a/src/api/alarm.cc b/src/api/alarm.cc
index 3352a3a..0340657 100644
--- a/src/api/alarm.cc
+++ b/src/api/alarm.cc
@@ -120,9 +120,10 @@ void Alarm::handler(IC::Interrupt_Id i)
     }
 
     unlock();
+    // kout << "*";
 
     if(alarm) {
-        db<Alarm>(TRC) << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
+        kout << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
         (*alarm->_handler)();
     }
 }
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
new file mode 100644
index 0000000..751633d
--- /dev/null
+++ b/src/api/scheduler.cc
@@ -0,0 +1,14 @@
+// EPOS CPU Scheduler Component Implementation
+
+#include <process.h>
+#include <time.h>
+
+__BEGIN_SYS
+
+// The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
+template <typename ... Tn>
+FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
+
+template FCFS::FCFS<>(int p);
+
+__END_SYS
diff --git a/src/api/segment.cc b/src/api/segment.cc
index 9ae9b96..7c7634b 100644
--- a/src/api/segment.cc
+++ b/src/api/segment.cc
@@ -5,9 +5,9 @@
 __BEGIN_SYS
 
 // Methods
-Segment::Segment(unsigned int bytes, const Color & color, const Flags & flags): Chunk(bytes, flags, color)
+Segment::Segment(unsigned int bytes, const Flags & flags): Chunk(bytes, flags)
 {
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",color=" << color << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
 }
 
 
diff --git a/src/api/thread.cc b/src/api/thread.cc
index fdd0583..3d5e6f5 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -11,20 +11,17 @@ __END_UTIL
 
 __BEGIN_SYS
 
-extern "C" { void __epos_app_entry(); }
-
 volatile unsigned int Thread::_thread_count;
 Scheduler_Timer * Thread::_timer;
+Scheduler<Thread> Thread::_scheduler;
 
-Thread* volatile Thread::_running;
-Thread::Queue Thread::_ready;
-Thread::Queue Thread::_suspended;
 
 void Thread::constructor_prologue(unsigned int stack_size)
 {
     lock();
 
     _thread_count++;
+    _scheduler.insert(this);
 
     _stack = new (SYSTEM) char[stack_size];
 }
@@ -42,13 +39,8 @@ void Thread::constructor_epilogue(const Log_Addr & entry, unsigned int stack_siz
 
     assert((_state != WAITING) && (_state != FINISHING)); // Invalid states
 
-    switch(_state) {
-        case RUNNING: assert(entry == __epos_app_entry); break;
-        case READY: _ready.insert(&_link); break;
-        case SUSPENDED: _suspended.insert(&_link); break;
-        case WAITING: break;   // invalid state, for switch completion only
-        case FINISHING: break; // invalid state, for switch completion only
-    }
+    if((_state != READY) && (_state != RUNNING))
+        _scheduler.suspend(this);
 
     if(preemptive && (_state == READY) && (_link.rank() != IDLE))
         reschedule();
@@ -76,15 +68,18 @@ Thread::~Thread()
         exit(-1);
         break;
     case READY:
-        _ready.remove(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case SUSPENDED:
-        _suspended.remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case WAITING:
         _waiting->remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case FINISHING: // Already called exit()
@@ -100,6 +95,26 @@ Thread::~Thread()
 }
 
 
+void Thread::priority(const Priority & c)
+{
+    lock();
+
+    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+
+    _link.rank(Criterion(c));
+
+    if(_state != RUNNING) { // reorder the scheduling queue
+        _scheduler.remove(this);
+        _scheduler.insert(this);
+    }
+
+    if(preemptive)
+        reschedule();
+
+    unlock();
+}
+
+
 int Thread::join()
 {
     lock();
@@ -113,10 +128,18 @@ int Thread::join()
     assert(!_joining);
 
     if(_state != FINISHING) {
-        _joining = running();
-        _joining->suspend(true);
-    } else
-        unlock();
+        Thread * prev = running();
+
+        _joining = prev;
+        prev->_state = SUSPENDED;
+        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+
+        Thread * next = _scheduler.chosen();
+
+        dispatch(prev, next);
+    }
+
+    unlock();
 
     return *reinterpret_cast<int *>(_stack);
 }
@@ -128,56 +151,48 @@ void Thread::pass()
 
     db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
-
-    _ready.remove(this);
-    _state = RUNNING;
-    _running = this;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose(this);
 
-    dispatch(prev, this);
+    if(next)
+        dispatch(prev, next, false);
+    else
+        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
 
     unlock();
 }
 
 
-void Thread::suspend(bool locked)
+void Thread::suspend()
 {
-    if(!locked)
-        lock();
+    lock();
 
     db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    if(_running != this)
-        _ready.remove(this);
+    Thread * prev = running();
 
     _state = SUSPENDED;
-    _suspended.insert(&_link);
+    _scheduler.suspend(this);
 
-    if(_running == this) {
-        _running = _ready.remove()->object();
-        _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-        dispatch(this, _running);
-    }
+    dispatch(prev, next);
 
     unlock();
 }
 
 
-void Thread::resume(bool unpreemptive)
+void Thread::resume()
 {
     lock();
 
     db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
 
     if(_state == SUSPENDED) {
-        _suspended.remove(this);
         _state = READY;
-        _ready.insert(&_link);
+        _scheduler.resume(this);
 
-        if(preemptive && !unpreemptive)
+        if(preemptive)
             reschedule();
     } else
         db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
@@ -191,16 +206,12 @@ void Thread::yield()
 {
     lock();
 
-    db<Thread>(TRC) << "Thread::yield(running=" << _running << ")" << endl;
-
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
+    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose_another();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -212,23 +223,22 @@ void Thread::exit(int status)
 
     db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    Thread * prev = _running;
+    Thread * prev = running();
+    _scheduler.remove(prev);
     prev->_state = FINISHING;
     *reinterpret_cast<int *>(prev->_stack) = status;
 
     _thread_count--;
 
     if(prev->_joining) {
-        Thread * joining = prev->_joining;
+        prev->_joining->_state = READY;
+        _scheduler.resume(prev->_joining);
         prev->_joining = 0;
-        joining->resume(true);
-        lock();
     }
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.choose(); // at least idle will always be there
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -241,14 +251,14 @@ void Thread::sleep(Queue * q)
     assert(locked()); // locking handled by caller
 
     Thread * prev = running();
+    _scheduler.suspend(prev);
     prev->_state = WAITING;
     prev->_waiting = q;
     q->insert(&prev->_link);
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 }
 
 
@@ -262,7 +272,7 @@ void Thread::wakeup(Queue * q)
         Thread * t = q->remove()->object();
         t->_state = READY;
         t->_waiting = 0;
-        _ready.insert(&t->_link);
+        _scheduler.resume(t);
 
         if(preemptive)
             reschedule();
@@ -281,7 +291,7 @@ void Thread::wakeup_all(Queue * q)
             Thread * t = q->remove()->object();
             t->_state = READY;
             t->_waiting = 0;
-            _ready.insert(&t->_link);
+            _scheduler.resume(t);
         }
 
         if(preemptive)
@@ -292,21 +302,38 @@ void Thread::wakeup_all(Queue * q)
 
 void Thread::reschedule()
 {
-    yield();
-}
+    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
+        db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
+    assert(locked()); // locking handled by caller
+
+    Thread * prev = running();
+    Thread * next = _scheduler.choose();
+
+    dispatch(prev, next);
+}
 
 void Thread::time_slicer(IC::Interrupt_Id i)
 {
+    lock();
     reschedule();
+    unlock();
 }
 
 
-void Thread::dispatch(Thread * prev, Thread * next)
+void Thread::dispatch(Thread * prev, Thread * next, bool charge)
 {
+    // "next" is not in the scheduler's queue anymore. It's already "chosen"
+
+    if(charge) {
+        if(Criterion::timed)
+            _timer->restart();
+    }
+
     if(prev != next) {
-        assert(prev->_state != RUNNING);
-        assert(next->_state == RUNNING);
+        if(prev->_state == RUNNING)
+            prev->_state = READY;
+        next->_state = RUNNING;
 
         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
         db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index db05478..f36c3af 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -13,10 +13,20 @@ void Thread::init()
 {
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
 
-    // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
-    // which will directly call main(). In this case, _init will have already been called,
-    // before Init_Application to construct MAIN's global objects.
-    Thread::_running = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
+    typedef int (Main)();
+
+    System_Info * si = System::info();
+    Main * main;
+
+    if(Traits<System>::multitask)
+        main = reinterpret_cast<Main *>(si->lm.app_entry);
+    else
+        // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
+        // which will directly call main(). In this case, _init will have already been called,
+        // before Init_Application to construct MAIN's global objects.
+        main = reinterpret_cast<Main *>(__epos_app_entry);
+
+    new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), main);
 
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
     new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
@@ -27,7 +37,7 @@ void Thread::init()
     // Letting reschedule() happen during thread creation is also harmless, since MAIN is
     // created first and dispatch won't replace it nor by itself neither by IDLE (which
     // has a lower priority)
-    if(preemptive)
+    if(Criterion::timed)
         _timer = new (SYSTEM) Scheduler_Timer(QUANTUM, time_slicer);
 
     // No more interrupts until we reach init_first
diff --git a/src/architecture/armv7/armv7_crtend.c b/src/architecture/armv7/armv7_crtend.c
index 84ae9b3..78a6b11 100644
--- a/src/architecture/armv7/armv7_crtend.c
+++ b/src/architecture/armv7/armv7_crtend.c
@@ -16,5 +16,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/ia32/ia32_crtend.c b/src/architecture/ia32/ia32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/ia32/ia32_crtend.c
+++ b/src/architecture/ia32/ia32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_crtend.c b/src/architecture/rv32/rv32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv32/rv32_crtend.c
+++ b/src/architecture/rv32/rv32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv64/rv64_crtend.c b/src/architecture/rv64/rv64_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv64/rv64_crtend.c
+++ b/src/architecture/rv64/rv64_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/init/init_first.cc b/src/init/init_first.cc
index cef9299..73faf01 100644
--- a/src/init/init_first.cc
+++ b/src/init/init_first.cc
@@ -18,13 +18,17 @@ public:
 
         db<Init>(INF) << "INIT ends here!" << endl;
 
-        db<Init, Thread>(INF) << "Dispatching the first thread: " << Thread::running() << endl;
+        // Thread::self() and Task::self() can be safely called after the construction of MAIN
+        // even if no reschedule() was called (running is set by the Scheduler at each insert())
+        Thread * first = Thread::self();
+
+        db<Init, Thread>(INF) << "Dispatching the first thread: " << first << endl;
 
         // Interrupts have been disable at Thread::init() and will be reenabled by CPU::Context::load()
         // but we first reset the timer to avoid getting a time interrupt during load()
         Timer::reset();
         CPU::int_enable();
-        Thread::running()->_context->load();
+        first->_context->load();
     }
 };
 
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index d3c373f..c9311cf 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -25,9 +25,11 @@ public:
         // Initialize System's heap
         db<Init>(INF) << "Initializing system's heap: " << endl;
         if(Traits<System>::multiheap) {
-            Segment * tmp = reinterpret_cast<Segment *>(&System::_preheap[0]);
-            System::_heap_segment = new (tmp) Segment(HEAP_SIZE, WHITE, Segment::Flags::SYS);
-            System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
+            System::_heap_segment = new (&System::_preheap[0]) Segment(HEAP_SIZE, Segment::Flags::SYS);
+            if(Memory_Map::SYS_HEAP == Traits<Machine>::NOT_USED)
+            	System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment), System::_heap_segment->size());
+            else
+                System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
         } else
             System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
         db<Init>(INF) << "done!" << endl;
diff --git a/tests/active_test/active_test.cc b/tests/active_test/active_test.cc
new file mode 100644
index 0000000..a7bd4cc
--- /dev/null
+++ b/tests/active_test/active_test.cc
@@ -0,0 +1,63 @@
+// EPOS Active Object Component Test Program
+
+#include <process.h>
+
+using namespace EPOS;
+
+const int iterations = 100;
+
+OStream cout;
+
+class A: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "a";
+            cout << endl;
+        }
+
+        return 'A';
+    }
+};
+
+class B: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "b";
+            cout << endl;
+        }
+
+        return 'B';
+    }
+};
+
+int main()
+{
+    cout << "Active Object Test" << endl;
+
+    A * a = new A;
+    B * b = new B;
+
+    a->start();
+    b->start();
+
+    cout << "Both threads are now done and have suspended themselves. I'll now wake them up so they can exit ..." << endl;
+
+    int status_a = a->join();
+    int status_b = b->join();
+
+    cout << "Thread A exited with status " << status_a
+ 	 << " and thread B exited with status " << status_b << endl;
+
+    delete a;
+    delete b;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
new file mode 100644
index 0000000..4642f73
--- /dev/null
+++ b/tests/active_test/active_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 1000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/active_test/makefile b/tests/active_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/active_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index 609d140..0f9a2d0 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = IA32;
-    static const unsigned int MACHINE = PC;
-    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/tests/segment_test/makefile b/tests/segment_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/segment_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
new file mode 100644
index 0000000..67c0759
--- /dev/null
+++ b/tests/segment_test/segment_test.cc
@@ -0,0 +1,50 @@
+// EPOS Segment Test Program
+
+#include <memory.h>
+
+using namespace EPOS;
+
+const unsigned ES1_SIZE = 10000;
+const unsigned ES2_SIZE = 100000;
+
+int main()
+{
+    OStream cout;
+
+    cout << "Segment test" << endl;
+
+    cout << "My address space's page directory is located at "
+         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
+    Address_Space self(MMU::current());
+
+    cout << "Creating two extra data segments:" << endl;
+    Segment * es1 = new (SYSTEM) Segment(ES1_SIZE);
+    Segment * es2 = new (SYSTEM) Segment(ES2_SIZE);
+    cout << "  extra segment 1 => " << ES1_SIZE << " bytes, done!" << endl;
+    cout << "  extra segment 2 => " << ES2_SIZE << " bytes, done!" << endl;
+
+    cout << "Attaching segments:" << endl;
+    CPU::Log_Addr * extra1 = self.attach(es1);
+    CPU::Log_Addr * extra2 = self.attach(es2);
+    cout << "  extra segment 1 => " << extra1 << " done!" << endl;
+    cout << "  extra segment 2 => " << extra2 << " done!" << endl;
+
+    cout << "Clearing segments:";
+    memset(extra1, 0, ES1_SIZE);
+    memset(extra2, 0, ES2_SIZE);
+    cout << "  done!" << endl;
+
+    cout << "Detaching segments:";
+    self.detach(es1);
+    self.detach(es2);
+    cout << "  done!" << endl;
+
+    cout << "Deleting segments:";
+    delete es1;
+    delete es2;
+    cout << "  done!" << endl;
+
+    cout << "I'm done, bye!" << endl;
+
+    return 0;
+}
diff --git a/tests/segment_test/segment_test_traits.h b/tests/segment_test/segment_test_traits.h
new file mode 100644
index 0000000..d1ca6d5
--- /dev/null
+++ b/tests/segment_test/segment_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
index c54f943..fb06a1b 100755
--- a/tools/eposctors/eposctors
+++ b/tools/eposctors/eposctors
@@ -13,11 +13,13 @@ FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '
 
 echo "CTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    LIST=`hexdump -s $INIT_ARRAY_OFFSET -n $INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+
     for item in $LIST; do
+        # echo $item
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
         echo 0x$item $sym
-    done   
+    done
 else
     hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "break *0x%08x\n"' $ELF
 fi
