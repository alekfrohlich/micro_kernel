diff --git a/app/test/makefile b/app/test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test/notes_heap.txt b/app/test/notes_heap.txt
new file mode 100644
index 0000000..a11a5a3
--- /dev/null
+++ b/app/test/notes_heap.txt
@@ -0,0 +1,62 @@
+Machine:
+0x00020000k -> 128mb? (tah 128MB no traits)
+
+Heap:
+tamanho inicial da Heap (HEAP_SIZE) = (MAX_THREADS=16 + 1) * STACK_SIZE=16*1024 = 278528
+Sequencia de uso da Heap de sistema (soma 4 em cada pcausa de size):
+- Alarm_Timer (20 bytes)
+% Idle
+- Thread (36 bytes)
+- Stack (STACK_SIZE)
+% Main
+- Thread (36 bytes)
+- Stack (STACK_SIZE)
+- Scheduler_Timer(20 bytes)
+Ocupado de E1: 2*20+2*36+2*16*1024+4*6 = 32904 bytes
+
+Allocs:
+MMU::free(addr=0x80004118,n=134184680) (Toda RAM, menos BOOT_STACK)
+MMU::free(addr=0x87ffc000,n=16384) (BOOT_STACK em um segundo elemento)
+MMU::alloc(bytes=278528) => 0x87fb8000 (Heap de sistema)
+Heap::free(this=0x80004064,ptr=0x87fb8000,bytes=278528) (Heap de sistema se populando)
+Heap::alloc(this=0x80004064,bytes=20 (Alarm_Timer)
+% Idle
+Heap::alloc(this=0x80004064,bytes=36 (Thread)
+Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+% Main
+Heap::alloc(this=0x80004064,bytes=36 (Thread)
+Heap::alloc(this=0x80004064,bytes=16384 (Stack)
+Heap::alloc(this=0x80004064,bytes=20 (Scheduler_Timer)
+MMU::alloc(bytes=133906152) => 0x80004118 (o que tinha sobrado do primeiro elemento)
+Heap::free(this=0x80004064,ptr=0x80004118,bytes=133906152)
+MMU::alloc(bytes=16384) => 0x87ffc000 (recuperando a BOOT_STACK)
+Heap::free(this=0x80004064,ptr=0x87ffc000,bytes=16384)
+
+Conclusoes:
+Quando chegamos na main(),
+
+1) 32904 bytes eh o que de fato esta ocupado em _heap (vale lembrar que toda memoria de _free foi transferida para _heap em init_application)
+2) Ha dois elementos em _heap: head=E1; tail=E2=BOOT_STACK
+3) Nada foi deletado; ou seja, a _heap nao esta fragmentada
+4) A BOOT_STACK foi absorvida pela _heap
+5) A _free esta vazia (size=0; _grouped_size=0)
+6) So a _heap foi alocada em _free (em duas etapas)
+7) _free comeca particionada em dois elementos: tudo [&_end,BOOT_STACK-THREAD_SIZE]; stack temp [BOOT_STACK-THREAD_SIZE, BOOT_STACK]
+8) Tamanho inicial de _free=134201064
+9) sizeof(Page) = 1 e pages(x) = x  
+
+Desafios:
+A busca comeca em head e a insercao em tail?
+Aglutinacao e insert na lista?
+
+Matheus:
+explicar sequencia de inicializacao
+onde esta bootstack?
+onde eh inicializada a _free?
+quantos elementos tem _free antes de construir a heap de sistema?
+onde foram construidos?
+qnt retorna pages? (sizeof no gdb)
+algo foi alocado ah mais na MMU antes de criar a Heap?
+
+Teste:
+So precisa mostrar o algoritmo skippando um bloco que cabe?
\ No newline at end of file
diff --git a/app/test/notes_mmu.txt b/app/test/notes_mmu.txt
new file mode 100644
index 0000000..1239a86
--- /dev/null
+++ b/app/test/notes_mmu.txt
@@ -0,0 +1,3 @@
+Desafios:
+Em que momento liga paginacao na intel?
+Como que liga paginacao no rv32?
diff --git a/app/test/test.cc b/app/test/test.cc
new file mode 100644
index 0000000..4a473a9
--- /dev/null
+++ b/app/test/test.cc
@@ -0,0 +1,34 @@
+// Description:
+// The Heap reaches main() containing two elements: E1 and E2.
+//    E1 begun from &_end to BOOT_STACK, but now has 32904 less bytes due to the allocations
+//  of System::init().
+//    E2 is still untouched and ranges from MEM_TOP to MEM_TOP-STACK_SIZE.
+// E1 is way larger than E2.
+//    In this test program, we allocate almost all of E1 so that Worst-Fit has to reach for E2
+//  in its second allocation (line 30).
+// For comparision purposes, we print how First Fit would have handled each allocation.
+
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+static const int SIZE_OF_E1 = 134201064 - 32904 - 16*1024;
+
+char * alloc(int bytes) {
+    return new char[bytes];
+}
+
+int main()
+{
+    // terminal output is important after the following line
+    cout << "Testing Worst-Fit..." << endl;
+
+    // leave less than a stack worth of memory on E1
+    alloc(SIZE_OF_E1 - 8*1024);
+    // this should go to E2
+    alloc(16); // will alloc 16+4 due to size
+
+    return 0;
+}
diff --git a/app/test/test_traits.h b/app/test/test_traits.h
new file mode 100644
index 0000000..008c06f
--- /dev/null
+++ b/app/test/test_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    static const bool preemptive = true;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+
+__END_SYS
+
+#endif
diff --git a/img/makefile b/img/makefile
index f048773..0799121 100644
--- a/img/makefile
+++ b/img/makefile
@@ -83,7 +83,7 @@ endif
 
 debug:		$(IMAGE)
 ifeq ($(NODES),1)
-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
+		$(EMULATOR)$(IMAGE) &
 		$(DEBUGGER)
 else
 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
 		@echo "Running $(APPLICATION) ..."
 posrun_$(APPLICATION):
 		@echo "done!"
-		
+
 FORCE:
diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
index 1c809b2..59fe619 100644
--- a/include/architecture/rv32/rv32_mmu.h
+++ b/include/architecture/rv32/rv32_mmu.h
@@ -105,6 +105,7 @@ public:
                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
         }
         db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+        kout << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
 
         return phy;
     };
@@ -117,7 +118,7 @@ public:
 
     static void free(Phy_Addr addr, unsigned int n = 1) {
         db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
-
+        kout << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
         // No unaligned addresses if the CPU doesn't support it
         assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
 
diff --git a/include/utility/heap.h b/include/utility/heap.h
index f377454..0235644 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -18,6 +18,9 @@ protected:
 public:
     using Grouping_List<char>::empty;
     using Grouping_List<char>::size;
+    using Grouping_List<char>::search_decrementing;
+    using Grouping_List<char>::find_first;
+    using Grouping_List<char>::find_worst;
 
     Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
@@ -30,8 +33,8 @@ public:
     }
 
     void * alloc(unsigned int bytes) {
-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
+        kout << "Heap::alloc(this=" << this << ",bytes=" << bytes  << ")" << endl;
         if(!bytes)
             return 0;
 
@@ -45,6 +48,8 @@ public:
         if(bytes < sizeof(Element))
             bytes = sizeof(Element);
 
+        kout << "First Fit: " << find_first(bytes) << endl;
+        kout << "Worst Fit: " << find_worst(bytes) << endl;
         Element * e = search_decrementing(bytes);
         if(!e) {
             out_of_memory();
@@ -65,11 +70,12 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
-        if(ptr && (bytes >= sizeof(Element))) {
+        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
         }
+        kout << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
     }
 
     static void typed_free(void * ptr) {
diff --git a/include/utility/list.h b/include/utility/list.h
index ccc8954..eca1174 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -1348,7 +1348,7 @@ public:
 
     Element * search_size(unsigned int s) {
         Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
+        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
         else
             for(; e && (e->size() < s); e = e->next());
@@ -1381,7 +1381,7 @@ public:
         print_head();
         print_tail();
 
-        Element * e = search_size(s);
+        Element * e = find_worst(s);
         if(e) {
             e->shrink(s);
             _grouped_size -= s;
@@ -1392,6 +1392,33 @@ public:
         return e;
     }
 
+    // Used by Heap/Worst-Fit
+    // for empty lists, return 0
+    // for nonempty lists,
+    //      return 0 if there is no element big enough to fit s
+    //      return the element with biggest size otherwise
+    // precons:
+    //  1. s >= sizeof(Element) [s >= 16]
+    Element * find_worst(unsigned int s) {
+        Element * max = 0;
+        unsigned max_size = 0;
+        for(Element * e = head(); e; e = e->next()) {
+            if (e->size() > max_size) {
+                max_size = e->size();
+                max = e;
+            }
+        }
+
+        if (max_size < s)
+            return 0;
+
+        return max;
+    }
+
+    Element * find_first(unsigned int s) {
+        return search_size(s);
+    }
+
 private:
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
diff --git a/makedefs b/makedefs
index 21674d9..9275107 100644
--- a/makedefs
+++ b/makedefs
@@ -103,7 +103,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
 pc_AS_FLAGS		:= --32
 pc_LD_FLAGS		:= -m elf_i386
 pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
-pc_DEBUGGER		:= gdb
+pc_DEBUGGER		:= gdb -tui
 pc_FLASHER		:=
 pc_MAGIC		:= --nmagic
 pc_CODE_NAME		:= .init
@@ -254,7 +254,7 @@ TLDFLAGS	:= -m32
 ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
@@ -315,7 +315,7 @@ TEE		:= tee
 ifndef DISPLAY
 TERM        := sh -c
 else
-TERM        := xterm -e
+TERM        := konsole -e
 endif
 
 TOUCH		:= touch
diff --git a/src/api/thread.cc b/src/api/thread.cc
index fdd0583..12cb8e7 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -295,7 +295,6 @@ void Thread::reschedule()
     yield();
 }
 
-
 void Thread::time_slicer(IC::Interrupt_Id i)
 {
     reschedule();
diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
index c54f943..fb06a1b 100755
--- a/tools/eposctors/eposctors
+++ b/tools/eposctors/eposctors
@@ -13,11 +13,13 @@ FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '
 
 echo "CTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    LIST=`hexdump -s $INIT_ARRAY_OFFSET -n $INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+
     for item in $LIST; do
+        # echo $item
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
         echo 0x$item $sym
-    done   
+    done
 else
     hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "break *0x%08x\n"' $ELF
 fi
