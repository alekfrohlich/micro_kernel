diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 567f515..b275f8d 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -5,17 +5,17 @@ using namespace EPOS;
 
 OStream cout;
 
-int __attribute__((optimize("O0"))) dummy(int n) {
-    long long int a = 0;
-    for (int i = 0; i < n; i++) {
-        for (int j = 0; j < n; j++) {
-            a += i*j;
-        }
-    }
-    return a;
-}
+// int __attribute__((optimize("O0"))) dummy(int n) {
+//     long long int a = 0;
+//     for (int i = 0; i < n; i++) {
+//         for (int j = 0; j < n; j++) {
+//             a += i*j;
+//         }
+//     }
+//     return a;
+// }
 
-static unsigned ITERATIONS = 1000;
+// static unsigned ITERATIONS = 1000;
 int main()
 {
     // Chronometer chron;
@@ -31,7 +31,7 @@ int main()
     // }
     // chron.stop();
     // unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
-    // cout << "T=" << avg << endl; 
+    // cout << "T=" << avg << endl;
     cout << "Hello world!" << endl;
     return 0;
 }
diff --git a/img/makefile b/img/makefile
index 9b1b14f..d47e93b 100644
--- a/img/makefile
+++ b/img/makefile
@@ -31,7 +31,7 @@ ifeq ($(DEBUG),1)
 # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
 # endif
 # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000000"
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000080"
 PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
 endif
 
@@ -85,6 +85,7 @@ endif
 
 debug:		$(IMAGE)
 ifeq ($(NODES),1)
+		echo "HELLO!!!!!!!!!!!!!!!!!"
 		$(EMULATOR)$(IMAGE) &
 		$(DEBUGGER)
 else
diff --git a/include/machine/display.h b/include/machine/display.h
index 03a873c..f3599c7 100644
--- a/include/machine/display.h
+++ b/include/machine/display.h
@@ -34,6 +34,7 @@ public:
 class Serial_Display: public Display_Common
 {
     friend class PC_Setup;
+    friend class Setup_SifiveE;
     friend class Serial_Keyboard;
     friend class Machine;
 
diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
index 865e083..aefc3ef 100644
--- a/include/machine/riscv/sifive_e/sifive_e_info.h
+++ b/include/machine/riscv/sifive_e/sifive_e_info.h
@@ -37,10 +37,50 @@ public:
         Size extras_offset;
     };
 
+    // !P2:
     // Load Map (not used in this machine, but kept for architectural transparency)
+    // struct Load_Map
+    // {
+    //     bool  has_ext;
+    //     LAddr app_entry;
+    //     Size  app_segments;
+    //     LAddr app_code;
+    //     Size  app_code_size;
+    //     LAddr app_data;
+    //     LAddr app_stack;
+    //     LAddr app_heap;
+    //     Size  app_data_size;
+    //     LAddr app_extra;
+    //     Size  app_extra_size;
+    // };
+
     struct Load_Map
     {
+        bool  has_stp;
+        bool  has_ini;
+        bool  has_sys;
+        bool  has_app;
         bool  has_ext;
+        LAddr stp_entry;
+        Size  stp_segments;
+        LAddr stp_code;
+        Size  stp_code_size;
+        LAddr stp_data;
+        Size  stp_data_size;
+        LAddr ini_entry;
+        Size  ini_segments;
+        LAddr ini_code;
+        Size  ini_code_size;
+        LAddr ini_data;
+        Size  ini_data_size;
+        LAddr sys_entry;
+        Size  sys_segments;
+        LAddr sys_code;
+        Size  sys_code_size;
+        LAddr sys_data;
+        Size  sys_data_size;
+        LAddr sys_stack;
+        Size  sys_stack_size;
         LAddr app_entry;
         Size  app_segments;
         LAddr app_code;
@@ -49,7 +89,7 @@ public:
         LAddr app_stack;
         LAddr app_heap;
         Size  app_data_size;
-        LAddr app_extra;
+        PAddr app_extra;
         Size  app_extra_size;
     };
 
diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
index 2acbf80..0fa18a3 100644
--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
+++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
@@ -34,7 +34,7 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
     // Logical Memory Map
     static const unsigned int BOOT              = NOT_USED;
     static const unsigned int IMAGE             = NOT_USED;
-    static const unsigned int SETUP             = 0x80000000; // This controls whether an ELF file is generated for setup
+    static const unsigned int SETUP             = 0x80000000 + 0x78; // This controls whether an ELF file is generated for setup; boot + elf header
     // static const unsigned int SETUP             = NOT_USED;
     static const unsigned int INIT              = 0x80010000; // 16 pages for setup
 
diff --git a/include/system/config.h b/include/system/config.h
index d2d607d..4b24ad1 100644
--- a/include/system/config.h
+++ b/include/system/config.h
@@ -7,15 +7,15 @@
 // ARCHITECTURE, MACHINE, AND APPLICATION SELECTION
 // This section is generated automatically from makedefs by $EPOS/etc/makefile
 //============================================================================
-#define SMOD xxx
-#define ARCH xxx
-#define MACH xxx
-#define MMOD xxx
-#define APPL xxx
-#define __mode_xxx__
-#define __arch_xxx__
-#define __mach_xxx__
-#define __mmod_xxx__
+#define SMOD builtin
+#define ARCH rv32
+#define MACH riscv
+#define MMOD sifive_e
+#define APPL hello_usr
+#define __mode_builtin__
+#define __arch_rv32__
+#define __mach_riscv__
+#define __mmod_sifive_e__
 
 //============================================================================
 // NAMESPACES AND DEFINITIONS
diff --git a/include/utility/elf.h b/include/utility/elf.h
index 0ef4158..0c47657 100644
--- a/include/utility/elf.h
+++ b/include/utility/elf.h
@@ -31,7 +31,8 @@ public:
         : seg(i)->p_align ? seg(i)->p_vaddr
         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
     }
-
+    
+    // !P2: is this correct?
     int segment_size(int i) {
         return (i > segments()) ? -1 : (int)(
             ((seg(i)->p_offset % seg(i)->p_align)
diff --git a/makedefs b/makedefs
index 5e654fb..e0f4ef7 100644
--- a/makedefs
+++ b/makedefs
@@ -114,7 +114,7 @@ ifeq ($(MMOD),realview_pbx)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -126,7 +126,7 @@ endif
 ifeq ($(MMOD),zynq)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -139,7 +139,7 @@ ifeq ($(MMOD),raspberry_pi3)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -149,7 +149,7 @@ cortex_IMG_SUFFIX	:= .bin
 endif
 
 ifeq ($(MMOD),lm3s811)
-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -162,7 +162,7 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),emote3)
-cortex_EMULATOR		= 
+cortex_EMULATOR		=
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -176,11 +176,12 @@ endif
 
 ifeq ($(MMOD),sifive_e)
 riscv_CC_FLAGS          := -Wl, -mno-relax
-riscv_AS_FLAGS          := 
+riscv_AS_FLAGS          :=
 riscv_LD_FLAGS          := --no-relax
-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --nmagic
 riscv_CODE_NAME 		:= .init
 riscv_DATA_NAME 		:= .sdata
@@ -189,11 +190,11 @@ endif
 
 ifeq ($(MMOD),sifive_u)
 riscv_CC_FLAGS          := -mcmodel=medany
-riscv_AS_FLAGS          := 
-riscv_LD_FLAGS          := 
-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_AS_FLAGS          :=
+riscv_LD_FLAGS          :=
+riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --omagic
 riscv_CODE_NAME := .init
 riscv_DATA_NAME :=
@@ -254,7 +255,7 @@ TLDFLAGS	:= -m32
 ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index 194e2e5..806249d 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -2,6 +2,8 @@
 
 #include <utility/ostream.h>
 
+#include <utility/elf.h>
+#include <utility/debug.h>
 #include <system/info.h>
 #include <architecture.h>
 #include <machine.h>
@@ -24,11 +26,13 @@ extern "C"
         // _start();
     }
     void _print(const char * s) { Display::puts(s); }
+    void _panic() { Machine::panic(); }
+
 }
 
-char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________";
+// char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________________________________________________________________________________________________________________________________________";
 System_Info * si;
-EPOS::S::U::OStream kout, kerr;
 
 extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
     Reg id = CPU::mcause();
@@ -42,6 +46,7 @@ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
 }
 
 __BEGIN_SYS
+EPOS::S::U::OStream kout, kerr;
 
 class Setup_SifiveE {
 private:
@@ -57,8 +62,176 @@ public:
     static void setup_supervisor_environment();
     static void build_page_tables();
     static void clean_bss();
+    static void build_lm();
 };
 
+// !P2:
+void Setup_SifiveE::build_lm()
+{
+    // Get boot image structure
+    si->lm.has_stp = (si->bm.setup_offset != -1u);
+    si->lm.has_ini = (si->bm.init_offset != -1u);
+    si->lm.has_sys = (si->bm.system_offset != -1u);
+    si->lm.has_app = (si->bm.application_offset != -1u);
+    si->lm.has_ext = (si->bm.extras_offset != -1u);
+
+    // Check SETUP integrity and get the size of its segments
+    si->lm.stp_entry = 0;
+    si->lm.stp_segments = 0;
+    si->lm.stp_code = ~0U;
+    si->lm.stp_code_size = 0;
+    si->lm.stp_data = ~0U;
+    si->lm.stp_data_size = 0;
+
+    db<Spin>(ERR) << "SETUP ELF image is corrupted!" << endl;
+    EPOS::S::kout << "oioioioioio" << endl;
+    char * bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE);
+    if(si->lm.has_stp) {
+        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
+        if(!stp_elf->valid()) {
+            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.stp_entry = stp_elf->entry();
+        si->lm.stp_segments = stp_elf->segments();
+        si->lm.stp_code = stp_elf->segment_address(0);
+        si->lm.stp_code_size = stp_elf->segment_size(0);
+        if(stp_elf->segments() > 1) {
+            for(int i = 1; i < stp_elf->segments(); i++) {
+                if(stp_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(stp_elf->segment_address(i) < si->lm.stp_data)
+                    si->lm.stp_data = stp_elf->segment_address(i);
+                si->lm.stp_data_size += stp_elf->segment_size(i);
+            }
+        }
+    }
+
+
+    // // Check INIT integrity and get the size of its segments
+    // si->lm.ini_entry = 0;
+    // si->lm.ini_segments = 0;
+    // si->lm.ini_code = ~0U;
+    // si->lm.ini_code_size = 0;
+    // si->lm.ini_data = ~0U;
+    // si->lm.ini_data_size = 0;
+    // if(si->lm.has_ini) {
+    //     ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+    //     if(!ini_elf->valid()) {
+    //         db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
+    //         panic();
+    //     }
+
+    //     si->lm.ini_entry = ini_elf->entry();
+    //     si->lm.ini_segments = ini_elf->segments();
+    //     si->lm.ini_code = ini_elf->segment_address(0);
+    //     si->lm.ini_code_size = ini_elf->segment_size(0);
+    //     if(ini_elf->segments() > 1) {
+    //         for(int i = 1; i < ini_elf->segments(); i++) {
+    //             if(ini_elf->segment_type(i) != PT_LOAD)
+    //                 continue;
+    //             if(ini_elf->segment_address(i) < si->lm.ini_data)
+    //                 si->lm.ini_data = ini_elf->segment_address(i);
+    //             si->lm.ini_data_size += ini_elf->segment_size(i);
+    //         }
+    //     }
+    // }
+
+    // // Check SYSTEM integrity and get the size of its segments
+    // si->lm.sys_entry = 0;
+    // si->lm.sys_segments = 0;
+    // si->lm.sys_code = ~0U;
+    // si->lm.sys_code_size = 0;
+    // si->lm.sys_data = ~0U;
+    // si->lm.sys_data_size = 0;
+    // si->lm.sys_stack = SYS_STACK;
+    // si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
+    // if(si->lm.has_sys) {
+    //     ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+    //     if(!sys_elf->valid()) {
+    //         db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
+    //         panic();
+    //     }
+
+    //     si->lm.sys_entry = sys_elf->entry();
+    //     si->lm.sys_segments = sys_elf->segments();
+    //     si->lm.sys_code = sys_elf->segment_address(0);
+    //     si->lm.sys_code_size = sys_elf->segment_size(0);
+    //     if(sys_elf->segments() > 1) {
+    //         for(int i = 1; i < sys_elf->segments(); i++) {
+    //             if(sys_elf->segment_type(i) != PT_LOAD)
+    //                 continue;
+    //             if(sys_elf->segment_address(i) < si->lm.sys_data)
+    //                 si->lm.sys_data = sys_elf->segment_address(i);
+    //             si->lm.sys_data_size += sys_elf->segment_size(i);
+    //         }
+    //     }
+
+    //     if(si->lm.sys_code != SYS_CODE) {
+    //         db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
+    //         panic();
+    //     }
+    //     if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
+    //         db<Setup>(ERR) << "OS code segment is too large!" << endl;
+    //         panic();
+    //     }
+    //     if(si->lm.sys_data != SYS_DATA) {
+    //         db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
+    //         panic();
+    //     }
+    //     if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack) {
+    //         db<Setup>(ERR) << "OS data segment is too large!" << endl;
+    //         panic();
+    //     }
+    //     if(MMU::page_tables(MMU::pages(si->lm.sys_stack - SYS + si->lm.sys_stack_size)) > 1) {
+    //         db<Setup>(ERR) << "OS stack segment is too large!" << endl;
+    //         panic();
+    //     }
+    // }
+
+    // // Check APPLICATION integrity and get the size of its segments
+    // si->lm.app_entry = 0;
+    // si->lm.app_segments = 0;
+    // si->lm.app_code = ~0U;
+    // si->lm.app_code_size = 0;
+    // si->lm.app_data = ~0U;
+    // si->lm.app_data_size = 0;
+    // if(si->lm.has_app) {
+    //     ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+    //     if(!app_elf->valid()) {
+    //         db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
+    //         panic();
+    //     }
+    //     si->lm.app_entry = app_elf->entry();
+    //     si->lm.app_code = app_elf->segment_address(0);
+    //     si->lm.app_code_size = app_elf->segment_size(0);
+    //     if(app_elf->segments() > 1) {
+    //         for(int i = 1; i < app_elf->segments(); i++) {
+    //             if(app_elf->segment_type(i) != PT_LOAD)
+    //                 continue;
+    //             if(app_elf->segment_address(i) < si->lm.app_data)
+    //                 si->lm.app_data = app_elf->segment_address(i);
+    //             si->lm.app_data_size += app_elf->segment_size(i);
+    //         }
+    //     }
+    //     if(Traits<System>::multiheap) { // Application heap in data segment
+    //         si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
+    //         si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
+    //         si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
+    //         si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
+    //         si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
+    //     }
+    //     if(si->lm.has_ext) { // Check for EXTRA data in the boot image
+    //         si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
+    //         si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
+    //         if(Traits<System>::multiheap)
+    //             si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
+    //         si->lm.app_data_size += si->lm.app_extra_size;
+    //     }
+    // }
+}
+
 void Setup_SifiveE::build_page_tables()
 {
     // Address of the Directory
@@ -103,8 +276,11 @@ void Setup_SifiveE::setup_supervisor_environment()
     build_page_tables();
 
     //!P2: How could machine pre_init run before Init_System if it was linked w/ SYS?
-    // if(CPU::id() == 0)
-    //     Display::init();
+    if(CPU::id() == 0)
+        Display::init();
+
+    si = reinterpret_cast<System_Info*>(placeholder);
+    build_lm();
 
     // db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
 
@@ -128,7 +304,6 @@ void Setup_SifiveE::setup_supervisor_environment()
 
 void Setup_SifiveE::setup_machine_environment()
 {
-    si = reinterpret_cast<System_Info*>(placeholder);
     // We first configure the M-mode CSRs and then switch to S-mode
     // configure paging. After that, we won't return to M-mode; an exception
     // is the forwarding of ints and excps to S-mode.
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
deleted file mode 120000
index fa235ad..0000000
--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
+++ /dev/null
@@ -1 +0,0 @@
-../scheduler_rm_test/scheduler_rm_test.cc
\ No newline at end of file
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
deleted file mode 120000
index fa235ad..0000000
--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
+++ /dev/null
@@ -1 +0,0 @@
-../scheduler_rm_test/scheduler_rm_test.cc
\ No newline at end of file
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
index 75a2801..bcb452f 100644
--- a/tools/eposmkbi/eposmkbi.cc
+++ b/tools/eposmkbi/eposmkbi.cc
@@ -166,6 +166,11 @@ int main(int argc, char **argv)
     unsigned int image_size = 0;
     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
 
+    // !P2:
+    // riscv boot jump: jal 0x74
+    unsigned int boot_jump = 0b111100000000000000001101111; 
+    image_size += put_number(fd_img, boot_jump);
+    
     // Add BOOT
     if(CONFIG.boot_length_max > 0) {
         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
@@ -181,6 +186,8 @@ int main(int argc, char **argv)
         }
     }
     unsigned int boot_size = image_size;
+    // !P2:
+    // boot_size = 0;
 
     // Determine if System_Info is needed and how it must be handled
     bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
@@ -210,10 +217,10 @@ int main(int argc, char **argv)
     si.bm.space_z  = CONFIG.space_z;
 
     fprintf(out, "\nsi.bm.n_cpus %u", si.bm.n_cpus);
-    fprintf(out, "\nsi.bm.mem_base %u", si.bm.mem_base);
-    fprintf(out, "\nsi.bm.mem_top %u", si.bm.mem_top);
-    fprintf(out, "\nsi.bm.mio_base %u", si.bm.mio_base);
-    fprintf(out, "\nsi.bm.mio_top %u", si.bm.mio_top);
+    fprintf(out, "\nsi.bm.mem_base %08x", si.bm.mem_base);
+    fprintf(out, "\nsi.bm.mem_top %08x", si.bm.mem_top);
+    fprintf(out, "\nsi.bm.mio_base %08x", si.bm.mio_base);
+    fprintf(out, "\nsi.bm.mio_top %08x", si.bm.mio_top);
     fprintf(out, "\nsi.bm.node_id %u", si.bm.node_id);
     fprintf(out, "\nsi.bm.space_x %u", si.bm.space_x);
     fprintf(out, "\nsi.bm.space_y %u", si.bm.space_y);
