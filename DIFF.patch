diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 567f515..b275f8d 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -5,17 +5,17 @@ using namespace EPOS;
 
 OStream cout;
 
-int __attribute__((optimize("O0"))) dummy(int n) {
-    long long int a = 0;
-    for (int i = 0; i < n; i++) {
-        for (int j = 0; j < n; j++) {
-            a += i*j;
-        }
-    }
-    return a;
-}
+// int __attribute__((optimize("O0"))) dummy(int n) {
+//     long long int a = 0;
+//     for (int i = 0; i < n; i++) {
+//         for (int j = 0; j < n; j++) {
+//             a += i*j;
+//         }
+//     }
+//     return a;
+// }
 
-static unsigned ITERATIONS = 1000;
+// static unsigned ITERATIONS = 1000;
 int main()
 {
     // Chronometer chron;
@@ -31,7 +31,7 @@ int main()
     // }
     // chron.stop();
     // unsigned avg = (chron.ticks()/ITERATIONS)/RESCALE;
-    // cout << "T=" << avg << endl; 
+    // cout << "T=" << avg << endl;
     cout << "Hello world!" << endl;
     return 0;
 }
diff --git a/img/makefile b/img/makefile
index 9b1b14f..b25502a 100644
--- a/img/makefile
+++ b/img/makefile
@@ -31,7 +31,7 @@ ifeq ($(DEBUG),1)
 # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
 # endif
 # DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000000"
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(IMG)/setup_sifive_e 0x80000080"
 PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
 endif
 
diff --git a/include/machine/display.h b/include/machine/display.h
index 03a873c..f3599c7 100644
--- a/include/machine/display.h
+++ b/include/machine/display.h
@@ -34,6 +34,7 @@ public:
 class Serial_Display: public Display_Common
 {
     friend class PC_Setup;
+    friend class Setup_SifiveE;
     friend class Serial_Keyboard;
     friend class Machine;
 
diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
index 865e083..aefc3ef 100644
--- a/include/machine/riscv/sifive_e/sifive_e_info.h
+++ b/include/machine/riscv/sifive_e/sifive_e_info.h
@@ -37,10 +37,50 @@ public:
         Size extras_offset;
     };
 
+    // !P2:
     // Load Map (not used in this machine, but kept for architectural transparency)
+    // struct Load_Map
+    // {
+    //     bool  has_ext;
+    //     LAddr app_entry;
+    //     Size  app_segments;
+    //     LAddr app_code;
+    //     Size  app_code_size;
+    //     LAddr app_data;
+    //     LAddr app_stack;
+    //     LAddr app_heap;
+    //     Size  app_data_size;
+    //     LAddr app_extra;
+    //     Size  app_extra_size;
+    // };
+
     struct Load_Map
     {
+        bool  has_stp;
+        bool  has_ini;
+        bool  has_sys;
+        bool  has_app;
         bool  has_ext;
+        LAddr stp_entry;
+        Size  stp_segments;
+        LAddr stp_code;
+        Size  stp_code_size;
+        LAddr stp_data;
+        Size  stp_data_size;
+        LAddr ini_entry;
+        Size  ini_segments;
+        LAddr ini_code;
+        Size  ini_code_size;
+        LAddr ini_data;
+        Size  ini_data_size;
+        LAddr sys_entry;
+        Size  sys_segments;
+        LAddr sys_code;
+        Size  sys_code_size;
+        LAddr sys_data;
+        Size  sys_data_size;
+        LAddr sys_stack;
+        Size  sys_stack_size;
         LAddr app_entry;
         Size  app_segments;
         LAddr app_code;
@@ -49,7 +89,7 @@ public:
         LAddr app_stack;
         LAddr app_heap;
         Size  app_data_size;
-        LAddr app_extra;
+        PAddr app_extra;
         Size  app_extra_size;
     };
 
diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
index cb8beac..28e9ce5 100644
--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
@@ -49,7 +49,7 @@ struct Memory_Map
         IO              = Traits<Machine>::IO_BASE,
 
         SYS             = Traits<Machine>::SYS,
-        SYS_INFO        = unsigned(-1),                 // Dynamically built during initialization.
+        SYS_INFO        = Traits<Machine>::SYS_INFO,
         SYS_CODE        = Traits<Machine>::SYS_CODE,
         SYS_DATA        = Traits<Machine>::SYS_DATA,
         SYS_HEAP        = Traits<Machine>::NOT_USED,
diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
index 2acbf80..25cb11a 100644
--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
+++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
@@ -30,13 +30,14 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
 
     static const unsigned int VECTOR_TABLE      = NOT_USED;
     static const unsigned int PAGE_TABLES       = 0x87ffffff + 1 - 16*1024 - ((1024+1)*4*1024); // 0x87BFB000
+    static const unsigned int SYS_INFO          = PAGE_TABLES - 4096; 
 
     // Logical Memory Map
     static const unsigned int BOOT              = NOT_USED;
     static const unsigned int IMAGE             = NOT_USED;
-    static const unsigned int SETUP             = 0x80000000; // This controls whether an ELF file is generated for setup
+    static const unsigned int SETUP             = 0x80000000 + 0x78; // This controls whether an ELF file is generated for setup; boot + elf header
     // static const unsigned int SETUP             = NOT_USED;
-    static const unsigned int INIT              = 0x80010000; // 16 pages for setup
+    static const unsigned int INIT              = 0x80200000;
 
     static const unsigned int APP_LOW           = 0x88000000;
     static const unsigned int APP_CODE          = 0x88000000;
@@ -51,8 +52,8 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
     //!P2: Is SYS_HEAP necessary?
     //!P2: we can let the BOOT_STACK be the kernel stack
     static const unsigned int SYS               = NOT_USED;
-    static const unsigned int SYS_CODE          = 0x80020000;
-    static const unsigned int SYS_DATA          = 0x80040000;
+    static const unsigned int SYS_CODE          = 0x80300000;
+    static const unsigned int SYS_DATA          = 0x80400000;
     static const unsigned int SYS_HEAP          = NOT_USED;
     static const unsigned int SYS_STACK         = NOT_USED;
 
diff --git a/include/utility/elf.h b/include/utility/elf.h
index 0ef4158..0c47657 100644
--- a/include/utility/elf.h
+++ b/include/utility/elf.h
@@ -31,7 +31,8 @@ public:
         : seg(i)->p_align ? seg(i)->p_vaddr
         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
     }
-
+    
+    // !P2: is this correct?
     int segment_size(int i) {
         return (i > segments()) ? -1 : (int)(
             ((seg(i)->p_offset % seg(i)->p_align)
diff --git a/makedefs b/makedefs
index 5e654fb..fd2fd15 100644
--- a/makedefs
+++ b/makedefs
@@ -114,7 +114,7 @@ ifeq ($(MMOD),realview_pbx)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -126,7 +126,7 @@ endif
 ifeq ($(MMOD),zynq)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -139,7 +139,7 @@ ifeq ($(MMOD),raspberry_pi3)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -149,7 +149,7 @@ cortex_IMG_SUFFIX	:= .bin
 endif
 
 ifeq ($(MMOD),lm3s811)
-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -162,7 +162,7 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),emote3)
-cortex_EMULATOR		= 
+cortex_EMULATOR		=
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -175,12 +175,13 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),sifive_e)
-riscv_CC_FLAGS          := -Wl, -mno-relax
-riscv_AS_FLAGS          := 
+riscv_CC_FLAGS          := -Wl, -mno-relax -march='rv32g'
+riscv_AS_FLAGS          :=
 riscv_LD_FLAGS          := --no-relax
-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --nmagic
 riscv_CODE_NAME 		:= .init
 riscv_DATA_NAME 		:= .sdata
@@ -189,11 +190,11 @@ endif
 
 ifeq ($(MMOD),sifive_u)
 riscv_CC_FLAGS          := -mcmodel=medany
-riscv_AS_FLAGS          := 
-riscv_LD_FLAGS          := 
-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_AS_FLAGS          :=
+riscv_LD_FLAGS          :=
+riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --omagic
 riscv_CODE_NAME := .init
 riscv_DATA_NAME :=
@@ -254,7 +255,7 @@ TLDFLAGS	:= -m32
 ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
diff --git a/notes/build.txt b/notes/build.txt
index 25a091f..83bbce6 100644
--- a/notes/build.txt
+++ b/notes/build.txt
@@ -132,4 +132,30 @@ usr/local/rv32/bin/riscv32-unknown-linux-gnu-ld --no-relax -nostdlib -L/home/ale
         --whole-archive \
         -lsys_sifive_e -lmach_sifive_e -larch_sifive_e \
         --no-whole-archive \
-        -lutil_sifive_e -linit_sifive_e -lgcc
\ No newline at end of file
+        -lutil_sifive_e -linit_sifive_e -lgcc
+
+
+GDB
+=======
+0x81000000 -> 16MB
+0x80100000 -> 1MB
+
+INIT:     0x80200000; 
+SYS_CODE: 0x80300000;
+SYS_DATA: 0x80400000;
+
+find 0x80000000, 0x8fffffff, (char) 0x7F , 'E', 'L', 'F'       
+0x80000004
+0x80019b6c
+0x8006ec00
+0x8013a538
+
+entry_point     setup 0x80000080
+
+init global constructors
+
+app entry 
+
+
+=======
+        
\ No newline at end of file
diff --git a/qemu_help b/qemu_help
new file mode 100644
index 0000000..5af1707
--- /dev/null
+++ b/qemu_help
@@ -0,0 +1,451 @@
+QEMU emulator version 5.0.0 (v5.0.0-dirty)
+Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers
+usage: qemu-system-riscv32 [options] [disk_image]
+
+'disk_image' is a raw hard disk image for IDE hard disk 0
+
+Standard options:
+-h or -help     display this help and exit
+-version        display version information and exit
+-machine [type=]name[,prop[=value][,...]]
+                selects emulated machine ('-machine help' for list)
+                property accel=accel1[:accel2[:...]] selects accelerator
+                supported accelerators are kvm, xen, hax, hvf, whpx or tcg (default: tcg)
+                vmport=on|off|auto controls emulation of vmport (default: auto)
+                dump-guest-core=on|off include guest memory in a core dump (default=on)
+                mem-merge=on|off controls memory merge support (default: on)
+                aes-key-wrap=on|off controls support for AES key wrapping (default=on)
+                dea-key-wrap=on|off controls support for DEA key wrapping (default=on)
+                suppress-vmdesc=on|off disables self-describing migration (default=off)
+                nvdimm=on|off controls NVDIMM support (default=off)
+                enforce-config-section=on|off enforce configuration section migration (default=off)
+                memory-encryption=@var{} memory encryption object to use (default=none)
+                hmat=on|off controls ACPI HMAT support (default=off)
+-cpu cpu        select CPU ('-cpu help' for list)
+-accel [accel=]accelerator[,prop[=value][,...]]
+                select accelerator (kvm, xen, hax, hvf, whpx or tcg; use 'help' for a list)
+                igd-passthru=on|off (enable Xen integrated Intel graphics passthrough, default=off)
+                kernel-irqchip=on|off|split controls accelerated irqchip support (default=on)
+                kvm-shadow-mem=size of KVM shadow MMU in bytes
+                tb-size=n (TCG translation block cache size)
+                thread=single|multi (enable multi-threaded TCG)
+-smp [cpus=]n[,maxcpus=cpus][,cores=cores][,threads=threads][,dies=dies][,sockets=sockets]
+                set the number of CPUs to 'n' [default=1]
+                maxcpus= maximum number of total cpus, including
+                offline CPUs for hotplug, etc
+                cores= number of CPU cores on one socket (for PC, it's on one die)
+                threads= number of threads on one CPU core
+                dies= number of CPU dies on one socket (for PC only)
+                sockets= number of discrete sockets in the system
+-numa node[,mem=size][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]
+-numa node[,memdev=id][,cpus=firstcpu[-lastcpu]][,nodeid=node][,initiator=node]
+-numa dist,src=source,dst=destination,val=distance
+-numa cpu,node-id=node[,socket-id=x][,core-id=y][,thread-id=z]
+-numa hmat-lb,initiator=node,target=node,hierarchy=memory|first-level|second-level|third-level,data-type=access-latency|read-latency|write-latency[,latency=lat][,bandwidth=bw]
+-numa hmat-cache,node-id=node,size=size,level=level[,associativity=none|direct|complex][,policy=none|write-back|write-through][,line=size]
+-add-fd fd=fd,set=set[,opaque=opaque]
+                Add 'fd' to fd 'set'
+-set group.id.arg=value
+                set <arg> parameter for item <id> of type <group>
+                i.e. -set drive.$id.file=/path/to/image
+-global driver.property=value
+-global driver=driver,property=property,value=value
+                set a global default for a driver property
+-boot [order=drives][,once=drives][,menu=on|off]
+      [,splash=sp_name][,splash-time=sp_time][,reboot-timeout=rb_time][,strict=on|off]
+                'drives': floppy (a), hard disk (c), CD-ROM (d), network (n)
+                'sp_name': the file's name that would be passed to bios as logo picture, if menu=on
+                'sp_time': the period that splash picture last if menu=on, unit is ms
+                'rb_timeout': the timeout before guest reboot when boot failed, unit is ms
+-m [size=]megs[,slots=n,maxmem=size]
+                configure guest RAM
+                size: initial amount of guest memory
+                slots: number of hotplug slots (default: none)
+                maxmem: maximum amount of guest memory (default: none)
+NOTE: Some architectures might enforce a specific granularity
+-mem-path FILE  provide backing storage for guest RAM
+-mem-prealloc   preallocate guest memory (use with -mem-path)
+-k language     use keyboard layout (for example 'fr' for French)
+-audio-help     show -audiodev equivalent of the currently specified audio settings
+-audiodev [driver=]driver,id=id[,prop[=value][,...]]
+                specifies the audio backend to use
+                id= identifier of the backend
+                timer-period= timer period in microseconds
+                in|out.mixing-engine= use mixing engine to mix streams inside QEMU
+                in|out.fixed-settings= use fixed settings for host audio
+                in|out.frequency= frequency to use with fixed settings
+                in|out.channels= number of channels to use with fixed settings
+                in|out.format= sample format to use with fixed settings
+                valid values: s8, s16, s32, u8, u16, u32, f32
+                in|out.voices= number of voices to use
+                in|out.buffer-length= length of buffer in microseconds
+-audiodev none,id=id,[,prop[=value][,...]]
+                dummy driver that discards all output
+-audiodev oss,id=id[,prop[=value][,...]]
+                in|out.dev= path of the audio device to use
+                in|out.buffer-count= number of buffers
+                in|out.try-poll= attempt to use poll mode
+                try-mmap= try using memory mapped access
+                exclusive= open device in exclusive mode
+                dsp-policy= set timing policy (0..10), -1 to use fragment mode
+-audiodev wav,id=id[,prop[=value][,...]]
+                path= path of wav file to record
+-soundhw c1,... enable audio support
+                and only specified sound cards (comma separated list)
+                use '-soundhw help' to get the list of supported cards
+                use '-soundhw all' to enable all of them
+-device driver[,prop[=value][,...]]
+                add device (based on driver)
+                prop=value,... sets driver properties
+                use '-device help' to print all possible drivers
+                use '-device driver,help' to print all possible properties
+-name string1[,process=string2][,debug-threads=on|off]
+                set the name of the guest
+                string1 sets the window title and string2 the process name
+                When debug-threads is enabled, individual threads are given a separate name
+                NOTE: The thread names are for debugging and not a stable API.
+-uuid %08x-%04x-%04x-%04x-%012x
+                specify machine UUID
+
+Block device options:
+-fda/-fdb file  use 'file' as floppy disk 0/1 image
+-hda/-hdb file  use 'file' as IDE hard disk 0/1 image
+-hdc/-hdd file  use 'file' as IDE hard disk 2/3 image
+-cdrom file     use 'file' as IDE cdrom image (cdrom is ide1 master)
+-blockdev [driver=]driver[,node-name=N][,discard=ignore|unmap]
+          [,cache.direct=on|off][,cache.no-flush=on|off]
+          [,read-only=on|off][,auto-read-only=on|off]
+          [,force-share=on|off][,detect-zeroes=on|off|unmap]
+          [,driver specific parameters...]
+                configure a block backend
+-drive [file=file][,if=type][,bus=n][,unit=m][,media=d][,index=i]
+       [,cache=writethrough|writeback|none|directsync|unsafe][,format=f]
+       [,snapshot=on|off][,rerror=ignore|stop|report]
+       [,werror=ignore|stop|report|enospc][,id=name][,aio=threads|native]
+       [,readonly=on|off][,copy-on-read=on|off]
+       [,discard=ignore|unmap][,detect-zeroes=on|off|unmap]
+       [[,bps=b]|[[,bps_rd=r][,bps_wr=w]]]
+       [[,iops=i]|[[,iops_rd=r][,iops_wr=w]]]
+       [[,bps_max=bm]|[[,bps_rd_max=rm][,bps_wr_max=wm]]]
+       [[,iops_max=im]|[[,iops_rd_max=irm][,iops_wr_max=iwm]]]
+       [[,iops_size=is]]
+       [[,group=g]]
+                use 'file' as a drive image
+-mtdblock file  use 'file' as on-board Flash memory image
+-sd file        use 'file' as SecureDigital card image
+-pflash file    use 'file' as a parallel flash image
+-snapshot       write to temporary files instead of disk image files
+-fsdev local,id=id,path=path,security_model=mapped-xattr|mapped-file|passthrough|none
+ [,writeout=immediate][,readonly][,fmode=fmode][,dmode=dmode]
+ [[,throttling.bps-total=b]|[[,throttling.bps-read=r][,throttling.bps-write=w]]]
+ [[,throttling.iops-total=i]|[[,throttling.iops-read=r][,throttling.iops-write=w]]]
+ [[,throttling.bps-total-max=bm]|[[,throttling.bps-read-max=rm][,throttling.bps-write-max=wm]]]
+ [[,throttling.iops-total-max=im]|[[,throttling.iops-read-max=irm][,throttling.iops-write-max=iwm]]]
+ [[,throttling.iops-size=is]]
+-fsdev proxy,id=id,socket=socket[,writeout=immediate][,readonly]
+-fsdev proxy,id=id,sock_fd=sock_fd[,writeout=immediate][,readonly]
+-fsdev synth,id=id
+-virtfs local,path=path,mount_tag=tag,security_model=mapped-xattr|mapped-file|passthrough|none
+        [,id=id][,writeout=immediate][,readonly][,fmode=fmode][,dmode=dmode][,multidevs=remap|forbid|warn]
+-virtfs proxy,mount_tag=tag,socket=socket[,id=id][,writeout=immediate][,readonly]
+-virtfs proxy,mount_tag=tag,sock_fd=sock_fd[,id=id][,writeout=immediate][,readonly]
+-virtfs synth,mount_tag=tag[,id=id][,readonly]
+-iscsi [user=user][,password=password]
+       [,header-digest=CRC32C|CR32C-NONE|NONE-CRC32C|NONE
+       [,initiator-name=initiator-iqn][,id=target-iqn]
+       [,timeout=timeout]
+                iSCSI session parameters
+
+USB options:
+-usb            enable on-board USB host controller (if not enabled by default)
+-usbdevice name add the host or guest USB device 'name'
+
+Display options:
+-display gtk[,grab_on_hover=on|off][,gl=on|off]|
+-display vnc=<display>[,<optargs>]
+-display curses[,charset=<encoding>]
+-display none
+                select display backend type
+                The default display is equivalent to
+                "-display gtk"
+-nographic      disable graphical output and redirect serial I/Os to console
+-curses         shorthand for -display curses
+-alt-grab       use Ctrl-Alt-Shift to grab mouse (instead of Ctrl-Alt)
+-ctrl-grab      use Right-Ctrl to grab mouse (instead of Ctrl-Alt)
+-no-quit        disable SDL window close capability
+-sdl            shorthand for -display sdl
+-spice [port=port][,tls-port=secured-port][,x509-dir=<dir>]
+       [,x509-key-file=<file>][,x509-key-password=<file>]
+       [,x509-cert-file=<file>][,x509-cacert-file=<file>]
+       [,x509-dh-key-file=<file>][,addr=addr][,ipv4|ipv6|unix]
+       [,tls-ciphers=<list>]
+       [,tls-channel=[main|display|cursor|inputs|record|playback]]
+       [,plaintext-channel=[main|display|cursor|inputs|record|playback]]
+       [,sasl][,password=<secret>][,disable-ticketing]
+       [,image-compression=[auto_glz|auto_lz|quic|glz|lz|off]]
+       [,jpeg-wan-compression=[auto|never|always]]
+       [,zlib-glz-wan-compression=[auto|never|always]]
+       [,streaming-video=[off|all|filter]][,disable-copy-paste]
+       [,disable-agent-file-xfer][,agent-mouse=[on|off]]
+       [,playback-compression=[on|off]][,seamless-migration=[on|off]]
+       [,gl=[on|off]][,rendernode=<file>]
+   enable spice
+   at least one of {port, tls-port} is mandatory
+-portrait       rotate graphical output 90 deg left (only PXA LCD)
+-rotate <deg>   rotate graphical output some deg left (only PXA LCD)
+-vga [std|cirrus|vmware|qxl|xenfb|tcx|cg3|virtio|none]
+                select video card type
+-full-screen    start in full screen
+-vnc <display>  shorthand for -display vnc=<display>
+
+Network options:
+-netdev user,id=str[,ipv4[=on|off]][,net=addr[/mask]][,host=addr]
+         [,ipv6[=on|off]][,ipv6-net=addr[/int]][,ipv6-host=addr]
+         [,restrict=on|off][,hostname=host][,dhcpstart=addr]
+         [,dns=addr][,ipv6-dns=addr][,dnssearch=domain][,domainname=domain]
+         [,tftp=dir][,tftp-server-name=name][,bootfile=f][,hostfwd=rule][,guestfwd=rule][,smb=dir[,smbserver=addr]]
+                configure a user mode network backend with ID 'str',
+                its DHCP server and optional services
+-netdev tap,id=str[,fd=h][,fds=x:y:...:z][,ifname=name][,script=file][,downscript=dfile]
+         [,br=bridge][,helper=helper][,sndbuf=nbytes][,vnet_hdr=on|off][,vhost=on|off]
+         [,vhostfd=h][,vhostfds=x:y:...:z][,vhostforce=on|off][,queues=n]
+         [,poll-us=n]
+                configure a host TAP network backend with ID 'str'
+                connected to a bridge (default=br0)
+                use network scripts 'file' (default=/etc/qemu-ifup)
+                to configure it and 'dfile' (default=/etc/qemu-ifdown)
+                to deconfigure it
+                use '[down]script=no' to disable script execution
+                use network helper 'helper' (default=/usr/local/libexec/qemu-bridge-helper) to
+                configure it
+                use 'fd=h' to connect to an already opened TAP interface
+                use 'fds=x:y:...:z' to connect to already opened multiqueue capable TAP interfaces
+                use 'sndbuf=nbytes' to limit the size of the send buffer (the
+                default is disabled 'sndbuf=0' to enable flow control set 'sndbuf=1048576')
+                use vnet_hdr=off to avoid enabling the IFF_VNET_HDR tap flag
+                use vnet_hdr=on to make the lack of IFF_VNET_HDR support an error condition
+                use vhost=on to enable experimental in kernel accelerator
+                    (only has effect for virtio guests which use MSIX)
+                use vhostforce=on to force vhost on for non-MSIX virtio guests
+                use 'vhostfd=h' to connect to an already opened vhost net device
+                use 'vhostfds=x:y:...:z to connect to multiple already opened vhost net devices
+                use 'queues=n' to specify the number of queues to be created for multiqueue TAP
+                use 'poll-us=n' to speciy the maximum number of microseconds that could be
+                spent on busy polling for vhost net
+-netdev bridge,id=str[,br=bridge][,helper=helper]
+                configure a host TAP network backend with ID 'str' that is
+                connected to a bridge (default=br0)
+                using the program 'helper (default=/usr/local/libexec/qemu-bridge-helper)
+-netdev l2tpv3,id=str,src=srcaddr,dst=dstaddr[,srcport=srcport][,dstport=dstport]
+         [,rxsession=rxsession],txsession=txsession[,ipv6=on/off][,udp=on/off]
+         [,cookie64=on/off][,counter][,pincounter][,txcookie=txcookie]
+         [,rxcookie=rxcookie][,offset=offset]
+                configure a network backend with ID 'str' connected to
+                an Ethernet over L2TPv3 pseudowire.
+                Linux kernel 3.3+ as well as most routers can talk
+                L2TPv3. This transport allows connecting a VM to a VM,
+                VM to a router and even VM to Host. It is a nearly-universal
+                standard (RFC3931). Note - this implementation uses static
+                pre-configured tunnels (same as the Linux kernel).
+                use 'src=' to specify source address
+                use 'dst=' to specify destination address
+                use 'udp=on' to specify udp encapsulation
+                use 'srcport=' to specify source udp port
+                use 'dstport=' to specify destination udp port
+                use 'ipv6=on' to force v6
+                L2TPv3 uses cookies to prevent misconfiguration as
+                well as a weak security measure
+                use 'rxcookie=0x012345678' to specify a rxcookie
+                use 'txcookie=0x012345678' to specify a txcookie
+                use 'cookie64=on' to set cookie size to 64 bit, otherwise 32
+                use 'counter=off' to force a 'cut-down' L2TPv3 with no counter
+                use 'pincounter=on' to work around broken counter handling in peer
+                use 'offset=X' to add an extra offset between header and data
+-netdev socket,id=str[,fd=h][,listen=[host]:port][,connect=host:port]
+                configure a network backend to connect to another network
+                using a socket connection
+-netdev socket,id=str[,fd=h][,mcast=maddr:port[,localaddr=addr]]
+                configure a network backend to connect to a multicast maddr and port
+                use 'localaddr=addr' to specify the host address to send packets from
+-netdev socket,id=str[,fd=h][,udp=host:port][,localaddr=host:port]
+                configure a network backend to connect to another network
+                using an UDP tunnel
+-netdev vhost-user,id=str,chardev=dev[,vhostforce=on|off]
+                configure a vhost-user network, backed by a chardev 'dev'
+-netdev hubport,id=str,hubid=n[,netdev=nd]
+                configure a hub port on the hub with ID 'n'
+-nic [tap|bridge|user|l2tpv3|vhost-user|socket][,option][,...][mac=macaddr]
+                initialize an on-board / default host NIC (using MAC address
+                macaddr) and connect it to the given host network backend
+-nic none       use it alone to have zero network devices (the default is to
+                provided a 'user' network connection)
+-net nic[,macaddr=mac][,model=type][,name=str][,addr=str][,vectors=v]
+                configure or create an on-board (or machine default) NIC and
+                connect it to hub 0 (please use -nic unless you need a hub)
+-net [user|tap|bridge|socket][,option][,option][,...]
+                old way to initialize a host network interface
+                (use the -netdev option if possible instead)
+
+Character device options:
+-chardev help
+-chardev null,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev socket,id=id[,host=host],port=port[,to=to][,ipv4][,ipv6][,nodelay][,reconnect=seconds]
+         [,server][,nowait][,telnet][,websocket][,reconnect=seconds][,mux=on|off]
+         [,logfile=PATH][,logappend=on|off][,tls-creds=ID][,tls-authz=ID] (tcp)
+-chardev socket,id=id,path=path[,server][,nowait][,telnet][,websocket][,reconnect=seconds]
+         [,mux=on|off][,logfile=PATH][,logappend=on|off] (unix)
+-chardev udp,id=id[,host=host],port=port[,localaddr=localaddr]
+         [,localport=localport][,ipv4][,ipv6][,mux=on|off]
+         [,logfile=PATH][,logappend=on|off]
+-chardev msmouse,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev vc,id=id[[,width=width][,height=height]][[,cols=cols][,rows=rows]]
+         [,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev ringbuf,id=id[,size=size][,logfile=PATH][,logappend=on|off]
+-chardev file,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev pipe,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev pty,id=id[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev stdio,id=id[,mux=on|off][,signal=on|off][,logfile=PATH][,logappend=on|off]
+-chardev serial,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev tty,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev parallel,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
+-chardev parport,id=id,path=path[,mux=on|off][,logfile=PATH][,logappend=on|off]
+
+TPM device options:
+-tpmdev passthrough,id=id[,path=path][,cancel-path=path]
+                use path to provide path to a character device; default is /dev/tpm0
+                use cancel-path to provide path to TPM's cancel sysfs entry; if
+                not provided it will be searched for in /sys/class/misc/tpm?/device
+-tpmdev emulator,id=id,chardev=dev
+                configure the TPM device using chardev backend
+
+Linux/Multiboot boot specific:
+-kernel bzImage use 'bzImage' as kernel image
+-append cmdline use 'cmdline' as kernel command line
+-initrd file    use 'file' as initial ram disk
+-dtb    file    use 'file' as device tree image
+
+Debug/Expert options:
+-fw_cfg [name=]<name>,file=<file>
+                add named fw_cfg entry with contents from file
+-fw_cfg [name=]<name>,string=<str>
+                add named fw_cfg entry with contents from string
+-serial dev     redirect the serial port to char device 'dev'
+-parallel dev   redirect the parallel port to char device 'dev'
+-monitor dev    redirect the monitor to char device 'dev'
+-qmp dev        like -monitor but opens in 'control' mode
+-qmp-pretty dev like -qmp but uses pretty JSON formatting
+-mon [chardev=]name[,mode=readline|control][,pretty[=on|off]]
+-debugcon dev   redirect the debug console to char device 'dev'
+-pidfile file   write PID to 'file'
+-singlestep     always run in singlestep mode
+--preconfig     pause QEMU before machine is initialized (experimental)
+-S              freeze CPU at startup (use 'c' to start execution)
+-realtime [mlock=on|off]
+                run qemu with realtime features
+                mlock=on|off controls mlock support (default: on)
+-overcommit [mem-lock=on|off][cpu-pm=on|off]
+                run qemu with overcommit hints
+                mem-lock=on|off controls memory lock support (default: off)
+                cpu-pm=on|off controls cpu power management (default: off)
+-gdb dev        accept gdb connection on 'dev'. (QEMU defaults to starting
+                the guest without waiting for gdb to connect; use -S too
+                if you want it to not start execution.)
+-s              shorthand for -gdb tcp::1234
+-d item1,...    enable logging of specified items (use '-d help' for a list of log items)
+-D logfile      output log to logfile (default stderr)
+-dfilter range,..  filter debug output to range of addresses (useful for -d cpu,exec,etc..)
+-seed number       seed the pseudo-random number generator
+-L path         set the directory for the BIOS, VGA BIOS and keymaps
+-bios file      set the filename for the BIOS
+-enable-kvm     enable KVM full virtualization support
+-xen-domid id   specify xen guest domain id
+-xen-attach     attach to existing xen domain
+                libxl will use this when starting QEMU
+-xen-domid-restrict     restrict set of available xen operations
+                        to specified domain id. (Does not affect
+                        xenpv machine type).
+-no-reboot      exit instead of rebooting
+-no-shutdown    stop before shutdown
+-loadvm [tag|id]
+                start right away with a saved state (loadvm in monitor)
+-daemonize      daemonize QEMU after initializing
+-option-rom rom load a file, rom, into the option ROM space
+-rtc [base=utc|localtime|<datetime>][,clock=host|rt|vm][,driftfix=none|slew]
+                set the RTC base and clock, enable drift fix for clock ticks (x86 only)
+-icount [shift=N|auto][,align=on|off][,sleep=on|off,rr=record|replay,rrfile=<filename>,rrsnapshot=<snapshot>]
+                enable virtual instruction counter with 2^N clock ticks per
+                instruction, enable aligning the host and virtual clocks
+                or disable real time cpu sleeping
+-watchdog model
+                enable virtual hardware watchdog [default=none]
+-watchdog-action reset|shutdown|poweroff|inject-nmi|pause|debug|none
+                action when watchdog fires [default=reset]
+-echr chr       set terminal escape character instead of ctrl-a
+-show-cursor    show cursor
+-tb-size n      set TB size
+-incoming tcp:[host]:port[,to=maxport][,ipv4][,ipv6]
+-incoming rdma:host:port[,ipv4][,ipv6]
+-incoming unix:socketpath
+                prepare for incoming migration, listen on
+                specified protocol and socket address
+-incoming fd:fd
+-incoming exec:cmdline
+                accept incoming migration on given file descriptor
+                or from given external command
+-incoming defer
+                wait for the URI to be specified via migrate_incoming
+-only-migratable     allow only migratable devices
+-nodefaults     don't create default devices
+-chroot dir     chroot to dir just before starting the VM
+-runas user     change to user id user just before starting the VM
+                user can be numeric uid:gid instead
+-sandbox on[,obsolete=allow|deny][,elevateprivileges=allow|deny|children]
+          [,spawn=allow|deny][,resourcecontrol=allow|deny]
+                Enable seccomp mode 2 system call filter (default 'off').
+                use 'obsolete' to allow obsolete system calls that are provided
+                    by the kernel, but typically no longer used by modern
+                    C library implementations.
+                use 'elevateprivileges' to allow or deny QEMU process to elevate
+                    its privileges by blacklisting all set*uid|gid system calls.
+                    The value 'children' will deny set*uid|gid system calls for
+                    main QEMU process but will allow forks and execves to run unprivileged
+                use 'spawn' to avoid QEMU to spawn new threads or processes by
+                     blacklisting *fork and execve
+                use 'resourcecontrol' to disable process affinity and schedular priority
+-readconfig <file>
+-writeconfig <file>
+                read/write config file
+-no-user-config
+                do not load default user-provided config files at startup
+-trace [[enable=]<pattern>][,events=<file>][,file=<file>]
+                specify tracing options
+-plugin [file=]<file>[,arg=<string>]
+                load a plugin
+-enable-fips    enable FIPS 140-2 compliance
+-msg timestamp[=on|off]
+                control error message format
+                timestamp=on enables timestamps (default: off)
+-dump-vmstate <file>
+                Output vmstate information in JSON format to file.
+                Use the scripts/vmstate-static-checker.py file to
+                check for possible regressions in migration code
+                by comparing two such vmstate dumps.
+-enable-sync-profile
+                enable synchronization profiling
+
+Generic object creation:
+-object TYPENAME[,PROP1=VALUE1,...]
+                create a new object of type TYPENAME setting properties
+                in the order they are specified.  Note that the 'id'
+                property must be set.  These objects are placed in the
+                '/objects' path.
+
+During emulation, the following keys are useful:
+ctrl-alt-f      toggle full screen
+ctrl-alt-n      switch to virtual console 'n'
+ctrl-alt        toggle mouse and keyboard grab
+
+When using -nographic, press 'ctrl-a h' to get some help.
+
+See <https://qemu.org/contribute/report-a-bug> for how to report bugs.
+More information on the QEMU project at <https://qemu.org>.
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index 194e2e5..a82e78c 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -2,6 +2,8 @@
 
 #include <utility/ostream.h>
 
+#include <utility/elf.h>
+#include <utility/debug.h>
 #include <system/info.h>
 #include <architecture.h>
 #include <machine.h>
@@ -24,11 +26,13 @@ extern "C"
         // _start();
     }
     void _print(const char * s) { Display::puts(s); }
+    void _panic() { Machine::panic(); }
+
 }
 
-char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________";
+// char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!_____________________________________________________________________________________________________________________________________________________________________________________________";
 System_Info * si;
-EPOS::S::U::OStream kout, kerr;
 
 extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
     Reg id = CPU::mcause();
@@ -42,11 +46,20 @@ extern "C" [[gnu::interrupt, gnu::aligned(4)]] void _mmode_forward() {
 }
 
 __BEGIN_SYS
+EPOS::S::U::OStream kout, kerr;
+char * bi;
 
 class Setup_SifiveE {
 private:
+    // Physical memory map
+    static const unsigned int SYS_INFO = Memory_Map::SYS_INFO;
+    static const unsigned int PAGE_TABLES = Traits<Machine>::PAGE_TABLES;
+    static const unsigned int MEM_BASE = Memory_Map::MEM_BASE;
+    static const unsigned int MEM_TOP = Memory_Map::MEM_TOP;
+    
     typedef CPU::Reg Reg;
     typedef MMU::RV32_Flags RV32_Flags;
+    typedef MMU::Page Page;
     typedef MMU::Page_Table Page_Table;
     typedef MMU::Page_Directory Page_Directory;
     typedef MMU::PT_Entry PT_Entry;
@@ -57,8 +70,254 @@ public:
     static void setup_supervisor_environment();
     static void build_page_tables();
     static void clean_bss();
+    static void build_lm();
+    static void load_parts();
 };
 
+// !P2:
+
+void Setup_SifiveE::load_parts()
+{
+    // Relocate System_Info
+    if(sizeof(System_Info) > sizeof(Page))
+        db<Setup>(WRN) << "System_Info is bigger than a page (" << sizeof(System_Info) << ")!" << endl;
+    memcpy(reinterpret_cast<void *>(SYS_INFO), si, sizeof(System_Info));
+
+    // Load INIT
+    ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+    ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+    
+    if(si->lm.has_ini) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_init()" << endl;
+        if(ini_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "INIT code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        
+        for(int i = 1; i < ini_elf->segments(); i++)
+            if(ini_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "INIT data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    
+    if((long unsigned int)ini_elf->segment_size(0) > sys_elf->segment_address(0) - ini_elf->segment_address(0)) {
+        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "init has " << hex << sys_elf->segment_address(0) - ini_elf->segment_address(0) - ini_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    // Load SYSTEM
+    if(si->lm.has_sys) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_system()" << endl;
+        if(sys_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "system code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        for(int i = 1; i < sys_elf->segments(); i++)
+            if(sys_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "system data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    
+    if((long unsigned int)sys_elf->segment_size(0) > sys_elf->segment_address(1) - sys_elf->segment_address(0)) {
+        db<Setup>(ERR) << "sys code is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "sys code has " << hex << sys_elf->segment_address(1) - sys_elf->segment_address(0) - sys_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    if((long unsigned int)ini_elf->segment_size(1) > sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1)) {
+        db<Setup>(ERR) << "init is larger than its reserved memory" << endl;
+        _panic();
+    } 
+    db<Setup>(TRC) << "sys data has " << hex << sys_elf->segment_address(1) + 0x00100000 - sys_elf->segment_address(1) - ini_elf->segment_size(1) << " unused bytes of memory" << endl;
+
+    // // Load APP
+    // if(si->lm.has_app) {
+    //     ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+    //     db<Setup>(TRC) << "PC_Setup::load_app()" << endl;
+    //     if(app_elf->load_segment(0) < 0) {
+    //         db<Setup>(ERR) << "Application code segment was corrupted during SETUP!" << endl;
+    //         _panic();
+    //     }
+    //     for(int i = 1; i < app_elf->segments(); i++)
+    //         if(app_elf->load_segment(i) < 0) {
+    //             db<Setup>(ERR) << "Application data segment was corrupted during SETUP!" << endl;
+    //             _panic();
+    //         }
+    // }
+
+}
+
+
+void Setup_SifiveE::build_lm()
+{
+    // Get boot image structure
+    si->lm.has_stp = (si->bm.setup_offset != -1u);
+    si->lm.has_ini = (si->bm.init_offset != -1u);
+    si->lm.has_sys = (si->bm.system_offset != -1u);
+    si->lm.has_app = (si->bm.application_offset != -1u);
+    si->lm.has_ext = (si->bm.extras_offset != -1u);
+
+    // Check SETUP integrity and get the size of its segments
+    si->lm.stp_entry = 0;
+    si->lm.stp_segments = 0;
+    si->lm.stp_code = ~0U;
+    si->lm.stp_code_size = 0;
+    si->lm.stp_data = ~0U;
+    si->lm.stp_data_size = 0;
+
+    db<Spin>(ERR) << "SETUP ELF image is corrupted!" << endl;
+    EPOS::S::kout << "oioioioioio" << endl;
+    bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE);
+    if(si->lm.has_stp) {
+        ELF * stp_elf = reinterpret_cast<ELF *>(&bi[si->bm.setup_offset]);
+        if(!stp_elf->valid()) {
+            db<Setup>(ERR) << "SETUP ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.stp_entry = stp_elf->entry();
+        si->lm.stp_segments = stp_elf->segments();
+        si->lm.stp_code = stp_elf->segment_address(0);
+        si->lm.stp_code_size = stp_elf->segment_size(0);
+        if(stp_elf->segments() > 1) {
+            for(int i = 1; i < stp_elf->segments(); i++) {
+                if(stp_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(stp_elf->segment_address(i) < si->lm.stp_data)
+                    si->lm.stp_data = stp_elf->segment_address(i);
+                si->lm.stp_data_size += stp_elf->segment_size(i);
+            }
+        }
+    }
+
+
+    // Check INIT integrity and get the size of its segments
+    si->lm.ini_entry = 0;
+    si->lm.ini_segments = 0;
+    si->lm.ini_code = ~0U;
+    si->lm.ini_code_size = 0;
+    si->lm.ini_data = ~0U;
+    si->lm.ini_data_size = 0;
+    if(si->lm.has_ini) {
+        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+        if(!ini_elf->valid()) {
+            db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.ini_entry = ini_elf->entry();
+        si->lm.ini_segments = ini_elf->segments();
+        si->lm.ini_code = ini_elf->segment_address(0);
+        si->lm.ini_code_size = ini_elf->segment_size(0);
+        if(ini_elf->segments() > 1) {
+            for(int i = 1; i < ini_elf->segments(); i++) {
+                if(ini_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(ini_elf->segment_address(i) < si->lm.ini_data)
+                    si->lm.ini_data = ini_elf->segment_address(i);
+                si->lm.ini_data_size += ini_elf->segment_size(i);
+            }
+        }
+    }
+
+    // Check SYSTEM integrity and get the size of its segments
+    si->lm.sys_entry = 0;
+    si->lm.sys_segments = 0;
+    si->lm.sys_code = ~0U;
+    si->lm.sys_code_size = 0;
+    si->lm.sys_data = ~0U;
+    si->lm.sys_data_size = 0;
+    // si->lm.sys_stack = SYS_STACK;
+    // si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
+    if(si->lm.has_sys) {
+        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+        if(!sys_elf->valid()) {
+            db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.sys_entry = sys_elf->entry();
+        si->lm.sys_segments = sys_elf->segments();
+        si->lm.sys_code = sys_elf->segment_address(0);
+        si->lm.sys_code_size = sys_elf->segment_size(0);
+        if(sys_elf->segments() > 1) {
+            for(int i = 1; i < sys_elf->segments(); i++) {
+                if(sys_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(sys_elf->segment_address(i) < si->lm.sys_data)
+                    si->lm.sys_data = sys_elf->segment_address(i);
+                si->lm.sys_data_size += sys_elf->segment_size(i);
+            }
+        }
+
+        // if(si->lm.sys_code != SYS_CODE) {
+        //     db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
+        //     db<Setup>(ERR) << "OS code segment is too large!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_data != SYS_DATA) {
+        //     db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
+        //     _panic();
+        // }
+        // if(si->lm.sys_data + si->lm.sys_data_size > si->lm.sys_stack) {
+        //     db<Setup>(ERR) << "OS data segment is too large!" << endl;
+        //     panic();
+        // }
+        // if(MMU::page_tables(MMU::pages(si->lm.sys_stack - SYS + si->lm.sys_stack_size)) > 1) {
+        //     db<Setup>(ERR) << "OS stack segment is too large!" << endl;
+        //     _panic();
+        // }
+    }
+
+    // Check APPLICATION integrity and get the size of its segments
+    si->lm.app_entry = 0;
+    si->lm.app_segments = 0;
+    si->lm.app_code = ~0U;
+    si->lm.app_code_size = 0;
+    si->lm.app_data = ~0U;
+    si->lm.app_data_size = 0;
+    if(si->lm.has_app) {
+        ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset]);
+        if(!app_elf->valid()) {
+            db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
+            _panic();
+        }
+        si->lm.app_entry = app_elf->entry();
+        si->lm.app_segments = app_elf->segments();
+        si->lm.app_code = app_elf->segment_address(0);
+        si->lm.app_code_size = app_elf->segment_size(0);
+        if(app_elf->segments() > 1) {
+            for(int i = 1; i < app_elf->segments(); i++) {
+                if(app_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(app_elf->segment_address(i) < si->lm.app_data)
+                    si->lm.app_data = app_elf->segment_address(i);
+                si->lm.app_data_size += app_elf->segment_size(i);
+            }
+        }
+        // if(Traits<System>::multiheap) { // Application heap in data segment
+        //     si->lm.app_data_size = MMU::align_page(si->lm.app_data_size);
+        //     si->lm.app_stack = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::STACK_SIZE);
+        //     si->lm.app_heap = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_data_size += MMU::align_page(Traits<Application>::HEAP_SIZE);
+        // }
+        // if(si->lm.has_ext) { // Check for EXTRA data in the boot image
+        //     si->lm.app_extra = si->lm.app_data + si->lm.app_data_size;
+        //     si->lm.app_extra_size = si->bm.img_size - si->bm.extras_offset;
+        //     if(Traits<System>::multiheap)
+        //         si->lm.app_extra_size = MMU::align_page(si->lm.app_extra_size);
+        //     si->lm.app_data_size += si->lm.app_extra_size;
+        // }
+    }
+}
+
 void Setup_SifiveE::build_page_tables()
 {
     // Address of the Directory
@@ -103,8 +362,13 @@ void Setup_SifiveE::setup_supervisor_environment()
     build_page_tables();
 
     //!P2: How could machine pre_init run before Init_System if it was linked w/ SYS?
-    // if(CPU::id() == 0)
-    //     Display::init();
+    if(CPU::id() == 0)
+        Display::init();
+
+    si = reinterpret_cast<System_Info*>(placeholder);
+    build_lm();
+    
+    load_parts();
 
     // db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
 
@@ -117,7 +381,8 @@ void Setup_SifiveE::setup_supervisor_environment()
 
     // forward everything
     CPU::satp((0x1 << 31) | (Traits<Machine>::PAGE_TABLES >> 12));
-    // CPU::sepc_write((unsigned)&_start);
+    
+    CPU::sepc_write(si->lm.ini_entry);
 
     // Interrupts will remain disable until the Context::load at Init_First
     CPU::sstatus_write(CPU::SPP_S);
@@ -128,7 +393,6 @@ void Setup_SifiveE::setup_supervisor_environment()
 
 void Setup_SifiveE::setup_machine_environment()
 {
-    si = reinterpret_cast<System_Info*>(placeholder);
     // We first configure the M-mode CSRs and then switch to S-mode
     // configure paging. After that, we won't return to M-mode; an exception
     // is the forwarding of ints and excps to S-mode.
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
deleted file mode 120000
index fa235ad..0000000
--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
+++ /dev/null
@@ -1 +0,0 @@
-../scheduler_rm_test/scheduler_rm_test.cc
\ No newline at end of file
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
deleted file mode 120000
index fa235ad..0000000
--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
+++ /dev/null
@@ -1 +0,0 @@
-../scheduler_rm_test/scheduler_rm_test.cc
\ No newline at end of file
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
index 75a2801..c7ed1ff 100644
--- a/tools/eposmkbi/eposmkbi.cc
+++ b/tools/eposmkbi/eposmkbi.cc
@@ -166,6 +166,11 @@ int main(int argc, char **argv)
     unsigned int image_size = 0;
     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
 
+    // !P2:
+    // riscv boot jump: jal 0x78
+    unsigned int boot_jump = 0b111100000000000000001101111; 
+    image_size += put_number(fd_img, boot_jump);
+    
     // Add BOOT
     if(CONFIG.boot_length_max > 0) {
         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
@@ -181,6 +186,8 @@ int main(int argc, char **argv)
         }
     }
     unsigned int boot_size = image_size;
+    // !P2:
+    boot_size = 0;
 
     // Determine if System_Info is needed and how it must be handled
     bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
@@ -210,10 +217,10 @@ int main(int argc, char **argv)
     si.bm.space_z  = CONFIG.space_z;
 
     fprintf(out, "\nsi.bm.n_cpus %u", si.bm.n_cpus);
-    fprintf(out, "\nsi.bm.mem_base %u", si.bm.mem_base);
-    fprintf(out, "\nsi.bm.mem_top %u", si.bm.mem_top);
-    fprintf(out, "\nsi.bm.mio_base %u", si.bm.mio_base);
-    fprintf(out, "\nsi.bm.mio_top %u", si.bm.mio_top);
+    fprintf(out, "\nsi.bm.mem_base %08x", si.bm.mem_base);
+    fprintf(out, "\nsi.bm.mem_top %08x", si.bm.mem_top);
+    fprintf(out, "\nsi.bm.mio_base %08x", si.bm.mio_base);
+    fprintf(out, "\nsi.bm.mio_top %08x", si.bm.mio_top);
     fprintf(out, "\nsi.bm.node_id %u", si.bm.node_id);
     fprintf(out, "\nsi.bm.space_x %u", si.bm.space_x);
     fprintf(out, "\nsi.bm.space_y %u", si.bm.space_y);
