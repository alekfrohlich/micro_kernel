diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
index 4e522fb..33eb36f 100644
--- a/include/architecture/rv32/rv32_mmu.h
+++ b/include/architecture/rv32/rv32_mmu.h
@@ -71,25 +71,34 @@ public:
         // }
 
         void map(const RV32_Flags & flags, int from, int to) {
-            // Phy_Addr * addr = alloc(to - from);
-            // if(addr)
-            //     remap(addr, flags, from , to);
+            Phy_Addr * addr = alloc(to - from);
+            if(addr)
+                remap(addr, flags, from , to);
             // else
-            //     for( ; from < to; from++) {
-            //         Log_Addr * tmp = phy2log(&ptes[from]);
-            //         *tmp = alloc(1) | flags;
-            //         unsigned int pte = ((addr - Traits<Machine>::PAGE_TABLES)>>12) - 1;
-            //         pte = pte << 20;
-            //         pte += ((from) << 10);
-            //         pte = pte | flags;
-            //         ptes[i] = pte;
-            //     }
+                // for( ; from < to; from++) {
+                //     Log_Addr * tmp = phy2log(&ptes[from]);
+                //     *tmp = alloc(1) | flags;
+                //     unsigned int pte = ((addr - Traits<Machine>::PAGE_TABLES)>>12) - 1;
+                //     pte = pte << 20;
+                //     pte += ((from) << 10);
+                //     pte = pte | flags;
+                //     ptes[i] = pte;
+                // }
         }
 
+        // void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
+        //     for(int i = from; i < to; i++) {
+        //         unsigned int pte = ((this - Traits<Machine>::PAGE_TABLES)>>12) - 1;
+        //         pte = pte << 20;
+        //         pte += ((i) << 10);
+        //         pte = pte | flags;
+        //         ptes[i] = pte;
+        //     }
+        // }
+
         void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
             for(int i = from; i < to; i++) {
-                unsigned int pte = ((phy_addr - Traits<Machine>::PAGE_TABLES)>>12) - 1;
-                pte = pte << 20;
+                unsigned int pte = phy_addr >> 2;
                 pte += ((i) << 10);
                 pte = pte | flags;
                 ptes[i] = pte;
@@ -148,7 +157,15 @@ public:
     class Directory
     {
     public:
-        Directory() {}
+        // Directory() {}
+        Directory() : _pd(calloc(1)) {
+            kout << "Directory" << endl;
+            for(unsigned int i = 0; i < 544; i++){
+                (*_pd)[i] = (*_master)[i];
+                kout << i << endl;
+            }
+
+        }
         // Directory(Page_Directory * pd) {}
         Directory(Page_Directory * pd) : _pd(pd) {}
 
@@ -160,9 +177,16 @@ public:
         // Log_Addr attach(const Chunk & chunk) { return chunk.phy_address(); }
         // Log_Addr attach(const Chunk & chunk, Log_Addr addr) { return (addr == chunk.phy_address())? addr : Log_Addr(false); }
 
+        Log_Addr attach(const Chunk & chunk, unsigned int from = 0) {
+            for(unsigned int i = from; i < PD_ENTRIES; i++)
+                if(attach(i, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                    return i << DIRECTORY_SHIFT;
+            return false;
+        }
+
         Log_Addr attach(const Chunk & chunk, const Log_Addr & addr) {
             unsigned int from = directory(addr);
-            if(!attach(from, chunk.pt(), chunk.pts(), chunk.flags()))
+            if(!attach(from, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
                 return Log_Addr(false);
             return from << DIRECTORY_SHIFT;
         }
@@ -177,7 +201,7 @@ public:
                 if((*static_cast<Page_Directory *>(phy2log(_pd)))[i]) //it has already been used
                     return false;
             for(unsigned int i = from; i < from + n; i++, pt++)
-                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = Phy_Addr(pt) | flags;
+                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = Phy_Addr(pt) | flags; // is pt the correct value?
             return true;
         }
 
diff --git a/include/process.h b/include/process.h
index 6beda50..245e11d 100644
--- a/include/process.h
+++ b/include/process.h
@@ -178,34 +178,35 @@ private:
 };
 
 
-// class Task
-// {
-// private:
-//     static const bool multitask = Traits<System>::multitask;
-
-// public:
-//     template<typename ... Tn>
-//     Task(const Thread::Configuration & conf, Segment * cs, Segment * ds, int (* entry)(Tn ...), Tn ... an)
-//     : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _entry(entry), _code(_as->attach(_cs)), _data(_as->attach(_ds)) {
-//         db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds << ",entry=" << _entry << ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+class Task
+{
+private:
+    static const bool multitask = Traits<System>::multitask;
+    typedef CPU::Log_Addr Log_Addr;
 
-//     }
-//     ~Task();
+public:
+    Task(Segment * cs, Segment * ds)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _code(_as->attach(_cs)), _data(_as->attach(_ds)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    ~Task();
 
-//     Address_Space * address_space() const { return _as; }
+    Address_Space * address_space() const { return _as; }
 
-//     Segment * code_segment() const { return _cs; }
-//     Segment * data_segment() const { return _ds; }
+    Segment * code_segment() const { return _cs; }
+    Segment * data_segment() const { return _ds; }
 
-//     Log_Addr code() const { return _code; }
-//     Log_Addr data() const { return _data; }
+    Log_Addr code() const { return _code; }
+    Log_Addr data() const { return _data; }
 
 
-// private:
-//     Address_Space * _as;
-//     Segment * _cs;
-//     Segment * _ds;
-// };
+private:
+    Address_Space * _as;
+    Segment * _cs;
+    Segment * _ds;
+    Log_Addr _code;
+    Log_Addr _data;
+};
 
 
 // class Task
diff --git a/src/api/address_space.cc b/src/api/address_space.cc
index a1bf4f9..95e107f 100644
--- a/src/api/address_space.cc
+++ b/src/api/address_space.cc
@@ -12,6 +12,7 @@ Address_Space::Address_Space(MMU::Page_Directory * pd) : MMU::Directory(pd)
 Address_Space::Address_Space()
 {
     db<Address_Space> (TRC) << "Address_Space() [Directory::pd=" << Directory::pd() << "] => " << this << endl;
+    kout << "Address_Space() [Directory::pd=" << Directory::pd() << "] => " << this << endl;
 }
 
 Address_Space::~Address_Space()
@@ -19,14 +20,14 @@ Address_Space::~Address_Space()
     db<Address_Space>(TRC) << "~Address_Space(this=" << this << ") [Directory::pd=" << Directory::pd() << "]" << endl;
 }
 
-// Address_Space::Log_Addr Address_Space::attach(Segment * seg)
-// {
-//     Log_Addr tmp = Directory::attach(*seg);
+Address_Space::Log_Addr Address_Space::attach(Segment * seg)
+{
+    Log_Addr tmp = Directory::attach(*seg);
 
-//     db<Address_Space>(TRC) << "Address_Space::attach(this=" << this << ",seg=" << seg << ") => " << tmp << endl;
+    db<Address_Space>(TRC) << "Address_Space::attach(this=" << this << ",seg=" << seg << ") => " << tmp << endl;
 
-//     return tmp;
-// }
+    return tmp;
+}
 
 Address_Space::Log_Addr Address_Space::attach(Segment * seg, const Address_Space::Log_Addr & addr)
 {
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index 4326a72..8fadffc 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -57,25 +57,27 @@ void Setup_SifiveE::build_page_tables()
     Reg page_tables = Traits<Machine>::PAGE_TABLES;
     MMU::_master = new ( (void *) page_tables ) Page_Directory();
 
-    int sys_npages = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
+    int sys_entries = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
+
+    MMU::_master->remap(page_tables, MMU::RV32_Flags::VALID, 0, sys_entries);
 
     // Manually build the kernel directory
-    for(int i = 0; i < sys_npages; i++) {
-        PT_Entry * pte = (((PT_Entry *)MMU::_master) + i);
-        * pte = ((page_tables >> 12) << 10);
-        * pte += ((i+1) << 10);
-        * pte |= MMU::RV32_Flags::VALID;
-    }
+    // for(int i = 0; i < sys_entries; i++) {
+    //     PT_Entry * pte = (((PT_Entry *)MMU::_master) + i);
+    //     * pte = ((page_tables >> 12) << 10);
+    //     * pte += ((i+1) << 10);
+    //     * pte |= MMU::RV32_Flags::VALID;
+    // }
 
     // Map logical addrs back to themselves; with this, the kernel may access any
     // physical RAM address directly (as if paging wasn't there)
-    for(int i = 0; i < sys_npages; i++)
+    for(unsigned i = 0; i < sys_entries; i++)
     {
         Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1)) ) Page_Table();
-        pt->remap(pt, RV32_Flags::SYS);
+        pt->remap(i * 1024*4096, RV32_Flags::SYS);
     }
 
-    // for(int i = sys_npages; i < 1024; i++)
+    // for(int i = sys_entries; i < 1024; i++)
     // {
     //     Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1))  ) Page_Table();
     //     pt->remap(pt, RV32_Flags::USR);
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
deleted file mode 120000
index fa235ad..0000000
--- a/tests/scheduler_dm_test/scheduler_dm_test.cc
+++ /dev/null
@@ -1 +0,0 @@
-../scheduler_rm_test/scheduler_rm_test.cc
\ No newline at end of file
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
deleted file mode 120000
index fa235ad..0000000
--- a/tests/scheduler_edf_test/scheduler_edf_test.cc
+++ /dev/null
@@ -1 +0,0 @@
-../scheduler_rm_test/scheduler_rm_test.cc
\ No newline at end of file
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}