diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..cc0e168
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,11 @@
+{
+    "files.associations": {
+        "makeinc": "makefile",
+        "makedefs": "makefile",
+        "*.cfg": "plaintext",
+        "atomic": "cpp",
+        "vector": "cpp",
+        "ostream": "cpp",
+        "*.tcc": "cpp"
+    }
+}
\ No newline at end of file
diff --git a/HOW_TO.txt b/HOW_TO.txt
new file mode 100644
index 0000000..fd46462
--- /dev/null
+++ b/HOW_TO.txt
@@ -0,0 +1,17 @@
+Patch against c0b8a2517f80f0667ce23e30b51e39c705807a9b: Memory management (multiheap, Address_Space and Segment)
+
+We've implemented the following API interfaces
+
+Thread
+Mutex
+Semaphore
+Clock
+Chronometer
+Display (Shouldn't be on the API, but philosopher_dinner needs it and it is a good test)
+
+We will implement Task/Segment/Address_Space after we've solved a bug of Alarm which is causing us some trouble
+
+Currently, we have the following tests available:
+1) Syscalls: make APPS=test_syscalls run
+2) Switch context: make APPS='test_switch_context test_switch_context test_switch_context' run
+3) philosopher_dinner or producer_consumer, but they have to run separately due to the aforementioned bug on Alarm.
\ No newline at end of file
diff --git a/P3_TODO.txt b/P3_TODO.txt
new file mode 100644
index 0000000..d3ea875
--- /dev/null
+++ b/P3_TODO.txt
@@ -0,0 +1,41 @@
+P3.
+
+P4-P5.
+Detach unmap
+switch context has a bug: sstatus is written directly and no care is taken to avoid reentrancy
+we need to switch address space inside swtich context; for, otherwise, context will be saved in next's.
+App stack and Heap should be on APP_DATA
+Loader will be a U-mode app which will create the Task objects and attach the previously created Segments
+How can the loader inform Init_Application of the Heap's address? And the Stack?
+Remap pages after load_segment()
+
+Interfaces
+----------
+Thread:
+    // How to distinguish these two?
+    Thread(int (* entry)(Tn ...), Tn ... an);
+    Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an);
+
+    ~Thread();
+    static Thread * volatile self() { return running(); }
+    
+    const volatile State & state() const { return _state; }
+    const volatile Priority & priority() const { return _link.rank(); }
+    void priority(const Priority & p);
+    
+    int join();
+    void pass();
+    void suspend();
+    void resume();
+    static void yield();
+    static void exit(int status = 0);
+
+Timing
+-----
+    Alarm(const Microsecond & time, Handler * handler, unsigned int times = 1);
+    ~Alarm();
+    const Microsecond & period() const { return _time; }
+    void period(const Microsecond & p);
+    void reset();
+    static Hertz frequency() { return _timer->frequency(); }
+    static void delay(const Microsecond & time);
\ No newline at end of file
diff --git a/app/hello/hello.cc b/app/hello/hello.cc
index 40c7c05..de57d94 100644
--- a/app/hello/hello.cc
+++ b/app/hello/hello.cc
@@ -1,4 +1,5 @@
 #include <utility/ostream.h>
+#include <time.h>
 
 using namespace EPOS;
 
@@ -6,7 +7,7 @@ OStream cout;
 
 int main()
 {
+    
     cout << "Hello world!" << endl;
-
     return 0;
 }
diff --git a/app/hello/hello_traits.h b/app/hello/hello_traits.h
index 6661b46..a1044e6 100644
--- a/app/hello/hello_traits.h
+++ b/app/hello/hello_traits.h
@@ -9,19 +9,19 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = KERNEL;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
     static const bool monitored = false;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool hysterically_debugged = true;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
@@ -34,7 +34,7 @@ template<> struct Traits<Debug>: public Traits<Build>
     static const bool error   = true;
     static const bool warning = true;
     static const bool info    = false;
-    static const bool trace   = false;
+    static const bool trace   = true;
 };
 
 template<> struct Traits<Lists>: public Traits<Build>
@@ -95,8 +95,9 @@ __BEGIN_SYS
 // API Components
 template<> struct Traits<Application>: public Traits<Build>
 {
+    static const unsigned int APP_HEAP = Traits<Machine>::APP_HEAP;
     static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
-    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int HEAP_SIZE = 4*1024*1024;
     static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
 };
 
@@ -106,7 +107,7 @@ template<> struct Traits<System>: public Traits<Build>
     static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
     static const bool multitask = (mode != Traits<Build>::LIBRARY);
     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
-    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
@@ -129,7 +130,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/philosophers_dinner/philosophers_dinner.cc b/app/philosophers_dinner/philosophers_dinner.cc
index 20ea520..47640ed 100644
--- a/app/philosophers_dinner/philosophers_dinner.cc
+++ b/app/philosophers_dinner/philosophers_dinner.cc
@@ -16,7 +16,13 @@ Semaphore * chopstick[5];
 
 OStream cout;
 
-int philosopher(int n, int l, int c);
+int philosopher(void* params);
+
+struct parameters{
+public:
+  parameters(int _n, int _l, int _c): n(_n), l(_l), c(_c) {}
+  int n, l, c;
+};
 
 int main()
 {
@@ -27,12 +33,16 @@ int main()
 
     for(int i = 0; i < 5; i++)
         chopstick[i] = new Semaphore;
-
-    phil[0] = new Thread(&philosopher, 0,  5, 32);
-    phil[1] = new Thread(&philosopher, 1, 10, 44);
-    phil[2] = new Thread(&philosopher, 2, 16, 39);
-    phil[3] = new Thread(&philosopher, 3, 16, 24);
-    phil[4] = new Thread(&philosopher, 4, 10, 20);
+    parameters p1 = parameters(0,  5, 32);
+    parameters p2 = parameters(1, 10, 44);
+    parameters p3 = parameters(2, 16, 39);
+    parameters p4 = parameters(3, 16, 24);
+    parameters p5 = parameters(4, 10, 20);
+    phil[0] = new Thread(&philosopher, &p1);
+    phil[1] = new Thread(&philosopher, &p2);
+    phil[2] = new Thread(&philosopher, &p3);
+    phil[3] = new Thread(&philosopher, &p4);
+    phil[4] = new Thread(&philosopher, &p5);
 
     cout << "Philosophers are alive and hungry!" << endl;
 
@@ -69,8 +79,13 @@ int main()
     return 0;
 }
 
-int philosopher(int n, int l, int c)
+int philosopher(void * params)
 {
+    parameters * parameters_phi = reinterpret_cast<parameters *>(params);
+    int n = parameters_phi->n;
+    int l = parameters_phi->l;
+    int c = parameters_phi->c;
+    
     int first = (n < 4)? n : 0;
     int second = (n < 4)? n + 1 : 4;
 
@@ -81,7 +96,7 @@ int philosopher(int n, int l, int c)
         cout << "thinking";
         table.unlock();
 
-        Delay thinking(1000000);
+        Alarm::delay(1000000);
 
         table.lock();
         Display::position(l, c);
@@ -96,7 +111,7 @@ int philosopher(int n, int l, int c)
         cout << " eating ";
         table.unlock();
 
-        Delay eating(500000);
+        Alarm::delay(500000);
 
         table.lock();
         Display::position(l, c);
diff --git a/app/philosophers_dinner/philosophers_dinner_traits.h b/app/philosophers_dinner/philosophers_dinner_traits.h
index 6661b46..8ec8da4 100644
--- a/app/philosophers_dinner/philosophers_dinner_traits.h
+++ b/app/philosophers_dinner/philosophers_dinner_traits.h
@@ -9,19 +9,19 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = KERNEL;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
-    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
 
     // Default flags
     static const bool enabled = true;
     static const bool monitored = false;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool hysterically_debugged = true;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
@@ -95,6 +95,8 @@ __BEGIN_SYS
 // API Components
 template<> struct Traits<Application>: public Traits<Build>
 {
+        //!P3: should not be here
+    static const unsigned int APP_HEAP = Traits<Machine>::APP_HEAP;
     static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
     static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
     static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
@@ -106,7 +108,7 @@ template<> struct Traits<System>: public Traits<Build>
     static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
     static const bool multitask = (mode != Traits<Build>::LIBRARY);
     static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
-    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
 
     static const unsigned long LIFE_SPAN = 1 * YEAR; // s
     static const unsigned int DUTY_CYCLE = 1000000; // ppm
@@ -129,7 +131,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/producer_consumer/producer_consumer.cc b/app/producer_consumer/producer_consumer.cc
index c3f7b7d..0a71926 100644
--- a/app/producer_consumer/producer_consumer.cc
+++ b/app/producer_consumer/producer_consumer.cc
@@ -21,7 +21,7 @@ int consumer()
     int out = 0;
     for(int i = 0; i < iterations; i++) {
         full.p();
-        cout << "C<-" << buffer[out] << "\t";
+        cout << "C<-" << buffer[out] << "\n";
         out = (out + 1) % BUF_SIZE;
         Alarm::delay(100000);
         empty.v();
@@ -42,7 +42,7 @@ int main()
         empty.p();
         Alarm::delay(100000);
         buffer[in] = 'a' + in;
-        cout << "P->" << buffer[in] << "\t";
+        cout << "P->" << buffer[in] << "\n";
         in = (in + 1) % BUF_SIZE;
         full.v();
     }
diff --git a/app/producer_consumer/producer_consumer_traits.h b/app/producer_consumer/producer_consumer_traits.h
index 6661b46..59305ae 100644
--- a/app/producer_consumer/producer_consumer_traits.h
+++ b/app/producer_consumer/producer_consumer_traits.h
@@ -9,7 +9,7 @@ __BEGIN_SYS
 template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
-    static const unsigned int MODE = LIBRARY;
+    static const unsigned int MODE = KERNEL;
     static const unsigned int ARCHITECTURE = RV32;
     static const unsigned int MACHINE = RISCV;
     static const unsigned int MODEL = SiFive_E;
@@ -21,7 +21,7 @@ template<> struct Traits<Build>: public Traits_Tokens
     static const bool enabled = true;
     static const bool monitored = false;
     static const bool debugged = true;
-    static const bool hysterically_debugged = false;
+    static const bool hysterically_debugged = true;
 
     // Default aspects
     typedef ALIST<> ASPECTS;
@@ -34,7 +34,7 @@ template<> struct Traits<Debug>: public Traits<Build>
     static const bool error   = true;
     static const bool warning = true;
     static const bool info    = false;
-    static const bool trace   = false;
+    static const bool trace   = true;
 };
 
 template<> struct Traits<Lists>: public Traits<Build>
@@ -95,6 +95,8 @@ __BEGIN_SYS
 // API Components
 template<> struct Traits<Application>: public Traits<Build>
 {
+    //!P3: should not be here
+    static const unsigned int APP_HEAP = Traits<Machine>::APP_HEAP;
     static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
     static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
     static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
@@ -129,7 +131,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/app/test_switch_context/makefile b/app/test_switch_context/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_switch_context/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_switch_context/test_switch_context.cc b/app/test_switch_context/test_switch_context.cc
new file mode 100644
index 0000000..4f19690
--- /dev/null
+++ b/app/test_switch_context/test_switch_context.cc
@@ -0,0 +1,49 @@
+#include <utility/ostream.h>
+#include <machine.h>
+#include <time.h>
+#include <synchronizer.h>
+#include <process.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+const int iterations = 1000*1000*10;
+
+
+int consumer()
+{
+    int out = 0;
+    for(int i = 0; i < iterations; i++) {
+        out += 1;
+    }
+
+    return 0;
+}
+
+
+int main()
+{
+    
+    cout << "Hello world!" << endl;
+    
+    Thread * cons = new Thread(&consumer);
+    cons->join();
+    cout << "Thread 0 has finished!" << endl;
+    
+    Thread * cons1 = new Thread(&consumer);
+    cons1->join();
+    cout << "Thread 1 has finished!" << endl;
+    
+    Thread * cons2 = new Thread(&consumer);
+    cons2->join();
+    cout << "Thread 2 has finished!" << endl;
+    
+    Thread * cons3 = new Thread(&consumer);
+    cons3->join();
+    cout << "Thread 3 has finished!" << endl;
+    
+    cout << "Bye!" << endl;
+    
+    return 0;
+}
diff --git a/app/test_switch_context/test_switch_context_traits.h b/app/test_switch_context/test_switch_context_traits.h
new file mode 100644
index 0000000..a1044e6
--- /dev/null
+++ b/app/test_switch_context/test_switch_context_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = KERNEL;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = true;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int APP_HEAP = Traits<Machine>::APP_HEAP;
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = 4*1024*1024;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/app/test_syscalls/makefile b/app/test_syscalls/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/app/test_syscalls/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/test_syscalls/test_syscalls.cc b/app/test_syscalls/test_syscalls.cc
new file mode 100644
index 0000000..5e2770e
--- /dev/null
+++ b/app/test_syscalls/test_syscalls.cc
@@ -0,0 +1,138 @@
+#include <utility/ostream.h>
+#include <utility/handler.h>
+
+#include <process.h>
+#include <synchronizer.h>
+#include <time.h>
+
+using namespace EPOS;
+
+OStream cout;
+
+int test_thread() {
+    Thread::exit(3145);
+    return 3145;
+}
+
+int suspended_print() {
+    cout << "At last!" << endl;
+    return '*';
+}
+
+Mutex mut;
+Semaphore sem(2);
+
+int wait_on_the_mutex() {
+    cout << "I gotta go fast!" << endl;
+    mut.lock();
+    cout << "Ugh that took a while" << endl;
+    return 0;
+}
+
+struct Params{
+  Params(int _p): p(_p) {}; 
+  int p;  
+};
+
+int wait_on_the_semaphore(void * params) {
+    Params * parameters = reinterpret_cast<Params *>(params);
+    int a = parameters->p;
+    sem.p();
+    cout << "Semaphore p, thread = " << a << endl;
+    return 0;
+}
+
+void alarm_handler() {
+    cout << "********************";
+    // cout << "The clock is ticking..." << endl;
+}
+
+int main()
+{    
+    cout << "Testing Syscalls!" << endl;
+    
+    // Test Thread
+    //!TODO: pass/yield, delete threads
+    cout << "Thread:" << endl;
+    Thread * t = new Thread(&test_thread);
+    cout << "   t: self=" << t << ", state=" << t->state() << ", priority=" << t->priority() << endl; 
+    cout << "   M: self=" << Thread::self() << ", state=" << Thread::self()->state() << ", priority=" << Thread::self()->priority() << endl;     
+    cout << "t returned with code=" << t->join() << endl;
+
+    Thread * suspended = new Thread(&suspended_print);
+    suspended->suspend();
+
+    // Test Synchronization
+    t = new Thread(&wait_on_the_mutex);
+    mut.lock();
+    Alarm::delay(3000000);
+    mut.unlock();
+    t->join();
+    
+    Params p0 = Params(0);
+    Params p1 = Params(1);
+    Params p2 = Params(2);
+    Thread * t0 = new Thread(&wait_on_the_semaphore, &p0);
+    Thread * t1 = new Thread(&wait_on_the_semaphore, &p1);
+    Thread * t2 = new Thread(&wait_on_the_semaphore, &p2);    
+    cout << "Let the race begin" << endl;
+    Alarm::delay(3000000);
+    sem.v();
+    t0->join();
+    t1->join();
+    t2->join();
+
+    // Test Alarm
+    cout << "Time:" << endl;
+    cout << "   frequency=" << Alarm::alarm_frequency() << endl;
+    // !P4: Fix the vtable bug
+    // Function_Handler handler(&alarm_handler);
+    // Alarm(400000, &handler, 5);
+    // Alarm::delay(5000000);
+    // delete a;
+
+    // Test Chronometer
+    cout << "Chronometer:" << endl;
+    Chronometer * chrono = new Chronometer();
+    
+    unsigned long f = chrono->frequency(); //Hertz
+    cout << "frequency = " << f << endl; 
+    
+    chrono->start();
+    unsigned long read = chrono->read();
+    cout << "read = " << read << endl;
+    Alarm::delay(1000000);
+    chrono->stop();
+    unsigned long long ts = chrono->ticks(); //Time Stamp
+    cout << "time_stamp = " << ts << endl; //time_stamp is multiplied by ~12
+    
+    chrono->reset();
+    chrono->start();
+    Alarm::delay(500000);
+    chrono->lap();
+    ts = chrono->ticks(); //Time Stamp
+    cout << "time_stamp = " << ts << endl; //time_stamp is multiplied by ~12
+    
+    delete chrono;
+    
+    // Test Display
+    cout << "Display:" << endl;
+    Display::putc('#');
+    Display::puts("Display::puts($%)\n");
+    Alarm::delay(3000000);
+    Display::clear();
+    cout << "Clear\n\n\n" << endl; 
+    int l, c;
+    Display::geometry(&l, &c);
+    cout << "Display::geometry: l=" << l << "  c=" << c << endl;
+    Display::position(20, 50); 
+    Display::putc('#');
+    Display::position(&l, &c);
+    cout << "Display::position: l=" << l << "  c=" << c << endl;
+    Alarm::delay(1000000);
+    
+    // We now wake suspended
+    suspended->resume();
+
+    return 0;
+}
diff --git a/app/test_syscalls/test_syscalls_traits.h b/app/test_syscalls/test_syscalls_traits.h
new file mode 100644
index 0000000..2eb27f5
--- /dev/null
+++ b/app/test_syscalls/test_syscalls_traits.h
@@ -0,0 +1,155 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = KERNEL;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 6000; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = true;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int APP_HEAP = Traits<Machine>::APP_HEAP;
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = 4*1024*1024;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled || true;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/etc/makefile b/etc/makefile
index 1e29432..45d0fcd 100644
--- a/etc/makefile
+++ b/etc/makefile
@@ -31,7 +31,7 @@ eposcc.conf: FORCE
 		@echo "APP_DATA=$(shell $(BIN)/eposcfg APP_DATA)" >> $@
 		@echo "SETUP=$(shell $(BIN)/eposcfg SETUP)" >> $@
 		@echo "BOOT_STACK=$(shell $(BIN)/eposcfg BOOT_STACK)" >> $@
-		@echo "MACH_CC_FLAGS='$(MACH_CC_FLAGS)'" >> $@
+		@echo "MACH_CC_FLAGS='$(MACH_CXX_FLAGS)'" >> $@
 		@echo "MACH_LD_FLAGS='$(MACH_LD_FLAGS)'" >> $@
 		@echo "MACH_CODE_NAME='$(MACH_CODE_NAME)'" >> $@
 		@echo "MACH_DATA_NAME='$(MACH_DATA_NAME)'" >> $@
@@ -47,6 +47,8 @@ eposmkbi.conf:	FORCE
 		@echo "ENDIANESS=$(shell $(BIN)/eposcfg ENDIANESS)" >> $@
 		@echo "MEM_BASE=$(shell $(BIN)/eposcfg MEM_BASE)" >> $@
 		@echo "MEM_TOP=$(shell $(BIN)/eposcfg MEM_TOP)" >> $@
+		@echo "MIO_BASE=$(shell $(BIN)/eposcfg MIO_BASE)" >> $@
+		@echo "MIO_TOP=$(shell $(BIN)/eposcfg MIO_TOP)" >> $@
 		@echo "BOOT_LENGTH_MIN=$(shell $(BIN)/eposcfg BOOT_LENGTH_MIN)" >> $@
 		@echo "BOOT_LENGTH_MAX=$(shell $(BIN)/eposcfg BOOT_LENGTH_MAX)" >> $@
 		@echo "NODE_ID=$(NODE_ID)" >> $@
diff --git a/img/makefile b/img/makefile
index f048773..e630418 100644
--- a/img/makefile
+++ b/img/makefile
@@ -20,14 +20,14 @@ endif
 
 DEBUGGER	:= $(MACH_DEBUGGER)
 ifeq ($(DEBUG),1)
-ifneq ($(wildcard $(IMG)/$(MACH)_setup),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/$(MACH)_setup,.text)"
+ifneq ($(wildcard $(IMG)/setup_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/setup/setup_$(MMOD),.text)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_init),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/$(MACH)_init,.text)"
+ifneq ($(wildcard $(IMG)/init_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/init/init_$(MMOD),.text)"
 endif
-ifneq ($(wildcard $(IMG)/$(MACH)_system),)
-DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/$(MACH)_system,.text)"
+ifneq ($(wildcard $(IMG)/system_$(MMOD)),)
+DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(SRC)/system/system_$(MMOD),.text)"
 endif
 DEBUGGER	:= $(DEBUGGER) -ex "add-symbol-file $(call DBSEC,$(APP)/$(APPLICATION)/$(APPLICATION),.text)"
 PEER_DEBUGGER	:= $(subst 1235,1236,$(DEBUGGER))
@@ -45,7 +45,7 @@ all:		strip $(IMAGE)
 
 else
 
-all:		strip $(IMAGE) $(PEER_IMAGE)
+all:	 	$(IMAGE) $(PEER_IMAGE)
 
 $(IMAGE):	$(APPLICATION)
 		$(MKBI) -x 0 -y 0 -z 0 $@ $<
@@ -83,7 +83,7 @@ endif
 
 debug:		$(IMAGE)
 ifeq ($(NODES),1)
-		$(EMULATOR)$(IMAGE) | $(TEE) $(OUTPUT) &
+		$(EMULATOR)$(IMAGE) &
 		$(DEBUGGER)
 else
 		$(TERM) "$(EMULATOR)$(IMAGE) $(NETWORK) | $(TEE) $(OUTPUT) \
@@ -104,7 +104,7 @@ strip:		$(SYSTEM) $(APPLICATION)
 		@for file in $^; do $(STRIP) "$${file}"; done;
 
 clean:		FORCE
-		$(CLEAN) $(SYSTEM) $(APPLICATION) $(IMAGE)
+		$(CLEAN) $(SYSTEM) $(APPLICATION) $(IMAGE) setup_sifive_e
 ifneq ($(NODES),1)
 		$(CLEAN) $(PEER_IMAGE)
 endif
@@ -116,5 +116,5 @@ prerun_$(APPLICATION):
 		@echo "Running $(APPLICATION) ..."
 posrun_$(APPLICATION):
 		@echo "done!"
-		
+
 FORCE:
diff --git a/include/architecture/mmu.h b/include/architecture/mmu.h
index 5735fcf..664451f 100644
--- a/include/architecture/mmu.h
+++ b/include/architecture/mmu.h
@@ -37,15 +37,20 @@ public:
     {
     public:
         enum {
-            PRE = 0x001, // Presence (0=not-present, 1=present)
-            RW  = 0x002, // Write (0=read-only, 1=read-write)
-            USR = 0x004, // Access Control (0=supervisor, 1=user)
-            CWT = 0x008, // Cache Mode (0=write-back, 1=write-through)
-            CD  = 0x010, // Cache Disable (0=cacheable, 1=non-cacheable)
-            CT  = 0x020, // Contiguous (0=non-contiguous, 1=contiguous)
-            IO  = 0x040, // Memory Mapped I/O (0=memory, 1=I/O)
-            SYS = (PRE | RW ),
-            APP = (PRE | RW | USR)
+            PRE  = 0x001, // Presence (0=not-present, 1=present)
+            RW   = 0x002, // Write (0=read-only, 1=read-write)
+            USR  = 0x004, // Access Control (0=supervisor, 1=user)
+            CWT  = 0x008, // Cache Mode (0=write-back, 1=write-through)
+            CD   = 0x010, // Cache Disable (0=cacheable, 1=non-cacheable)
+            CT   = 0x020, // Contiguous (0=non-contiguous, 1=contiguous)
+            IO   = 0x040, // Memory Mapped I/O (0=memory, 1=I/O)
+            SYS = (PRE | RW),
+            APP = (PRE | RW | USR),
+            EXEC  = 0x080,
+            KCODE = (PRE | EXEC),
+            KDATA = (PRE | RW),
+            ALL = (PRE | RW | EXEC | USR),
+            UDATA = (PRE | RW | USR),
         };
 
     public:
@@ -67,8 +72,8 @@ public:
 
 public:
     static unsigned int pages(unsigned int bytes) { return (bytes + sizeof(Page) - 1) / sizeof(Page); }
-    static unsigned int page_tables(unsigned int pages) { return (pages + PT_ENTRIES - 1) / PT_ENTRIES; }
-
+    static unsigned int page_tables(unsigned int pages) { return sizeof(Page) > sizeof(int) ? (pages + PT_ENTRIES - 1) / PT_ENTRIES : 0; } // merged
+    
     static unsigned int offset(const Log_Addr & addr) { return addr & (sizeof(Page) - 1); }
     static unsigned int indexes(const Log_Addr & addr) { return addr & ~(sizeof(Page) - 1); }
 
@@ -76,7 +81,7 @@ public:
     static unsigned int directory(const Log_Addr & addr) { return addr >> DIRECTORY_SHIFT; }
 
     static Log_Addr align_page(const Log_Addr & addr) { return (addr + sizeof(Page) - 1) & ~(sizeof(Page) - 1); }
-    static Log_Addr align_directory(const Log_Addr & addr) { return (addr + sizeof(Page) * sizeof(Page) - 1) &  ~(sizeof(Page) * sizeof(Page) - 1); }
+    static Log_Addr align_directory(const Log_Addr & addr) { return (addr + PT_ENTRIES * sizeof(Page) - 1) &  ~(PT_ENTRIES * sizeof(Page) - 1); } // merged
 };
 
 __END_SYS
diff --git a/include/architecture/rv32/rv32_cpu.h b/include/architecture/rv32/rv32_cpu.h
index 55a077e..27a7416 100644
--- a/include/architecture/rv32/rv32_cpu.h
+++ b/include/architecture/rv32/rv32_cpu.h
@@ -27,24 +27,27 @@ public:
 
     // Control and Status Register (CSR) for machine mode
     // Status Register (mstatus)
+    typedef Reg32 Flags;
     enum {
         MIE             = 1 << 3,      // Machine Interrupts Enabled
         SIE             = 1 << 1,      // Supervisor Interrupts Enabled
         SPIE            = 1 << 5,      // Supervisor Previous Interrupts Enabled
         MPIE            = 1 << 7,      // Machine Previous Interrupts Enabled
-        MPP             = 3 << 11,     // Machine Previous Privilege
-        SPP             = 3 << 12,     // Supervisor Previous Privilege
+        MPP             = 3 << 11,     // Machine Previous Privilege=Machine
+        MPP_S           = 1 << 11,     // Machine Previous Privilege=Supervisor
+        SPP_S           = 1 << 8,      // Supervisor Previous Privilege=Supervisor
+        SPP_U           = 0 << 8,      // Supervisor Previous Privilege=User
         MPRV            = 1 << 17,     // Memory Priviledge
-        TVM             = 1 << 20,     // Trap Virtual Memory //not allow MMU
-        MSTATUS_DEFAULTS= (MIE | MPIE | MPP)
+        SUM             = 1 << 18,     // System can access user pages?
+        TVM             = 1 << 20      // Trap Virtual Memory //not allow MMU
     };
 
     // Interrupt-Enable, Interrupt-Pending and Machine Cause Registers (mie, mip, and mcause when interrupt bit is set)
     enum {
         SSI             = 1 << 1,   // Supervisor Software Interrupt
         MSI             = 1 << 3,   // Machine Software Interrupt
-        STI             = 1 << 5,   // Supervisor Software Interrupt
-        MTI             = 1 << 7,   // Machine Software Interrupt
+        STI             = 1 << 5,   // Supervisor Timer Interrupt
+        MTI             = 1 << 7,   // Machine Timer Interrupt
         SEI             = 1 << 9,   // Supervisor External Interrupt
         MEI             = 1 << 11   // Machine External Interrupt
     };
@@ -62,15 +65,16 @@ public:
         EXC_DWFAULT     = 7,    // Store/AMO access fault
         EXC_ENVU        = 8,    // Environment call from U-mode
         EXC_ENVS        = 9,    // Environment call from S-mode
-        EXC_ENVH        = 10,   // Environment call from H-mode
-        EXC_ENVM        = 11    // Environment call from M-m
+        // EXC_ENVH        = 10,   // Environment call from H-mode
+        EXC_ENVM        = 11    // Environment call from M-mode
     };
 
     // Context
     class Context
     {
     public:
-        Context(const Log_Addr & entry, const Log_Addr & exit): _pc(entry), _x1(exit) {
+        // Contexts are loaded with sret, which gets pc from sepc and updates some bits of sstatus, that's why _st is initialized with SPIE and SPP
+        Context(const Log_Addr & entry, const Log_Addr & exit): _st(SPIE | SPP_U | SUM), _pc(entry), _x1(exit) {
             if(Traits<Build>::hysterically_debugged || Traits<Thread>::trace_idle) {
                                                                         _x5 =  5;  _x6 =  6;  _x7 =  7;  _x8 =  8;  _x9 =  9;
                 _x10 = 10; _x11 = 11; _x12 = 12; _x13 = 13; _x14 = 14; _x15 = 15; _x16 = 16; _x17 = 17; _x18 = 18; _x19 = 19;
@@ -84,8 +88,9 @@ public:
 
         friend Debug & operator<<(Debug & db, const Context & c) {
             db << hex
-               << "{pc="   << c._pc
-               << ",sp="   << &c
+               << "{sp="   << &c
+               << ",st="   << c._st
+			   << ",pc="   << c._pc
                << ",lr="   << c._x1
                << ",x5="   << c._x5
                << ",x6="   << c._x6
@@ -119,6 +124,7 @@ public:
         }
 
     public:
+        Reg32  _st; // mstatus
         Reg32  _pc; // pc
     //  Reg32  _x0; // zero
         Reg32  _x1; // ra, ABI Link Register
@@ -164,24 +170,31 @@ public:
     CPU() {};
 
 public:
-    // Register access
+    static Reg32 flags() { return mstatus(); }
+    static void flags(const Flags st) { mstatus(st); }
+    
+    static Reg32 tp() {
+        Reg32 value;
+        ASM("mv %0, tp" : "=r"(value) :);
+        return value;
+    }
+
+    static void tp(const Reg32 & tp) { ASM("mv tp, %0" : : "r"(tp) :); }
+
     static Reg32 sp() {
         Reg32 value;
         ASM("mv %0, sp" : "=r"(value) :);
         return value;
     }
-    static void sp(const Reg32 & sp) {
-        ASM("mv sp, %0" : : "r"(sp) :);
-    }
+
+    static void sp(const Reg32 & sp) { ASM("mv sp, %0" : : "r"(sp) :); }
 
     static Reg32 fr() {
         Reg32 value;
         ASM("mv %0, x10" : "=r"(value)); // x10 is a0
         return value;
     }
-    static void fr(const Reg32 & fr) {
-        ASM("mv x10, %0" : : "r"(fr) :); // x10 is a0
-    }
+    static void fr(const Reg32 & fr) { ASM("mv x10, %0" : : "r"(fr) :); } // x10 is a0
 
     static Log_Addr ip() {
         Reg32 value;
@@ -241,15 +254,22 @@ public:
 
     static void halt() { ASM("wfi"); }
 
-    static unsigned int id() {
+    static unsigned int id() { return tp(); }
+
+    static unsigned int mhartid() {
         int id;
         ASM("csrr %0, mhartid" : "=r"(id) : : "memory", "cc");
         return id & 0x3;
     }
 
-    static void mstatus(Reg value) {
-        ASM("csrs mstatus, %0" : : "r"(value) : "cc");
-    }
+    //================ status
+
+    static void mstatus(Reg value) {       ASM("csrs mstatus, %0" : : "r"(value) : "cc"); }
+    static void mstatus_write(Reg value) { ASM("csrw mstatus, %0" : : "r"(value) : "cc"); }
+    static void mstatus_clear(Reg value) { ASM("csrc mstatus, %0" : : "r"(value) : "cc"); }
+
+    static void sstatus(Reg value) {       ASM("csrs sstatus, %0" : : "r"(value) : "cc"); }
+    static void sstatus_write(Reg value) { ASM("csrw sstatus, %0" : : "r"(value) : "cc"); }
 
     static Reg mstatus() {
         Reg value;
@@ -257,37 +277,99 @@ public:
         return value;
     }
 
-    static void mie(Reg value) {
-        ASM("csrs mie, %0" : : "r"(value) : "cc");
+    static Reg sstatus() {
+        Reg value;
+        ASM("csrr %0, sstatus" : "=r"(value) : : );
+        return value;
     }
 
-    static void mie_clear(Reg value) {
-        ASM("csrc mie, %0" : : "r"(value) : "cc");
+    static Reg rdtime() {
+        Reg value;
+        ASM("rdtime %0" : "=r"(value) : : );
+        return value;
     }
 
+    //================ exceptions
+
+    static void mepc(Reg value) { ASM("csrw mepc, %0" : : "r"(value) : "cc"); }
+
+    static void mtvec(Reg value) { ASM("csrw mtvec, %0" : : "r"(value) : "cc"); }
+
+    static void mie(Reg value) {       ASM("csrs mie, %0" : : "r"(value) : "cc"); }
+    static void mie_clear(Reg value) { ASM("csrc mie, %0" : : "r"(value) : "cc"); }
+    static void mie_write(Reg value) { ASM("csrw mie, %0" : : "r"(value) : "cc"); }
+
     static Reg mie() {
         Reg value;
         ASM("csrr %0, mie" : "=r"(value) : : );
         return value;
     }
 
+    static void mip(Reg value) {       ASM("csrs mip, %0" : : "r"(value) : "cc"); }
+    static void mip_write(Reg value) { ASM("csrw mip, %0" : : "r"(value) : "cc"); }
+    static void mip_clear(Reg value) { ASM("csrc mip, %0" : : "r"(value) : "cc"); }
+
     static Reg mcause() {
         Reg value;
         ASM("csrr %0, mcause" : "=r"(value) : : );
         return value;
     }
 
+    static Reg scause() {
+        Reg value;
+        ASM("csrr %0, scause" : "=r"(value) : : );
+        return value;
+    }
+    
+    static Reg satp() {
+        Reg value;
+        ASM("csrr %0, satp" : "=r"(value) : : );
+        return value;
+    }
+    
+    //================ supervisor mode
+    
+    static void satp(Reg value) {       ASM("csrw satp, %0" : : "r"(value) : "cc"); }
+    
+    static void mideleg_write(Reg value) { ASM("csrw mideleg, %0" : : "r"(value) : "cc"); }
+    static void medeleg_write(Reg value) { ASM("csrw medeleg, %0" : : "r"(value) : "cc"); }
+
+    static void sie(Reg value) {       ASM("csrs sie, %0" : : "r"(value) : "cc"); }
+    static void sie_write(Reg value) { ASM("csrw sie, %0" : : "r"(value) : "cc"); }
+    static void sie_clear(Reg value) { ASM("csrc sie, %0" : : "r"(value) : "cc"); }
+
+    static Reg sie() {
+        Reg value;
+        ASM("csrr %0, sie" : "=r"(value) : : );
+        return value;
+    }
+
+    static void sip(Reg value) {       ASM("csrs sip, %0" : : "r"(value) : "cc"); }
+    static void sip_clear(Reg value) { ASM("csrc sip, %0" : : "r"(value) : "cc"); }
+
+    static void stvec_write(Reg value) { ASM("csrw stvec, %0" : : "r"(value) : "cc"); }
+
+    static void sepc_write(Reg value) { ASM("csrw sepc, %0" : : "r"(value) : "cc"); }
+
+    static Reg sepc() {
+        Reg value;
+        ASM("csrr %0, sepc" : "=r"(value) : : );
+        return value;
+    }
+
     static unsigned int cores() {
         return Traits<Build>::CPUS;
     }
 
     static void smp_barrier(unsigned long cores = cores()) { CPU_Common::smp_barrier<&finc>(cores, id()); }
 
-    static void int_enable() { ASM("csrs mstatus, %0" : :"r"(MSTATUS_DEFAULTS)); }
-    static void int_disable() { ASM("csrc mstatus, %0" : :"r"(MIE)); }
-    static bool int_enabled() { return (mstatus() & MIE) ; }
+    static void mmode_int_disable() { ASM("csrc mstatus, %0" : :"r"(MIE)); }
+    static void int_enable() {        ASM("csrs sstatus, %0" : :"r"(SIE)); }
+    static void int_disable() {       ASM("csrc sstatus, %0" : :"r"(SIE)); }
+    static bool int_enabled() { return (sstatus() & SIE) ; }
     static bool int_disabled() { return !int_enabled(); }
-
+    
+    //!SMODE: Where is this being used?
     static void csrr31() { ASM("csrr x31, mstatus" : : : "x31"); }
     static void csrw31() { ASM("csrs mstatus, x31" : : : "cc"); }
 
@@ -295,7 +377,7 @@ public:
 
     static void fpu_save();
     static void fpu_restore();
-    static void switch_context(Context ** o, Context * n) __attribute__ ((naked));
+    static void switch_context(Context ** o, Context * n, unsigned int change_satp, unsigned int new_satp) __attribute__ ((naked));
 
     template<typename ... Tn>
     static Context * init_stack(const Log_Addr & usp, Log_Addr sp, void (* exit)(), int (* entry)(Tn ...), Tn ... an) {
@@ -312,7 +394,7 @@ public:
         return sp;
     }
 
-    static int syscall(void * message);
+    static void syscall(void * message);
     static void syscalled();
 
     using CPU_Common::htole64;
@@ -370,4 +452,4 @@ inline CPU::Reg16 ntohs(CPU::Reg16 v) { return CPU::ntohs(v); }
 
 __END_SYS
 
-#endif
+#endif
\ No newline at end of file
diff --git a/include/architecture/rv32/rv32_mmu.h b/include/architecture/rv32/rv32_mmu.h
index 1c809b2..8cbb59c 100644
--- a/include/architecture/rv32/rv32_mmu.h
+++ b/include/architecture/rv32/rv32_mmu.h
@@ -12,43 +12,148 @@
 
 __BEGIN_SYS
 
-class MMU: public MMU_Common<0, 0, 0>
+class MMU: public MMU_Common<10, 10, 12>
 {
     friend class CPU;
-
+    friend class Setup_SifiveE;
 private:
-    typedef Grouping_List<unsigned int> List;
-
+    typedef Grouping_List<Frame> List;
     static const unsigned int PHY_MEM = Memory_Map::PHY_MEM;
 
 public:
     // Page Flags
-    typedef MMU_Common<0, 0, 0>::Flags RV32_Flags;
+    class RV32_Flags
+    {
+    public:
+        enum {
+            VALID    = 1 << 0,
+            READ     = 1 << 1,
+            WRITE    = 1 << 2,
+            EXEC     = 1 << 3,
+            USR      = 1 << 4,
+            ACCESSED = 1 << 6,
+            DIRTY    = 1 << 7,
+            SYS      = VALID | READ | WRITE | EXEC,
+            KCODE    = VALID | READ | EXEC,
+            KDATA    = VALID | READ | WRITE,
+            UCODE    = VALID | READ | EXEC | USR,
+            UDATA    = VALID | READ | WRITE | USR,
+            UALL    = VALID | READ | WRITE | EXEC | USR,
+        };
+
+        RV32_Flags() {}
+        RV32_Flags(const RV32_Flags & f): _flags(f) {}
+        RV32_Flags(unsigned int f): _flags(f) {}
+        RV32_Flags(const Flags & f): _flags(((f & Flags::PRE)  ? VALID : 0) | 
+                                            ((f & Flags::RW)   ? (READ | WRITE) : READ) |
+                                            ((f & Flags::USR)  ? USR : 0) | 
+                                            ((f & Flags::EXEC) ? EXEC : 0)) {}
+        operator unsigned int() const { return _flags; }
+
+    private:
+        unsigned int _flags;
+
+    };
 
     // Page_Table
-    class Page_Table {};
+    class Page_Table
+    {
+
+    friend class Setup_SifiveE;
+
+    private:
+
+    public:
+        typedef unsigned int PTE;
+        PTE ptes[1024];
+        Page_Table() {}
+
+        PTE & operator[](unsigned int i) { return ptes[i]; }
+
+        void map(const RV32_Flags & flags, int from, int to) {
+            Phy_Addr * addr = alloc(to - from);
+            // Try to alloc contiguous
+            if (addr) {
+                remap(addr, flags, from , to);
+            } else {
+                for(; from < to; from++){
+                    ptes[from] = ((alloc(1) >> 12) << 10) | flags ;
+                }
+            }
+        }
+
+        void remap(Phy_Addr phy_addr, const RV32_Flags & flags, int from = 0, int to = 1024) {
+            for(int i = from; i < to; i++) {
+                unsigned int pte = phy_addr >> 12;
+                pte = pte << 10;
+                pte += ((i) << 10);
+                pte = pte | flags;
+                ptes[i] = pte;
+            }
+        }
+        
+        void print_pt(){
+            for(int i=512;i<1024;i++){
+                unsigned int ppn = ptes[i] >> 10;
+                unsigned int rsw = (ptes[i] << 22) >> 30;
+                unsigned int d = (ptes[i] << 24) >> 31;
+                unsigned int a = (ptes[i] << 25) >> 31;
+                unsigned int g = (ptes[i] << 26) >> 31;
+                unsigned int u = (ptes[i] << 27) >> 31;
+                unsigned int x = (ptes[i] << 28) >> 31;
+                unsigned int w = (ptes[i] << 29) >> 31;
+                unsigned int r = (ptes[i] << 30) >> 31;
+                unsigned int v = (ptes[i] << 31) >> 31;
+                db<MMU>(TRC) << "i = " << i << hex << "ppn = " << ppn <<" rsw =" << rsw;
+                db<MMU>(TRC) << " d=" << d << " a=" << a;
+                db<MMU>(TRC) << " g=" << g << " u=" << u;
+                db<MMU>(TRC) << " x=" << x << " w=" << w;
+                db<MMU>(TRC) << " r=" << r << " v=" << v << endl;
+            }
+        }
+    };
 
     // Chunk (for Segment)
     class Chunk
     {
     public:
         Chunk() {}
-        Chunk(unsigned int bytes, Flags flags): _phy_addr(alloc(bytes)), _bytes(bytes), _flags(flags) {}
-        Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags): _phy_addr(phy_addr), _bytes(bytes), _flags(flags) {}
+        // Chunk(unsigned int bytes, Flags flags): _phy_addr(alloc(bytes)), _bytes(bytes), _flags(flags) {}
+        // Chunk(Phy_Addr phy_addr, unsigned int bytes, Flags flags): _phy_addr(phy_addr), _bytes(bytes), _flags(flags) {}
+
+        Chunk(unsigned int bytes, const Flags & flags)
+        : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _bytes(bytes), _flags(RV32_Flags(flags)), _pt(calloc(_pts)) {
+            _pt->map(_flags, _from, _to);
+        }
+
+        // Chunk(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags)
+        // : _from(0), _to(pages(bytes)), _pts(page_tables(_to - _from)), _flags(RV32_Flags(flags)), _pt(calloc(_pts)) {
+        //     _pt->remap(phy_addr, flags);
+        // }
 
-        ~Chunk() { free(_phy_addr, _bytes); }
+        // ~Chunk() { free(_phy_addr, _bytes); }
+        ~Chunk() {
+            for( ; _from < _to; _from++)
+                free((*static_cast<Page_Table *>(phy2log(_pt)))[_from]);
+            free(_pt, _pts);
+        }
 
-        unsigned int pts() const { return 0; }
-        Flags flags() const { return _flags; }
-        Page_Table * pt() const { return 0; }
+        unsigned int pts() const { return _pts; }
+        // Flags flags() const { return Flags(_flags); }
+        Page_Table * pt() const { return _pt; }
         unsigned int size() const { return _bytes; }
-        Phy_Addr phy_address() const { return _phy_addr; } // always CT
+        // Phy_Addr phy_address() const { return _phy_addr; } // always CT
         int resize(unsigned int amount) { return 0; } // no resize in CT
 
     private:
-        Phy_Addr _phy_addr;
+        unsigned int _from;
+        unsigned int _to;
+        unsigned int _pts;
+        // Phy_Addr _phy_addr;
         unsigned int _bytes;
         RV32_Flags _flags;
+        Page_Table * _pt;
+
     };
 
     // Page Directory
@@ -58,74 +163,83 @@ public:
     class Directory
     {
     public:
-        Directory() {}
-        Directory(Page_Directory * pd) {}
+        Directory() : _pd(calloc(1)) {
+            for(unsigned int i = 0; i < 544; i++){
+                (*_pd)[i] = (*_master)[i];
+            }
+        }
+        Directory(Page_Directory * pd) : _pd(pd) {}
 
-        Page_Table * pd() const { return 0; }
+        Phy_Addr pd() const { return _pd; }
 
-        void activate() {}
+        void activate() {
+            CPU::satp((0x1 << 31) | (Phy_Addr)_pd >> 12);
+            ASM("sfence.vma");
+        }
+
+        Log_Addr attach(const Chunk & chunk, unsigned int from = 0) {
+            for(unsigned int i = from; i < PD_ENTRIES - chunk.pts(); i++)
+                if(attach(i, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                    return i << DIRECTORY_SHIFT;
+            return false;
+        }
+
+        // Used to create non-relocatable segments such as code
+        Log_Addr attach(const Chunk & chunk, const Log_Addr & addr) {
+            unsigned int from = directory(addr);
+            if(!attach(from, chunk.pt(), chunk.pts(), RV32_Flags::VALID))
+                return Log_Addr(false);
+            return from << DIRECTORY_SHIFT;
+        }
 
-        Log_Addr attach(const Chunk & chunk) { return chunk.phy_address(); }
-        Log_Addr attach(const Chunk & chunk, Log_Addr addr) { return (addr == chunk.phy_address())? addr : Log_Addr(false); }
         void detach(const Chunk & chunk) {}
         void detach(const Chunk & chunk, Log_Addr addr) {}
 
         Phy_Addr physical(Log_Addr addr) { return addr; }
-    };
 
-    // DMA_Buffer (straightforward without paging)
-    class DMA_Buffer: public Chunk
-    {
-    public:
-        DMA_Buffer(unsigned int s): Chunk(s, Flags::CT) {
-            db<MMU>(TRC) << "MMU::DMA_Buffer() => " << *this << endl;
+    private:
+        bool attach(unsigned int from, const Page_Table * pt, unsigned int n, RV32_Flags flags) {
+            for(unsigned int i = from; i < from + n; i++)
+                if((*static_cast<Page_Directory *>(phy2log(_pd)))[i]) // it has already been used
+                    return false;
+            for(unsigned int i = from; i < from + n; i++, pt++)
+                (*static_cast<Page_Directory *>(phy2log(_pd)))[i] = ((Phy_Addr(pt) >> 12) << 10) | flags; // is pt the correct value?
+            return true;
         }
 
-        Log_Addr log_address() const { return phy_address(); }
-
-        friend Debug & operator<<(Debug & db, const DMA_Buffer & b) {
-            db << "{phy=" << b.phy_address()
-               << ",log=" << b.log_address()
-               << ",size=" << b.size()
-               << ",flags=" << b.flags() << "}";
-            return db;
-        }
+    private:
+        Page_Directory * _pd;
     };
 
 public:
     MMU() {}
 
-    static Phy_Addr alloc(unsigned int bytes = 1) {
+    static Phy_Addr alloc(unsigned int frames = 1) {
         Phy_Addr phy(false);
-        if(bytes) {
-            List::Element * e = _free.search_decrementing(bytes);
+        if(frames) {
+            List::Element * e = _free.search_decrementing(frames);
             if(e)
-                phy = reinterpret_cast<unsigned int>(e->object()) + e->size();
+                phy = reinterpret_cast<unsigned int>(e->object()) + e->size() * PAGE_SIZE;
             else
                 db<MMU>(ERR) << "MMU::alloc() failed!" << endl;
         }
-        db<MMU>(TRC) << "MMU::alloc(bytes=" << bytes << ") => " << phy << endl;
+        db<MMU>(TRC) << "MMU::alloc(frames=" << frames << ") => " << phy << endl;
 
         return phy;
     };
 
-    static Phy_Addr calloc(unsigned int bytes = 1) {
-        Phy_Addr phy = alloc(bytes);
-        memset(phy, 0, bytes);
+    static Phy_Addr calloc(unsigned int frames = 1) {
+        Phy_Addr phy = alloc(frames);
+        memset(phy2log(phy), 0, frames*PAGE_SIZE);
+        db<MMU>(TRC) << "-----------CALLOC:  " << hex << phy << endl;
         return phy;
     }
 
-    static void free(Phy_Addr addr, unsigned int n = 1) {
-        db<MMU>(TRC) << "MMU::free(addr=" << addr << ",n=" << n << ")" << endl;
-
-        // No unaligned addresses if the CPU doesn't support it
-        assert(Traits<CPU>::unaligned_memory_access || !(addr % 4));
+    static void free(Phy_Addr frame, unsigned int n = 1) {
+        db<MMU>(TRC) << "MMU::free(frame=" << frame << ",n=" << n << ")" << endl;
 
-        // Free blocks must be large enough to contain a list element
-        assert(n > sizeof (List::Element));
-
-        if(addr && n) {
-            List::Element * e = new (addr) List::Element(addr, n);
+        if(frame && n) {
+            List::Element * e = new (frame) List::Element(frame, n);
             List::Element * m1, * m2;
             _free.insert_merging(e, &m1, &m2);
         }
@@ -133,7 +247,7 @@ public:
 
     static unsigned int allocable() { return _free.head() ? _free.head()->size() : 0; }
 
-    static Page_Directory * volatile current() { return 0; }
+    static Page_Directory * volatile current() { return _master; }
 
     static Phy_Addr physical(Log_Addr addr) { return addr; }
 
@@ -143,8 +257,11 @@ public:
 private:
     static void init();
 
+    static Log_Addr phy2log(const Phy_Addr & phy) { return phy ; }
+
 private:
     static List _free;
+    static Page_Directory * _master;
 };
 
 __END_SYS
diff --git a/include/aspect/authenticated.h b/include/aspect/authenticated.h
new file mode 100644
index 0000000..104422e
--- /dev/null
+++ b/include/aspect/authenticated.h
@@ -0,0 +1,26 @@
+// EPOS Component Authentication Aspect Program
+
+#ifndef __authenticated_h
+#define __authenticated_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+template<typename Component>
+class Authenticated
+{
+protected:
+    Authenticated() {}
+
+public:
+    void enter() { db<Aspect>(TRC) << "Authenticated::enter()" << endl; }
+    void leave() { db<Aspect>(TRC) << "Authenticated::leave()" << endl; }
+
+    static void static_enter() { db<Aspect>(TRC) << "Authenticated::static_enter()" << endl; }
+    static void static_leave() { db<Aspect>(TRC) << "Authenticated::static_leave()" << endl; }
+};
+
+__END_SYS
+
+#endif
diff --git a/include/aspect/energy_aware.h b/include/aspect/energy_aware.h
new file mode 100644
index 0000000..41eac51
--- /dev/null
+++ b/include/aspect/energy_aware.h
@@ -0,0 +1,74 @@
+// EPOS Energy-aware Component Management Aspect Program
+
+#ifndef __energy_aware_h
+#define __energy_aware_h
+
+#include <framework/id.h>
+#include <utility/hash.h>
+
+__BEGIN_SYS
+
+class Energized
+{
+public:
+    static const unsigned int TYPES = LAST_MEDIATOR_ID - FIRST_MEDIATOR_ID;
+
+    typedef Hash<Energized, TYPES, Type_Id> _Hash;
+    typedef _Hash::Element Element;
+
+public:
+    Energized(const Type_Id & id): _id(id), _mode(OFF), _link(this, id) {
+        db<Aspect>(WRN) << "Energized()" << endl;
+        _devices.insert(&_link);
+    }
+    ~Energized() {
+        db<Aspect>(WRN) << "~Energized()" << endl;
+        _devices.remove(&_link);
+    }
+
+    const Power_Mode & mode() { return _mode; }
+    Power_Mode mode(const Power_Mode & mode) {
+        db<Aspect>(WRN) << "Energized::mode()" << endl;
+        Power_Mode old = _mode;
+        switch(mode) {
+        case ENROLL:
+            //            _threaads.insert(Thread::self());
+            break;
+        case DISMISS:
+            //            _threaads.remove(Thread::self());
+            break;
+        default: // Contest current mode
+            _mode = mode;
+        }
+        return _mode == old ? SAME : _mode;
+    }
+
+private:
+    Type_Id _id;
+    Power_Mode _mode;
+//    List<void *> _threads;
+    Element _link;
+
+    static _Hash _devices;
+};
+
+template<typename Component>
+class Energy_Aware
+{
+protected:
+    Energy_Aware() {}
+
+public:
+    static const Power_Mode & power() { return _energized.mode(); }
+    static Power_Mode power(const Power_Mode & mode) { return _energized.mode(mode); }
+
+private:
+    static Energized _energized;
+};
+
+template<typename Component>
+Energized Energy_Aware<Component>::_energized(Type<Component>::ID);
+
+__END_SYS
+
+#endif
diff --git a/include/aspect/shared.h b/include/aspect/shared.h
new file mode 100644
index 0000000..22ca6ed
--- /dev/null
+++ b/include/aspect/shared.h
@@ -0,0 +1,26 @@
+// EPOS Component Sharing Control Aspect Program
+
+#ifndef __shared_h
+#define __shared_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+template<typename Component>
+class Shared
+{
+protected:
+    Shared() {}
+
+public:
+    void enter() { db<Aspect>(TRC) << "Shared::enter()" << endl; }
+    void leave() { db<Aspect>(TRC) << "Shared::leave()" << endl; }
+
+    static void static_enter() { db<Aspect>(TRC) << "Shared::static_enter()" << endl; }
+    static void static_leave() { db<Aspect>(TRC) << "Shared::static_leave()" << endl; }
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/adapter.h b/include/framework/adapter.h
new file mode 100644
index 0000000..0a1a7e5
--- /dev/null
+++ b/include/framework/adapter.h
@@ -0,0 +1,122 @@
+// EPOS Component Framework - Scenario Adapter
+
+// Scenario adapters are the heart of EPOS component framework.
+// They collect component-specific Aspect programs to build a scenario for it to run.
+// Scenario features are enforced by wrapping all and any method invocation (event creation and destruction)
+// within the enter() and leave() methods.
+
+#ifndef __adapter_h
+#define __adapter_h
+
+#include "scenario.h"
+
+__BEGIN_SYS
+
+template<typename Component>
+class Adapter: public Component, public Scenario<Component>
+{
+    using Scenario<Component>::enter;
+    using Scenario<Component>::leave;
+    using Scenario<Component>::static_enter;
+    using Scenario<Component>::static_leave;
+
+public:
+    typedef Component _Component; // used by Message
+
+public:
+    template<typename ... Tn>
+    Adapter(const Tn & ... an): Component(an ...) { static_leave(); }
+    ~Adapter() { static_enter(); }
+
+    void * operator new(size_t bytes) {
+        static_enter();
+        return Scenario<Component>::operator new(bytes);
+    }
+    void operator delete(void * adapter) {
+        Scenario<Component>::operator delete(adapter);
+        static_leave();
+    }
+
+    static const Adapter<Component> * self() { static_enter(); const Adapter<Component> * res = reinterpret_cast<const Adapter<Component> *>(Component::self()); return res; }
+
+    // Process management
+    int join() { enter(); int res = Component::join(); leave(); return res; }
+    void pass() { enter(); Component::pass(); leave(); }
+    void suspend() { enter(); Component::suspend(); leave(); }
+    void resume() { enter(); Component::resume(); leave(); }
+    int state() { enter(); return Component::state(); leave(); }
+    static void yield() { static_enter(); Component::yield(); static_leave(); }
+    static void exit(int status) { static_enter(); Component::exit(status); static_leave(); }
+
+    Address_Space * address_space() { enter(); Address_Space * res = Component::address_space(); leave(); return res; }
+    Segment * code_segment() { enter(); Segment * res = Component::code_segment(); leave(); return res; }
+    Segment * data_segment() { enter(); Segment * res = Component::data_segment(); leave(); return res; }
+    CPU::Log_Addr code() { enter(); CPU::Log_Addr res = Component::code(); leave(); return res; }
+    CPU::Log_Addr data() { enter(); CPU::Log_Addr res = Component::data(); leave(); return res; }
+    Thread * main() { enter(); Thread * res = Component::main(); leave(); return res; }
+
+    // Memory management
+    CPU::Phy_Addr pd() { enter(); CPU::Phy_Addr res = Component::pd(); leave(); return res; }
+    CPU::Log_Addr attach(Segment * seg) { enter(); CPU::Log_Addr res = Component::attach(seg); leave(); return res; }
+    CPU::Log_Addr attach(Segment * seg, const CPU::Log_Addr & addr) { enter(); CPU::Log_Addr res = Component::attach(seg, addr); leave(); return res; }
+    void detach(Segment * seg) { enter(); Component::detach(seg); leave(); }
+    void detach(Segment * seg, const CPU::Log_Addr & addr) { enter(); Component::detach(seg, addr); leave(); }
+    CPU::Phy_Addr physical(const CPU::Log_Addr & addr) { enter(); CPU::Phy_Addr res = Component::physical(addr); leave(); return res; }
+
+    unsigned int size() { enter(); unsigned int res = Component::size(); leave(); return res; }
+    CPU::Phy_Addr phy_address() { enter(); CPU::Phy_Addr res = Component::phy_address(); leave(); return res; }
+    int resize(int amount) { enter(); int res = Component::resize(amount); leave(); return res; }
+
+    // Synchronization
+    void lock() { enter(); Component::lock(); leave(); }
+    void unlock() { enter(); Component::unlock(); leave(); }
+    void p() { enter(); Component::p(); leave(); }
+    void v() { enter(); Component::v(); leave(); }
+    void wait() { enter(); Component::wait(); leave(); }
+    void signal() { enter(); Component::signal(); leave(); }
+    void broadcast() { enter(); Component::broadcast(); leave(); }
+
+    // Timing
+    static void delay(const Microsecond & time) { static_enter(); Component::delay(time); static_leave(); }
+    void reset() { enter(); Component::reset(); leave(); }
+    void start() { enter(); Component::start(); leave(); }
+    void lap() { enter(); Component::lap(); leave(); }
+    void stop() { enter(); Component::stop(); leave(); }
+    int frequency() { enter(); int res = Component::frequency(); leave(); return res; }
+    int ticks() { enter(); int res = Component::ticks(); leave(); return res; }
+    int read() { enter(); int res = Component::read(); leave(); return res; }
+    
+    Microsecond resolution() { enter(); Microsecond res = Component::resolution(); leave(); return res; }
+    Second now() { enter(); Second res = Component::now(); leave(); return res; }
+    Clock::Date date() { enter(); Clock::Date res = Component::date(); leave(); return res; }
+    void date(Clock::Date d) { enter(); Component::date(d); leave(); }
+    
+    const Microsecond period() { enter(); Microsecond res = Component::period(); leave(); return res; }
+    void period(const Microsecond p) { enter(); Component::period(p); leave(); }
+    static Hertz alarm_frequency() { static_enter(); Hertz res = Component::frequency(); static_leave(); return res; }
+
+    // Communication
+    template<typename ... Tn>
+    int send(Tn ... an) {
+        enter();
+        int res = Component::send(an ...);
+        leave();
+        return res;
+    }
+    template<typename ... Tn>
+    int receive(Tn ... an) {
+        enter();
+        int res = Component::receive(an ...);
+        leave();
+        return res;
+    }
+
+    template<typename ... Tn>
+    int read(Tn ... an) { return receive(an ...);}
+    template<typename ... Tn>
+    int write(Tn ... an) { return send(an ...);}
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/agent.h b/include/framework/agent.h
new file mode 100644
index 0000000..60cee10
--- /dev/null
+++ b/include/framework/agent.h
@@ -0,0 +1,519 @@
+// EPOS Component Framework - Component Agent
+
+#ifndef __agent_h
+#define __agent_h
+
+#include <process.h>
+
+#include <memory.h>
+#include <time.h>
+#include <synchronizer.h>
+
+#include "message.h"
+
+__BEGIN_SYS
+
+class Agent: public Message
+{
+private:
+    typedef void (Agent:: * Member)();
+
+public:
+    void exec() {
+        //!P4: Improve messages
+        if(id().type() != UTILITY_ID)
+            db<Framework>(TRC) << ":=>" << *reinterpret_cast<Message *>(this) << endl;
+
+        if(id().type() < LAST_TYPE_ID) // in-kernel services
+            (this->*_handlers[id().type()])();
+
+        if(id().type() != UTILITY_ID)
+            db<Framework>(TRC) << "<=:" << *reinterpret_cast<Message *>(this) << endl;
+    }
+
+private:
+    void handle_thread();
+    void handle_display();
+    // void handle_task();
+    // void handle_active();
+    // void handle_address_space();
+    // void handle_segment();
+    void handle_mutex();
+    void handle_semaphore();
+    void handle_condition();
+    void handle_clock();
+    void handle_alarm();
+    void handle_chronometer();
+    // void handle_ipc();
+    void handle_utility();
+
+private:
+    static Member _handlers[LAST_TYPE_ID];
+};
+
+void Agent::handle_thread()
+{
+    Adapter<Thread> * thread = reinterpret_cast<Adapter<Thread> *>(id().unit());
+    Result res = 0;
+
+    switch(method()) {
+    case CREATE1: {
+        int (*entry)();
+        in(entry);
+        id(Id(THREAD_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Thread>(Thread::Configuration(Thread::READY), entry))));
+    } break;
+    case CREATE2: {
+        int (*entry)(void *);
+        void *params;
+        in(entry, params);
+        id(Id(THREAD_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Thread>(Thread::Configuration(Thread::READY), entry, params))));
+    } break;
+    // case CREATE4: {
+    //     int n, l, c;
+    //     int (*entry)(int, int, int);
+    //     in(entry,n,l,c);
+    //     //!P5: How would this fit with an Application loader which has to inform the priority of the main and idle threads
+    //     Adapter<Thread> * th = new Adapter<Thread>(Thread::Configuration(Thread::READY), entry, n, l, c);
+    //     id(Id(THREAD_ID, reinterpret_cast<Id::Unit_Id>(th)));
+    // } break;
+    case DESTROY:
+        delete thread;
+        break;
+    case SELF:
+        id(Id(THREAD_ID, reinterpret_cast<Id::Unit_Id>(Adapter<Thread>::self())));
+        break;
+    case THREAD_PRIORITY:
+        res = thread->priority();
+        break;
+    case THREAD_PRIORITY1: {
+        int p;
+        in(p);
+        thread->priority(Thread::Criterion(p));
+    } break;
+    case THREAD_STATE: {
+        res = thread->state();
+    } break;
+    case THREAD_JOIN:
+        res = thread->join();
+        break;
+    case THREAD_PASS:
+        thread->pass();
+        break;
+    case THREAD_SUSPEND:
+        thread->suspend();
+        break;
+    case THREAD_RESUME:
+        thread->resume();
+        break;
+    case THREAD_YIELD:
+        Thread::yield();
+        break;
+    case THREAD_WAIT_NEXT:
+        //            Periodic_Thread::wait_next();
+        break;
+    case THREAD_EXIT: {
+        int r;
+        in(r);
+        Thread::exit(r);
+    } break;
+    default:
+        res = UNDEFINED;
+    }
+
+    result(res);
+};
+
+// This is not part of the API; it is here due to philosophers_dinner, temporarily.
+void Agent::handle_display()
+{
+    Result res = 0;
+
+    switch(method()) {
+    case DISPLAY_PUTC: {
+        char c;
+        in(c);
+        Display::putc(c);
+    } break;
+    case DISPLAY_PUTS: {
+        char * s;
+        in(s);
+        Display::puts(s);
+    } break;
+    case DISPLAY_CLEAR: {
+        Display::clear();
+    } break;
+    case DISPLAY_GEOMETRY: {
+        int * lines;
+        int * columns;
+        in(lines, columns);
+        Display::geometry(lines, columns);
+    } break;
+    case DISPLAY_POSITION1: {
+        int * line;
+        int * column;
+        in(line, column);
+        Display::position(line, column);
+    } break;
+    case DISPLAY_POSITION2: {
+        int line;
+        int column;
+        in(line, column);
+        Display::position(line, column);
+    } break;
+    default:
+        res = UNDEFINED;
+    }
+    result(res);
+}
+
+// void Agent::handle_task()
+// {
+//     Adapter<Task> * task = reinterpret_cast<Adapter<Task> *>(id().unit());
+//     Result res = 0;
+
+//     switch(method()) {
+//     case CREATE3: {
+//         Segment * cs, * ds;
+//         int (*entry)();
+//         in(cs, ds, entry);
+//         id(Id(TASK_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Task>(cs, ds, entry))));
+//     } break;
+//     case DESTROY:
+//         delete task;
+//         break;
+//     case SELF:
+//         id(Id(TASK_ID, reinterpret_cast<Id::Unit_Id>(Adapter<Task>::self())));
+//         break;
+//     case TASK_ADDRESS_SPACE:
+//         res = reinterpret_cast<int>(task->address_space());
+//         break;
+//     case TASK_CODE_SEGMENT:
+//         res = reinterpret_cast<int>(task->code_segment());
+//         break;
+//     case TASK_DATA_SEGMENT:
+//         res = reinterpret_cast<int>(task->data_segment());
+//         break;
+//     case TASK_CODE:
+//         res = task->code();
+//         break;
+//     case TASK_DATA:
+//         res = task->data();
+//         break;
+//     case TASK_MAIN:
+//         res = reinterpret_cast<int>(task->main());
+//         break;
+//     default:
+//         res = UNDEFINED;
+//     }
+
+//     result(res);
+// };
+
+
+// void Agent::handle_active()
+// {
+//     result(UNDEFINED);
+// };
+
+
+// void Agent::handle_address_space()
+// {
+//     Adapter<Address_Space> * as = reinterpret_cast<Adapter<Address_Space> *>(id().unit());
+//     Result res = 0;
+
+//     switch(method()) {
+//     case CREATE:
+//         id(Id(ADDRESS_SPACE_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Address_Space>())));
+//         break;
+//     case CREATE1:
+//         MMU::Page_Directory * pd;
+//         in(pd);
+//         id(Id(ADDRESS_SPACE_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Address_Space>(pd))));
+//         break;
+//     case DESTROY:
+//         delete as;
+//         break;
+//     case ADDRESS_SPACE_PD:
+//         res = as->pd();
+//         break;
+//     case ADDRESS_SPACE_ATTACH1: {
+//         Segment * seg;
+//         in(seg);
+//         res = as->attach(seg);
+//     } break;
+//     case ADDRESS_SPACE_ATTACH2: {
+//         Segment * seg;
+//         CPU::Log_Addr addr;
+//         in(seg, addr);
+//         res = as->attach(seg, addr);
+//     } break;
+//     case ADDRESS_SPACE_DETACH1: {
+//         Segment * seg;
+//         in(seg);
+//         as->detach(seg);
+//     } break;
+//     case ADDRESS_SPACE_DETACH2: {
+//         Segment * seg;
+//         CPU::Log_Addr addr;
+//         in(seg, addr);
+//         as->detach(seg, addr);
+//     } break;
+//     case ADDRESS_SPACE_PHYSICAL: {
+//         CPU::Log_Addr addr;
+//         in(addr);
+//         res = as->physical(addr);
+//     } break;
+//     default:
+//         res = UNDEFINED;
+//     }
+
+//     result(res);
+// };
+
+
+// void Agent::handle_segment()
+// {
+//     Adapter<Segment> * seg = reinterpret_cast<Adapter<Segment> *>(id().unit());
+//     Result res = 0;
+
+//     switch(method()) {
+//     case CREATE1: {
+//         unsigned int bytes;
+//         in(bytes);
+//         id(Id(SEGMENT_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Segment>(bytes))));
+//     } break;
+//     case CREATE2: { // *** indistinguishable ***
+//         unsigned int bytes;
+//     Segment::Flags flags;
+//     in(bytes, flags);
+//     id(Id(SEGMENT_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Segment>(bytes, WHITE, flags))));
+//     } break;
+//     case CREATE3: { // *** indistinguishable ***
+//         Segment::Phy_Addr phy_addr;
+//     unsigned int bytes;
+//     Segment::Flags flags;
+//     in(phy_addr, bytes, flags);
+//     id(Id(SEGMENT_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Segment>(phy_addr, bytes, flags))));
+//     } break;
+//     case DESTROY:
+//         delete seg;
+//         break;
+//     case SEGMENT_SIZE:
+//         res = seg->size();
+//         break;
+//     case SEGMENT_PHY_ADDRESS:
+//         res = seg->phy_address();
+//         break;
+//     case SEGMENT_RESIZE: {
+//         int amount;
+//         in(amount);
+//         res = seg->resize(amount);
+//     } break;
+//     default:
+//         res = UNDEFINED;
+//     }
+
+//     result(res);
+// };
+
+void Agent::handle_mutex()
+{
+    
+    Adapter<Mutex> * mutex = reinterpret_cast<Adapter<Mutex> *>(id().unit());
+    Result res = 0;
+
+    switch(method()) {
+    case CREATE: {
+        id(Id(MUTEX_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Mutex>())));
+    } break;
+    case DESTROY:
+        delete mutex;
+        break;
+    case SYNCHRONIZER_LOCK:
+        mutex->lock();
+        break;
+    case SYNCHRONIZER_UNLOCK:
+        mutex->unlock();
+        break;
+    default:
+        res = UNDEFINED;
+        break;
+    }
+
+    result(res);    
+};
+
+void Agent::handle_semaphore()
+{
+    Adapter<Semaphore> * semaphore = reinterpret_cast<Adapter<Semaphore> *>(id().unit());
+    Result res = 0;
+
+    switch(method()) {
+    case CREATE: {
+        id(Id(SEMAPHORE_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Semaphore>())));
+    } break;
+    case CREATE1: {
+        int v;
+        in(v);
+        id(Id(SEMAPHORE_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Semaphore>(v))));
+    } break;
+    case DESTROY:
+        delete semaphore;
+        break;
+    case SYNCHRONIZER_P:
+        semaphore->p();
+        break;
+    case SYNCHRONIZER_V:
+        semaphore->v();
+        break;
+    default:
+        res = UNDEFINED;
+    }
+    
+    result(res);    
+
+};
+
+void Agent::handle_condition()
+{
+    result(UNDEFINED);
+};
+
+void Agent::handle_clock()
+{
+    Adapter<Clock> * clock = reinterpret_cast<Adapter<Clock> *>(id().unit());
+    Result res = 0;
+
+    switch(method()) {
+    case CREATE: {
+        id(Id(CLOCK_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Clock>())));
+    } break;
+    case DESTROY:
+        delete clock;
+        break;
+    case CLOCK_RESOLUTION:
+        res = clock->resolution();
+    break;
+    case CLOCK_NOW:
+        res = clock->now();
+    break;
+    case CLOCK_DATE:
+        // res = clock->date();
+    break;
+    case CLOCK_DATE1:{
+        // Date d;
+        // in(d);
+        // clock->date(d);
+    } break;
+    default:
+        res = UNDEFINED;
+    }
+
+    result(res);
+};
+
+void Agent::handle_alarm()
+{
+    Adapter<Alarm> * alarm = reinterpret_cast<Adapter<Alarm> *>(id().unit());
+    Result res = 0;
+
+    switch(method()) {
+    case CREATE2: {
+        Microsecond time;
+        Handler * handler;
+        in(time, handler);
+        id(Id(ALARM_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Alarm>(time, handler))));
+    } break;
+    case CREATE3: {
+        Microsecond time;
+        Handler * handler;
+        int times;
+        in(time, handler, times);
+        id(Id(ALARM_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Alarm>(time, handler, times))));
+    } break;
+    case DESTROY:
+        delete alarm;
+        break;
+    case ALARM_GET_PERIOD:
+        res = alarm->period();
+    break;
+    case ALARM_SET_PERIOD: {
+        Microsecond p;
+        in(p);
+        alarm->period(p);
+    } break;
+    case ALARM_FREQUENCY:
+        res = Adapter<Alarm>::alarm_frequency();
+    break;
+    case ALARM_DELAY: {
+        Microsecond time;
+        in(time);
+        Adapter<Alarm>::delay(time);
+    } break;
+    default:
+        res = UNDEFINED;
+    }
+
+    result(res);
+};
+
+void Agent::handle_chronometer()
+{
+    Adapter<Chronometer> * chronometer = reinterpret_cast<Adapter<Chronometer> *>(id().unit());
+    Result res = 0;
+
+    switch(method()) {
+    case CREATE: {
+        id(Id(CHRONOMETER_ID, reinterpret_cast<Id::Unit_Id>(new Adapter<Chronometer>())));
+    } break;
+    case DESTROY:
+        delete chronometer;
+        break;
+    case CHRONOMETER_FREQUENCY:
+        res = chronometer->frequency();
+    break;
+    case CHRONOMETER_RESET: {
+        chronometer->reset();
+    } break;
+    case CHRONOMETER_START:
+        chronometer->start();
+    break;
+    case CHRONOMETER_LAP: {
+        chronometer->lap();
+    } break;
+    case CHRONOMETER_STOP: {
+        chronometer->stop();
+    } break;
+    case CHRONOMETER_READ: {
+        res = chronometer->read();
+    } break;
+    case CHRONOMETER_TICKS: {
+        res = chronometer->ticks();
+    } break;
+    default:
+        res = UNDEFINED;
+    }
+
+    result(res);
+};
+
+void Agent::handle_utility()
+{
+    Result res = 0;
+
+    switch(method()) {
+    case PRINT: {
+        const char * s;
+        in(s);
+        _print(s);
+    } break;
+    default:
+        res = UNDEFINED;
+    }
+
+    result(res);
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/handle.h b/include/framework/handle.h
new file mode 100644
index 0000000..ade7d03
--- /dev/null
+++ b/include/framework/handle.h
@@ -0,0 +1,162 @@
+// EPOS Component Framework - Component Handle
+
+// Handle is the framework entry point. It defines a first component wrapper whose main
+// purpose is to ensure the invocation of proper new and delete operators (from scenario) for components,
+// independently of how they are declared by the client (static allocations will be forwarded to new).
+
+#ifndef __handle_h
+#define __handle_h
+
+#include "stub.h"
+
+__BEGIN_SYS
+
+template<typename Component>
+class Handle;
+
+// Handled is used to create a wrapper for components created either by SETUP before the framework came into place or internally by the framework itself
+template<typename Component>
+class Handled: public Handle<Component>
+{
+public:
+    Handled(): Handle<Component>(Handle<Component>::HANDLED) {
+        db<Framework>(TRC) << "Handled(this=" << this << ")" << endl;
+    }
+
+    void * operator new(size_t s, void * stub) {
+        db<Framework>(TRC) << "Handled::new(stub=" << stub << ")" << endl;
+        Framework::Element * el= Framework::_cache.search_key(reinterpret_cast<unsigned int>(stub));
+        void * handle;
+        if(el) {
+            handle = el->object();
+            db<Framework>(INF) << "Handled::new(stub=" << stub << ") => " << handle << " (CACHED)" << endl;
+        } else {
+            handle = new Handle<Component>(reinterpret_cast<typename Handle<Component>::_Stub *>(stub));
+            el = new Framework::Element(handle, reinterpret_cast<unsigned int>(stub));  // the handled cache is insert-only; object are intentionally never deleted, since they have been created by SETUP!
+            Framework::_cache.insert(el);
+        }
+        return handle;
+    }
+};
+
+
+template<typename Component>
+class Handle
+{
+    template<typename> friend class Handle;
+    template<typename> friend class Handled;
+    template<typename> friend class Proxy;
+
+private:
+    typedef Stub<Component, Traits<Component>::ASPECTS::Length || (Traits<System>::mode == Traits<Build>::KERNEL)> _Stub;
+
+    enum Private_Handle{ HANDLED };
+
+private:
+    Handle(const Private_Handle & h) { db<Framework>(TRC) << "Handle(HANDLED) => [stub=" << _stub << "]" << endl; }
+    Handle(_Stub * s) { _stub = s; }
+
+public:
+    template<typename ... Tn>
+    Handle(const Tn & ... an) { _stub = new _Stub(an ...); }
+
+    // Dereferencing handles for Task(cs, ds, ...)
+    template<typename ... Tn>
+    Handle(Handle<Segment> * cs, Handle<Segment> * ds, const Tn & ... an) { _stub = new _Stub(*cs->_stub, *ds->_stub, an ...); }
+
+    ~Handle() { if(_stub) delete _stub; }
+
+    static Handle<Component> * self() { return new (_Stub::self()) Handled<Component>; }
+
+    // Display
+    static void putc(char c) {_Stub::putc(c); }
+    static void puts(const char * s) {_Stub::puts(s); }
+    static void clear() {_Stub::clear(); }
+    static void geometry(int * lines, int * columns) { _Stub::geometry(lines, columns); }
+    static void position(int * line, int * column) {_Stub::position(line, column); }
+    static void position(int line, int column) {_Stub::position(line, column); }
+    
+    // Process management
+    int priority() { return _stub->priority(); }
+    void priority(int p) { _stub->priority(p); }
+    int join() { return _stub->join(); }
+    int pass() { return _stub->pass(); }
+    void suspend() { _stub->suspend(); }
+    void resume() { _stub->resume(); }
+    int state() { return _stub->state(); }
+    static void yield() { _Stub::yield(); }
+    static void exit(int r = 0) { _Stub::exit(r); }
+    static volatile bool wait_next() { return _Stub::wait_next(); }
+
+    Handle<Address_Space> * address_space() const { return new (_stub->address_space()) Handled<Address_Space>; }
+    Handle<Segment> * code_segment() const { return new (_stub->code_segment()) Handled<Segment>; }
+    Handle<Segment> * data_segment() const { return new (_stub->data_segment()) Handled<Segment>; }
+    CPU::Log_Addr code() const { return _stub->code(); }
+    CPU::Log_Addr data() const { return _stub->data(); }
+    Handle<Thread> * main() const { return new (_stub->main()) Handled<Thread>; }
+
+    // Memory Management
+    CPU::Phy_Addr pd() { return _stub->pd(); }
+    CPU::Log_Addr attach(Handle<Segment> * seg) { return _stub->attach(*seg->_stub); }
+    CPU::Log_Addr attach(Handle<Segment> * seg, CPU::Log_Addr addr) { return _stub->attach(*seg->_stub, addr); }
+    void detach(Handle<Segment> * seg) { _stub->detach(*seg->_stub); }
+    void detach(Handle<Segment> * seg, CPU::Log_Addr addr) { _stub->detach(*seg->_stub, addr); }
+    CPU::Phy_Addr physical(const CPU::Log_Addr addr) { return _stub->physical(addr); }
+
+    unsigned int size() const { return _stub->size(); }
+    CPU::Phy_Addr phy_address() const { return _stub->phy_address(); }
+    int resize(int amount) { return _stub->resize(amount); }
+
+    // Synchronization
+    void lock() { _stub->lock(); }
+    void unlock() { _stub->unlock(); }
+
+    void p() { _stub->p(); }
+    void v() { _stub->v(); }
+
+    void wait() { _stub->wait(); }
+    void signal() { _stub->signal(); }
+    void broadcast() { _stub->broadcast(); }
+
+    // Timing
+    template<typename T>
+    static void delay(T t) { _Stub::delay(t); }
+
+    void reset() { _stub->reset(); }
+    void start() { _stub->start(); }
+    void lap() { _stub->lap(); }
+    void stop() { _stub->stop(); }
+
+    unsigned long frequency() { return _stub->frequency(); }
+    Chronometer::Time_Stamp ticks() { return _stub->ticks(); }
+    int read() { return _stub->read(); }
+    
+    Microsecond resolution() { return _stub->resolution(); }
+    Second now() { return _stub->now(); }
+    Clock::Date date() { return _stub->date(); }
+    void date(const Clock::Date & d) { _stub->date(d); }
+
+    const Microsecond period() const { return _stub->period(); }
+    void period(const Microsecond p) { _stub->period(p); }
+    static Hertz alarm_frequency() { return _Stub::alarm_frequency(); }
+
+    // Communication
+    template<typename ... Tn>
+    int send(Tn ... an) { return _stub->send(an ...);}
+    template<typename ... Tn>
+    int receive(Tn ... an) { return _stub->receive(an ...);}
+    template<typename ... Tn>
+    int reply(Tn ... an) { return _stub->reply(an ...);}
+
+    template<typename ... Tn>
+    int read(Tn ... an) { return _stub->read(an ...);}
+    template<typename ... Tn>
+    int write(Tn ... an) { return _stub->write(an ...);}
+
+private:
+    _Stub * _stub;
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/id.h b/include/framework/id.h
new file mode 100644
index 0000000..80c30fa
--- /dev/null
+++ b/include/framework/id.h
@@ -0,0 +1,49 @@
+// EPOS Component Identification Aspect Program
+
+#ifndef __id_h
+#define __id_h
+
+#include <utility/debug.h>
+
+__BEGIN_SYS
+
+class Pointer_Id
+{
+public:
+    enum Null { NULL = 0 };
+
+    enum {
+        ANY_UNIT = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+    };
+
+    typedef void Host_Id;
+    typedef unsigned int Type_Id;
+    typedef unsigned int Unit_Id;
+
+public:
+    Pointer_Id() {}
+    Pointer_Id(const Null &): _type(NULL), _unit(NULL) {}
+    Pointer_Id(const Type_Id & t, const Unit_Id & u): _type(t), _unit(u) {}
+    template<typename Component>
+    Pointer_Id(const Component * c): _type(Type<Component>::ID), _unit(reinterpret_cast<Unit_Id>(c)) {}
+
+    const Pointer_Id & id() const { return *this; }
+    void id(const Type_Id & t, const Unit_Id & u) { _type = t; _unit = u; }
+
+    const Type_Id & type() const { return _type; }
+    const Unit_Id & unit() const { return _unit; }
+
+    friend Debug & operator << (Debug & db, const Pointer_Id & id) {
+        db << "{t=" << id.type() << ",u=" << reinterpret_cast<void *>(id.unit()) << "}" ; return db;
+    }
+
+private:
+    Type_Id _type;
+    Unit_Id _unit;
+};
+
+typedef Pointer_Id Id;
+
+__END_SYS
+
+#endif
diff --git a/include/framework/main.h b/include/framework/main.h
new file mode 100644
index 0000000..5817742
--- /dev/null
+++ b/include/framework/main.h
@@ -0,0 +1,99 @@
+// EPOS Component Framework
+
+#ifndef __framework_h
+#define __framework_h
+
+#include <utility/hash.h>
+
+__BEGIN_SYS
+
+class Framework
+{
+    template<typename> friend class Handled;
+    template<typename> friend class Proxied;
+
+private:
+    typedef Simple_Hash<void, 5, unsigned int> Cache; // TODO: a real cache, with operator >> instead of % would improve performance
+    typedef Cache::Element Element;
+
+public:
+    Framework() {}
+
+private:
+    static Cache _cache;
+};
+
+__END_SYS
+
+#include <architecture/cpu.h>
+#include <architecture/mmu.h>
+#include <system.h>
+#include <process.h>
+
+#include <time.h>
+#include <memory.h>
+#include <synchronizer.h>
+
+#include "handle.h"
+
+#define BIND(X) typedef _SYS::IF<(_SYS::Traits<_SYS::X>::ASPECTS::Length || (_SYS::Traits<_SYS::Build>::MODE == _SYS::Traits<_SYS::Build>::KERNEL)), _SYS::Handle<_SYS::X>, _SYS::X>::Result X;
+#define EXPORT(X) typedef _SYS::X X;
+
+__BEGIN_API
+
+__USING_UTIL
+
+EXPORT(CPU);
+EXPORT(Handler);
+EXPORT(Function_Handler);
+
+EXPORT(System);
+EXPORT(Application);
+
+BIND(Thread);
+// BIND(Periodic_Thread);
+// BIND(RT_Thread);
+// BIND(ACTIVE);
+// BIND(Task);
+
+// BIND(Address_Space);
+// BIND(Segment);
+
+BIND(Mutex);
+BIND(Semaphore);
+// BIND(Condition);
+
+BIND(Clock);
+BIND(Chronometer);
+BIND(Alarm);
+// BIND(Delay);
+
+BIND(Display);
+
+// EXPORT(IPC);
+
+template<typename Channel, bool connectionless = Channel::connectionless>
+class Link: public _SYS::Handle<_SYS::Link<Channel, connectionless>>
+{
+private:
+    typedef typename _SYS::Handle<_SYS::Link<Channel, connectionless>> Base;
+
+public:
+    template<typename ... Tn>
+    Link(const Tn & ... an): Base(an ...) {};
+};
+
+template<typename Channel, bool connectionless = Channel::connectionless>
+class Port: public _SYS::Handle<_SYS::Port<Channel, connectionless>>
+{
+private:
+    typedef typename _SYS::Handle<_SYS::Port<Channel, connectionless>> Base;
+
+public:
+    template<typename ... Tn>
+    Port(const Tn & ... an): Base(an ...) {};
+};
+
+__END_API
+
+#endif
diff --git a/include/framework/message.h b/include/framework/message.h
new file mode 100644
index 0000000..22223d6
--- /dev/null
+++ b/include/framework/message.h
@@ -0,0 +1,165 @@
+// EPOS Component Framework - Proxy x Agent Message
+
+#ifndef __message_h
+#define __message_h
+
+#include <utility/observer.h>
+#include <utility/buffer.h>
+#include "id.h"
+
+extern "C" { void _syscall(void *); }
+
+__BEGIN_SYS
+
+class Message
+{
+private:
+    static const unsigned int MAX_PARAMETERS_SIZE = 20;
+
+public:
+    enum {
+        CREATE,
+        CREATE1,
+        CREATE2,
+        CREATE3,
+        CREATE4,
+        CREATE5,
+        CREATE6,
+        CREATE7,
+        CREATE8,
+        CREATE9,
+        DESTROY,
+        SELF,
+
+        COMPONENT = 0x10,
+
+        THREAD_STATE = COMPONENT,
+        THREAD_PRIORITY,
+        THREAD_PRIORITY1,
+        THREAD_JOIN,
+        THREAD_PASS,
+        THREAD_SUSPEND,
+        THREAD_RESUME,
+        THREAD_YIELD,
+        THREAD_EXIT,
+        THREAD_WAIT_NEXT,
+        
+        DISPLAY_PUTC = COMPONENT,
+        DISPLAY_PUTS,
+        DISPLAY_CLEAR,
+        DISPLAY_GEOMETRY,
+        DISPLAY_POSITION1,
+        DISPLAY_POSITION2,
+        
+        TASK_ADDRESS_SPACE = COMPONENT,
+        TASK_CODE_SEGMENT,
+        TASK_DATA_SEGMENT,
+        TASK_CODE,
+        TASK_DATA,
+        TASK_MAIN,
+
+        ADDRESS_SPACE_PD = COMPONENT,
+        ADDRESS_SPACE_ATTACH1,
+        ADDRESS_SPACE_ATTACH2,
+        ADDRESS_SPACE_DETACH1,
+        ADDRESS_SPACE_DETACH2,
+        ADDRESS_SPACE_PHYSICAL,
+
+        SEGMENT_SIZE = COMPONENT,
+        SEGMENT_PHY_ADDRESS,
+        SEGMENT_RESIZE,
+        CREATE_SEGMENT_IN_PLACE,
+        CREATE_HEAP_IN_PLACE,
+
+        SYNCHRONIZER_LOCK = COMPONENT,
+        SYNCHRONIZER_UNLOCK,
+        SYNCHRONIZER_P,
+        SYNCHRONIZER_V,
+        SYNCHRONIZER_WAIT,
+        SYNCHRONIZER_SIGNAL,
+        SYNCHRONIZER_BROADCAST,
+        
+        CLOCK_RESOLUTION = COMPONENT,
+        CLOCK_NOW,
+        CLOCK_DATE,
+        CLOCK_DATE1,
+
+        ALARM_DELAY = COMPONENT,
+        ALARM_GET_PERIOD,
+        ALARM_SET_PERIOD,
+        ALARM_FREQUENCY,
+        
+        CHRONOMETER_FREQUENCY = COMPONENT,
+        CHRONOMETER_RESET,
+        CHRONOMETER_START,
+        CHRONOMETER_LAP,
+        CHRONOMETER_STOP,
+        CHRONOMETER_READ,
+        CHRONOMETER_TICKS,
+        
+
+        PRINT = COMPONENT,
+
+        UNDEFINED = -1
+    };
+    typedef int Method;
+    typedef Method Result;
+
+    typedef Simple_List<Message> List;
+    typedef List::Element Element;
+
+public:
+    Message(): _link(this) {}
+    Message(const Message & msg): _link(this) { *this = msg; _link = this; }
+    Message(const Id & id): _id(id), _link(this) {}
+    template<typename ... Tn>
+    Message(const Id & id, const Method & m, Tn && ... an): _id(id), _method(m), _link(this) { out(an ...); }
+
+    const Id & id() const { return _id; }
+    void id(const Id & id) { _id = id; }
+
+    const Method & method() const { return _method; }
+    void method(const Method & m) { _method = m; }
+    const Result & result() const { return _method; }
+    void result(const Result & r) { _method = r; }
+
+    template<typename ... Tn>
+    void in(Tn && ... an) {
+        // Force a compilation error in case out is called with too many arguments
+        typename IF<(SIZEOF<Tn ...>::Result <= MAX_PARAMETERS_SIZE), int, void>::Result index = 0;
+        DESERIALIZE(_parms, index, an ...);
+    }
+    template<typename ... Tn>
+    void out(Tn && ... an) {
+        // Force a compilation error in case out is called with too many arguments
+        typename IF<(SIZEOF<Tn ...>::Result <= MAX_PARAMETERS_SIZE), int, void>::Result index = 0;
+        SERIALIZE(_parms, index, an ...);
+    }
+
+    void reply_to(const Id & id) { _reply_to = id; }
+    const Id & reply_to() { return _reply_to; }
+
+    void act() { _syscall(this); }
+
+    Element * lext() { return &_link; }
+
+    friend Debug & operator << (Debug & db, const Message & m) {
+          db << "{id=" << m._id << ",m=" << hex << m._method << ",rt=" << m._reply_to
+             << ",p={" << reinterpret_cast<void *>(*static_cast<const int *>(reinterpret_cast<const void *>(&m._parms[0]))) << ","
+             << reinterpret_cast<void *>(*static_cast<const int *>(reinterpret_cast<const void *>(&m._parms[4]))) << ","
+             << reinterpret_cast<void *>(*static_cast<const int *>(reinterpret_cast<const void *>(&m._parms[8]))) << "}}";
+          return db;
+      }
+
+public:
+    Id _id;
+    Method _method;
+    char _parms[MAX_PARAMETERS_SIZE];
+
+    Id _reply_to;
+    Element _link;
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/proxy.h b/include/framework/proxy.h
new file mode 100644
index 0000000..64a8dbd
--- /dev/null
+++ b/include/framework/proxy.h
@@ -0,0 +1,154 @@
+// EPOS Component Framework - Component Proxy
+
+// Proxies and Agents handle RMI within EPOS component framework
+
+#ifndef __proxy_h
+#define __proxy_h
+
+#include "message.h"
+
+__BEGIN_SYS
+
+template<typename Component>
+class Proxy;
+
+// Proxied is used to create a Proxy for components created either by SETUP before the framework came into place or internally by the framework itself
+template<typename Component>
+class Proxied: public Proxy<Component>
+{
+public:
+    Proxied(): Proxy<Component>(Proxy<Component>::PROXIED) {
+        db<Framework>(TRC) << "Proxied(this=" << this << ")" << endl;
+    }
+
+    void * operator new(size_t s, void * adapter) {
+        db<Framework>(TRC) << "Proxied::new(adapter=" << adapter << ")" << endl;
+        Framework::Element * el= Framework::_cache.search_key(reinterpret_cast<unsigned int>(adapter));
+        void * proxy;
+        if(el) {
+            proxy = el->object();
+            db<Framework>(INF) << "Proxied::new(adapter=" << adapter << ") => " << proxy << " (CACHED)" << endl;
+        } else {
+            proxy = new Proxy<Component>(Id(Type<Component>::ID, reinterpret_cast<Id::Unit_Id>(adapter)));
+            el = new Framework::Element(proxy, reinterpret_cast<unsigned int>(adapter));  // the proxied cache is insert-only; object are intentionally never deleted, since they have been created by SETUP!
+            Framework::_cache.insert(el);
+        }
+        return proxy;
+    }
+};
+
+template<typename Component>
+class Proxy: public Message
+{
+    template<typename> friend class Proxy;
+    template<typename> friend class Proxied;
+
+private:
+    enum Private_Proxied{ PROXIED };
+
+private:
+    Proxy(const Id & id): Message(id) {} // for Proxied::operator new()
+    Proxy(const Private_Proxied & p) { db<Framework>(TRC) << "Proxy(PROXIED) => [id=" << Proxy<Component>::id() << "]" << endl; } // for Proxied
+
+public:
+    template<typename ... Tn>
+    Proxy(const Tn & ... an): Message(Id(Type<Component>::ID, 0)) { invoke(CREATE + sizeof ... (Tn), an ...); }
+    ~Proxy() { invoke(DESTROY); }
+
+    static Proxy<Component> * self() { return new (reinterpret_cast<void *>(static_invoke(SELF))) Proxied<Component>; }
+
+    // Display
+    static void putc(char c) { static_invoke(DISPLAY_PUTC, c); }
+    static void puts(const char * s) { static_invoke(DISPLAY_PUTS, s); }
+    static void clear() { static_invoke(DISPLAY_CLEAR); }
+    static void geometry(int * lines, int * columns) { static_invoke(DISPLAY_GEOMETRY, lines, columns); }
+    static void position(int * line, int * column) { static_invoke(DISPLAY_POSITION1, line, column); }
+    static void position(int line, int column) { static_invoke(DISPLAY_POSITION2, line, column); }
+    
+    // Process management
+    int state() { return invoke(THREAD_STATE); }
+    int priority() { return invoke(THREAD_PRIORITY); }
+    void priority(int p) { invoke(THREAD_PRIORITY1, p); }
+    int join() { return invoke(THREAD_JOIN); }
+    int pass() { return invoke(THREAD_PASS); }
+    void suspend() { invoke(THREAD_SUSPEND); }
+    void resume() { invoke(THREAD_RESUME); }
+    static int yield() { return static_invoke(THREAD_YIELD); }
+    static void exit(int r) { static_invoke(THREAD_EXIT, r); }
+    static volatile bool wait_next() { return static_invoke(THREAD_WAIT_NEXT); }
+
+    Proxy<Address_Space> * address_space() { return new (reinterpret_cast<Adapter<Address_Space> *>(invoke(TASK_ADDRESS_SPACE))) Proxied<Address_Space>; }
+    Proxy<Segment> * code_segment() { return new (reinterpret_cast<Adapter<Segment> *>(invoke(TASK_CODE_SEGMENT))) Proxied<Segment>; }
+    Proxy<Segment> * data_segment() { return new (reinterpret_cast<Adapter<Segment> *>(invoke(TASK_DATA_SEGMENT))) Proxied<Segment>; }
+    CPU::Log_Addr code() { return invoke(TASK_CODE); }
+    CPU::Log_Addr data() { return invoke(TASK_DATA); }
+    Proxy<Thread> * main() { return new (reinterpret_cast<Adapter<Thread> *>(invoke(TASK_MAIN))) Proxied<Thread>; }
+
+    // Memory management
+    CPU::Phy_Addr pd() { return invoke(ADDRESS_SPACE_PD); }
+    CPU::Log_Addr attach(const Proxy<Segment> & seg) { return invoke(ADDRESS_SPACE_ATTACH1, seg.id().unit()); }
+    CPU::Log_Addr attach(const Proxy<Segment> & seg, CPU::Log_Addr addr) { return invoke(ADDRESS_SPACE_ATTACH2, seg.id().unit(), addr); }
+    void detach(const Proxy<Segment> & seg) { invoke(ADDRESS_SPACE_DETACH1, seg.id().unit());}
+    void detach(const Proxy<Segment> & seg, CPU::Log_Addr addr) { invoke(ADDRESS_SPACE_DETACH2, seg.id().unit(), addr); }
+    CPU::Phy_Addr physical(const CPU::Log_Addr addr) { return invoke(ADDRESS_SPACE_PHYSICAL, addr); }
+
+    unsigned int size() { return invoke(SEGMENT_SIZE); }
+    CPU::Phy_Addr phy_address() { return invoke(SEGMENT_PHY_ADDRESS); }
+    int resize(int amount) { return invoke(SEGMENT_RESIZE, amount); }
+
+    // Synchronization
+    void lock() { invoke(SYNCHRONIZER_LOCK); }
+    void unlock() { invoke(SYNCHRONIZER_UNLOCK); }
+
+    void p() { invoke(SYNCHRONIZER_P); }
+    void v() { invoke(SYNCHRONIZER_V); }
+
+    void wait() { invoke(SYNCHRONIZER_WAIT); }
+    void signal() { invoke(SYNCHRONIZER_SIGNAL); }
+    void broadcast() { invoke(SYNCHRONIZER_BROADCAST); }
+
+    // Timing
+    template<typename T>
+    static void delay(T t) { static_invoke(ALARM_DELAY, t); }
+    static Hertz alarm_frequency() { return static_invoke(ALARM_FREQUENCY); } 
+    
+    void reset() { invoke(CHRONOMETER_RESET); }
+    void start() { invoke(CHRONOMETER_START); }
+    void lap() { invoke(CHRONOMETER_LAP); }
+    void stop() { invoke(CHRONOMETER_STOP); }
+    unsigned long frequency() { return invoke(CHRONOMETER_FREQUENCY); }
+    Chronometer::Time_Stamp ticks() { return invoke(CHRONOMETER_TICKS); }
+    int read() { return invoke(CHRONOMETER_READ); }
+    
+    Microsecond resolution() { return invoke(CLOCK_RESOLUTION); }
+    Second now() { return invoke(CLOCK_NOW); }
+    Clock::Date date() { return invoke(CLOCK_DATE); }
+    void date(const Clock::Date & d) { invoke(CLOCK_DATE1, d); }
+    
+    template<typename ... Tn>
+    int read(Tn ... an) { return receive(an ...); }
+    template<typename ... Tn>
+    int write(Tn ... an) { return send(an ...); }
+
+ private:
+    template<typename ... Tn>
+    Result invoke(const Method & m, const Tn & ... an) {
+        method(m);
+        out(an ...);
+        act();
+        return result();
+    }
+
+    template<typename ... Tn>
+    static Result static_invoke(const Method & m, const Tn & ... an) {
+        Message msg(Id(Type<Component>::ID, 0)); // avoid calling ~Proxy()
+        msg.method(m);
+        msg.out(an ...);
+        msg.act();
+        return (m == SELF) ? msg.id().unit() : msg.result();
+    }
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/scenario.h b/include/framework/scenario.h
new file mode 100644
index 0000000..433a044
--- /dev/null
+++ b/include/framework/scenario.h
@@ -0,0 +1,33 @@
+// EPOS Component Framework - Execution Scenario
+
+// Scenario is simply an ordered collection of Aspect programs that are
+// to be applied to a given component through its scenario adapter.
+
+#ifndef __scenario_h
+#define __scenario_h
+
+#include <aspect/shared.h>
+#include <aspect/authenticated.h>
+#include <aspect/energy_aware.h>
+
+__BEGIN_SYS
+
+template<typename Component>
+class Scenario: public Traits<Component>::ASPECTS::template Recur<Component>
+{
+protected:
+    Scenario() {}
+
+public:
+    ~Scenario() {}
+
+    static const Power_Mode & power();
+    static Power_Mode power(const Power_Mode & mode);
+
+    void * operator new(size_t bytes) { return ::operator new(bytes, SYSTEM); }
+    void operator delete(void * ptr) { ::operator delete(ptr); }
+};
+
+__END_SYS
+
+#endif
diff --git a/include/framework/stub.h b/include/framework/stub.h
new file mode 100644
index 0000000..5fe1430
--- /dev/null
+++ b/include/framework/stub.h
@@ -0,0 +1,39 @@
+// EPOS Component Framework - Component Stub
+
+// Stub selectively binds the Handle either to the component's scenario Adapter or to its Proxy.
+// Proxies are used in the kernel mode or when a component is subject to the Remote Aspect program.
+
+#ifndef __stub_h
+#define __stub_h
+
+#include "adapter.h"
+#include "proxy.h"
+
+__BEGIN_SYS
+
+template<typename Component, bool remote>
+class Stub: public Adapter<Component>
+{
+public:
+    template<typename ... Tn>
+    Stub(const Tn & ... an): Adapter<Component>(an ...) {}
+    ~Stub() {}
+};
+
+template<typename Component>
+class Stub<Component, true>: public Proxy<Component>
+{
+public:
+    template<typename ... Tn>
+    Stub(const Tn & ... an): Proxy<Component>(an ...) {}
+
+    // Dereferencing stubs for Task(cs, ds, ...)
+    template<typename ... Tn>
+    Stub(const Stub<Segment, true> & cs, const Stub<Segment, true> & ds, const Tn & ... an): Proxy<Component>(cs.id().unit(), ds.id().unit(), an ...) {}
+
+    ~Stub() {}
+};
+
+__END_SYS
+
+#endif
diff --git a/include/machine/display.h b/include/machine/display.h
index 03a873c..f3599c7 100644
--- a/include/machine/display.h
+++ b/include/machine/display.h
@@ -34,6 +34,7 @@ public:
 class Serial_Display: public Display_Common
 {
     friend class PC_Setup;
+    friend class Setup_SifiveE;
     friend class Serial_Keyboard;
     friend class Machine;
 
diff --git a/include/machine/riscv/riscv_ic.h b/include/machine/riscv/riscv_ic.h
index c4ba106..eb334ec 100644
--- a/include/machine/riscv/riscv_ic.h
+++ b/include/machine/riscv/riscv_ic.h
@@ -16,7 +16,7 @@ public:
     static const unsigned int IRQS = 16;
 
     // Interrupts (mcause with interrupt = 1)
-    enum {
+    enum : unsigned int {
         IRQ_USR_SOFT            = 0,
         IRQ_SUP_SOFT            = 1,
         IRQ_MAC_SOFT            = 3,
@@ -26,7 +26,13 @@ public:
         IRQ_USR_EXT             = 8,
         IRQ_SUP_EXT             = 9,
         IRQ_MAC_EXT             = 11,
-        INTERRUPT               = 1 << 31
+        INTERRUPT               = 1UL << 31,
+        INT_MASK                = ~INTERRUPT
+    };
+
+    // Exceptions
+    enum : unsigned int {
+        EXC_INSTR_PAGE_FAULT    = 12,
     };
 
     // Registers offsets from CLINT_BASE
@@ -43,6 +49,7 @@ public:
 class IC: private IC_Common, private CLINT
 {
     friend class Machine;
+    friend class Setup_SifiveE;
 
 private:
     typedef CPU::Reg Reg;
@@ -55,8 +62,8 @@ public:
 
     enum {
         HARD_INT        = CPU::EXCEPTIONS,
-        INT_SYS_TIMER   = HARD_INT + IRQ_MAC_TIMER,
-        INT_RESCHEDULER = HARD_INT + IRQ_MAC_SOFT, // An IPI is mapped to the machine with mcause set to IRQ_MAC_SOFT
+        INT_SYS_TIMER   = HARD_INT + IRQ_SUP_TIMER,
+        INT_RESCHEDULER = HARD_INT + IRQ_SUP_SOFT, // An IPI is mapped to the machine with mcause set to IRQ_MAC_SOFT
         INT_MASK        = CPU::Reg32(1 << 31) - 1
     };
 
@@ -76,7 +83,7 @@ public:
 
     static void enable() {
         db<IC>(TRC) << "IC::enable()" << endl;
-        CPU::mie(CPU::MSI | CPU::MTI | CPU::MEI);
+        CPU::sie(CPU::SSI | CPU::STI | CPU::SEI);
     }
 
     static void enable(Interrupt_Id i) {
@@ -88,7 +95,7 @@ public:
 
     static void disable() {
         db<IC>(TRC) << "IC::disable()" << endl;
-        CPU::mie_clear(CPU::MSI | CPU::MTI | CPU::MEI);
+        CPU::sie_clear(CPU::SSI | CPU::STI | CPU::SEI);
     }
 
     static void disable(Interrupt_Id i) {
@@ -100,7 +107,7 @@ public:
 
     static Interrupt_Id int_id() {
         // Id is retrieved from mcause even if mip has the equivalent bit up, because only mcause can tell if it is an interrupt or an exception
-        Reg id = CPU::mcause();
+        Reg id = CPU::scause();
         if(id & INTERRUPT)
             return (id & INT_MASK) + HARD_INT;
         else
@@ -131,7 +138,7 @@ private:
     static void exception(Interrupt_Id i);
 
     // Physical handler
-    static void entry();
+    [[gnu::naked, gnu::aligned(4)]] static void entry();
 
     static void init();
 
diff --git a/include/machine/riscv/riscv_info.h b/include/machine/riscv/riscv_info.h
deleted file mode 100644
index f50bdda..0000000
--- a/include/machine/riscv/riscv_info.h
+++ /dev/null
@@ -1,63 +0,0 @@
-// EPOS RISC-V Common Run-Time System Information
-
-#ifndef __riscv_info_h
-#define __riscv_info_h
-
-#include <system/info.h>
-
-__BEGIN_SYS
-
-struct System_Info
-{
-private:
-    typedef unsigned int LAddr;
-    typedef unsigned int PAddr;
-    typedef unsigned int Size;
-
-public:
-    // The information we have at boot time (built by MKBI)
-    // Modifications to this map requires adjustments at MKBI
-    struct Boot_Map
-    {
-        volatile unsigned int n_cpus;     // Number of CPUs in SMPs
-        PAddr mem_base;                   // Memory base address
-        PAddr mem_top;                    // Memory top address
-        PAddr io_base;                    // I/O Memory base address
-        PAddr io_top;                     // I/O Memory top address
-        int node_id;                      // Local node id in SAN (-1 => RARP)
-        int space_x;                      // Spatial coordinates of a node (-1 => mobile)
-        int space_y;                      //
-        int space_z;                      //
-        unsigned char uuid[8];            // EPOS image Universally Unique Identifier
-        Size img_size;                    // Boot image size (in bytes)
-        Size setup_offset;                // Image offsets (-1 => not present)
-        Size init_offset;
-        Size system_offset;
-        Size application_offset;
-        Size extras_offset;
-    };
-
-    // Load Map (not used in this machine, but kept for architectural transparency)
-    struct Load_Map
-    {
-        bool  has_ext;
-        LAddr app_entry;
-        Size  app_segments;
-        LAddr app_code;
-        Size  app_code_size;
-        LAddr app_data;
-        LAddr app_stack;
-        LAddr app_heap;
-        Size  app_data_size;
-        PAddr app_extra;
-        Size  app_extra_size;
-    };
-
-public:
-    Boot_Map bm;
-    Load_Map lm;
-};
-
-__END_SYS
-
-#endif
diff --git a/include/machine/riscv/riscv_timer.h b/include/machine/riscv/riscv_timer.h
index 18cca96..2b50117 100644
--- a/include/machine/riscv/riscv_timer.h
+++ b/include/machine/riscv/riscv_timer.h
@@ -17,13 +17,16 @@ class Timer: private Timer_Common, private CLINT
     friend Machine;
     friend IC;
     friend class Init_System;
-
 protected:
+    friend class Setup_SifiveE; // Timer::config will be called during setup
     static const unsigned int CHANNELS = 2;
     static const unsigned int FREQUENCY = Traits<Timer>::FREQUENCY;
-
     typedef IC_Common::Interrupt_Id Interrupt_Id;
 
+    static void config(const Hertz & frequency) {
+        reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
+    }
+
 public:
     using Timer_Common::Tick;
     using Timer_Common::Handler;
@@ -72,10 +75,6 @@ public:
 private:
     static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::CLINT_BASE)[o / sizeof(CPU::Reg32)]; }
 
-    static void config(const Hertz & frequency) {
-        reg(MTIMECMP + MTIMECMP_CORE_OFFSET * CPU::id()) = reg(MTIME) + (CLOCK / frequency);
-    }
-
     static void int_handler(Interrupt_Id i);
 
     static void init();
diff --git a/include/machine/riscv/sifive_e/sifive_e_info.h b/include/machine/riscv/sifive_e/sifive_e_info.h
index f50bdda..4f9f592 100644
--- a/include/machine/riscv/sifive_e/sifive_e_info.h
+++ b/include/machine/riscv/sifive_e/sifive_e_info.h
@@ -1,12 +1,31 @@
 // EPOS RISC-V Common Run-Time System Information
 
-#ifndef __riscv_info_h
-#define __riscv_info_h
+#ifndef __riscv_sifive_e_info_h
+#define __riscv_sifive_e_info_h
 
 #include <system/info.h>
 
 __BEGIN_SYS
 
+
+struct App_Load_Map
+{
+private:
+    typedef unsigned int LAddr;
+    typedef unsigned int PAddr;
+    typedef unsigned int Size;
+
+public:
+    LAddr app_entry;
+    Size  app_segments;
+    LAddr app_code;
+    Size  app_code_size;
+    LAddr app_data;
+    LAddr app_stack;
+    LAddr app_heap;
+    Size  app_data_size;
+};
+
 struct System_Info
 {
 private:
@@ -22,8 +41,8 @@ public:
         volatile unsigned int n_cpus;     // Number of CPUs in SMPs
         PAddr mem_base;                   // Memory base address
         PAddr mem_top;                    // Memory top address
-        PAddr io_base;                    // I/O Memory base address
-        PAddr io_top;                     // I/O Memory top address
+        PAddr mio_base;                   // Memory-mapped I/O base address
+        PAddr mio_top;                    // Memory-mapped I/O top address
         int node_id;                      // Local node id in SAN (-1 => RARP)
         int space_x;                      // Spatial coordinates of a node (-1 => mobile)
         int space_y;                      //
@@ -33,25 +52,51 @@ public:
         Size setup_offset;                // Image offsets (-1 => not present)
         Size init_offset;
         Size system_offset;
-        Size application_offset;
+        Size application_offset[8];
+        unsigned int n_apps;
         Size extras_offset;
     };
 
-    // Load Map (not used in this machine, but kept for architectural transparency)
     struct Load_Map
     {
+        bool  has_stp;
+        bool  has_ini;
+        bool  has_sys;
+        bool  has_app;
         bool  has_ext;
-        LAddr app_entry;
-        Size  app_segments;
-        LAddr app_code;
-        Size  app_code_size;
-        LAddr app_data;
-        LAddr app_stack;
-        LAddr app_heap;
-        Size  app_data_size;
+        LAddr stp_entry;
+        Size  stp_segments;
+        LAddr stp_code;
+        Size  stp_code_size;
+        LAddr stp_data;
+        Size  stp_data_size;
+        LAddr ini_entry;
+        Size  ini_segments;
+        LAddr ini_code;
+        Size  ini_code_size;
+        LAddr ini_data;
+        Size  ini_data_size;
+        LAddr sys_entry;
+        Size  sys_segments;
+        LAddr sys_code;
+        Size  sys_code_size;
+        LAddr sys_data;
+        Size  sys_data_size;
+        LAddr sys_stack;
+        Size  sys_stack_size;
+        App_Load_Map app[8];
+        // LAddr app_entry;
+        // Size  app_segments;
+        // LAddr app_code;
+        // Size  app_code_size;
+        // LAddr app_data;
+        // LAddr app_stack;
+        // LAddr app_heap;
+        // Size  app_data_size;
         PAddr app_extra;
         Size  app_extra_size;
     };
+    
 
 public:
     Boot_Map bm;
diff --git a/include/machine/riscv/sifive_e/sifive_e_memory_map.h b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
index 3ea43bd..170c825 100644
--- a/include/machine/riscv/sifive_e/sifive_e_memory_map.h
+++ b/include/machine/riscv/sifive_e/sifive_e_memory_map.h
@@ -11,7 +11,9 @@ __BEGIN_SYS
 
 struct Memory_Map
 {
-    // Physical Memory
+    static const unsigned int NOT_USED = Traits<Machine>::NOT_USED;
+    
+    // Memory Mapped stuff
     enum {
         TEST_BASE                   = 0x00100000, // SiFive test engine
         RTC_BASE                    = 0x00101000, // goldfish_rtc
@@ -24,23 +26,34 @@ struct Memory_Map
     // Physical Memory
     enum {
         MEM_BASE        = Traits<Machine>::MEM_BASE,
-        MEM_TOP         = Traits<Machine>::MEM_TOP
+        MEM_TOP         = Traits<Machine>::MEM_TOP,
+        MIO_BASE        = Traits<Machine>::MIO_BASE,
+        MIO_TOP         = Traits<Machine>::MIO_TOP,
+        BOOT_STACK      = Traits<Machine>::BOOT_STACK,
+        PAGE_TABLES     = Traits<Machine>::PAGE_TABLES,
+        MMODE_F         = Traits<Machine>::MMODE_F,
     };
 
     // Logical Address Space
     enum {
+        BOOT            = Traits<Machine>::BOOT,
+        IMAGE           = Traits<Machine>::IMAGE,
+        SETUP           = Traits<Machine>::SETUP,
+        INIT            = Traits<Machine>::INIT,
+
         APP_LOW         = Traits<Machine>::APP_LOW,
         APP_CODE        = Traits<Machine>::APP_CODE,
         APP_DATA        = Traits<Machine>::APP_DATA,
         APP_HIGH        = Traits<Machine>::APP_HIGH,
+        APP_HEAP        = Traits<Machine>::APP_HEAP,
 
         PHY_MEM         = Traits<Machine>::PHY_MEM,
         IO              = Traits<Machine>::IO_BASE,
 
-        SYS             = Traits<Machine>::NOT_USED,
-        SYS_INFO        = unsigned(-1),                 // Dynamically built during initialization.
-        SYS_CODE        = Traits<Machine>::NOT_USED,
-        SYS_DATA        = Traits<Machine>::NOT_USED,
+        SYS             = Traits<Machine>::SYS,
+        SYS_INFO        = Traits<Machine>::SYS_INFO,
+        SYS_CODE        = Traits<Machine>::SYS_CODE,
+        SYS_DATA        = Traits<Machine>::SYS_DATA,
         SYS_HEAP        = Traits<Machine>::NOT_USED,
         SYS_STACK       = Traits<Machine>::NOT_USED
     };
diff --git a/include/machine/riscv/sifive_e/sifive_e_traits.h b/include/machine/riscv/sifive_e/sifive_e_traits.h
index 9fa9ce7..c8cece4 100644
--- a/include/machine/riscv/sifive_e/sifive_e_traits.h
+++ b/include/machine/riscv/sifive_e/sifive_e_traits.h
@@ -23,34 +23,41 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
 
     // Physical Memory
     static const unsigned int MEM_BASE          = 0x80000000;
-    static const unsigned int VECTOR_TABLE      = NOT_USED;
-    static const unsigned int PAGE_TABLES       = NOT_USED; // No paging MMU
     static const unsigned int MEM_TOP           = 0x87ffffff; // 128 MB
-    static const unsigned int BOOT_STACK        = 0x87ffffff;
+    static const unsigned int MIO_BASE          = 0x00000000;
+    static const unsigned int MIO_TOP           = 0x100081ff;
 
+    static const unsigned int BOOT_STACK        = MEM_TOP;
+    static const unsigned int VECTOR_TABLE      = NOT_USED;
+    static const unsigned int PAGE_TABLES       = MEM_TOP + 1 - 16*1024 - ((544+1)*4*1024);
+    static const unsigned int SYS_INFO          = PAGE_TABLES - 4096; 
+    static const unsigned int MMODE_F           = SYS_INFO - 4096;
+   
     // Logical Memory Map
     static const unsigned int BOOT              = NOT_USED;
-    static const unsigned int SETUP             = NOT_USED;
-    static const unsigned int INIT              = NOT_USED;
-
-    static const unsigned int APP_LOW           = 0x80000000;
-    static const unsigned int APP_CODE          = 0x80000000;
-    static const unsigned int APP_DATA          = 0x80000000;
-    static const unsigned int APP_HIGH          = 0x87ffffff;
-
-    static const unsigned int PHY_MEM           = NOT_USED; // No paging MMU
-    static const unsigned int IO_BASE           = NOT_USED; // No paging MMU
-    static const unsigned int IO_TOP            = NOT_USED; // No paging MMU
-
-    static const unsigned int SYS               = NOT_USED; // No paging MMU
-    static const unsigned int SYS_CODE          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_DATA          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_HEAP          = NOT_USED; // No paging MMU
-    static const unsigned int SYS_STACK         = NOT_USED; // No paging MMU
+    static const unsigned int IMAGE             = NOT_USED;
+    static const unsigned int SETUP             = 0x80000000; // SETUP == NOT_USED ? ELF file is generated for setup : setup is a library
+    static const unsigned int INIT              = 0x80200000;
+
+    static const unsigned int APP_LOW           = 0x88000000;
+    static const unsigned int APP_CODE          = APP_LOW;
+    static const unsigned int APP_DATA          = 0xff800000;
+    static const unsigned int APP_HEAP          = 0xffc00000;
+    static const unsigned int APP_HIGH          = 0xffffffff;
+
+    static const unsigned int PHY_MEM           = NOT_USED;
+    static const unsigned int IO_BASE           = NOT_USED;
+    static const unsigned int IO_TOP            = NOT_USED;
+
+    static const unsigned int SYS               = 0x80300000;
+    static const unsigned int SYS_CODE          = SYS;
+    static const unsigned int SYS_DATA          = 0x80400000;
+    static const unsigned int SYS_HEAP          = NOT_USED;
+    static const unsigned int SYS_STACK         = BOOT_STACK;
 
     // Default Sizes and Quantities
     static const unsigned int STACK_SIZE        = 16 * 1024;
-    static const unsigned int HEAP_SIZE         = 16 * 1024 * 1024;
+    static const unsigned int HEAP_SIZE         = 4 * 1024 * 1024;
     static const unsigned int MAX_THREADS       = 16;
 
     // Clocks
@@ -60,6 +67,7 @@ template <> struct Traits<Machine>: public Traits<Machine_Common>
 template <> struct Traits<IC>: public Traits<Machine_Common>
 {
     static const bool debugged = hysterically_debugged;
+    static const bool enabled = true;
 
     static const unsigned int IRQS = 1024; // PLIC
     static const unsigned int INTS = 1056; // Exceptions + Software + Local + Timer + External
@@ -68,6 +76,7 @@ template <> struct Traits<IC>: public Traits<Machine_Common>
 template <> struct Traits<Timer>: public Traits<Machine_Common>
 {
     static const bool debugged = hysterically_debugged;
+    static const bool enabled = true;
 
     static const unsigned int UNITS = 1;
 
@@ -104,7 +113,7 @@ template<> struct Traits<Serial_Display>: public Traits<Machine_Common>
 
 template<> struct Traits<Scratchpad>: public Traits<Machine_Common>
 {
-    static const bool enabled = false;
+    static const bool enabled = true;
 };
 
 __END_SYS
diff --git a/include/memory.h b/include/memory.h
index b2f8be5..ed73b23 100644
--- a/include/memory.h
+++ b/include/memory.h
@@ -9,10 +9,6 @@ __BEGIN_SYS
 
 class Address_Space: private MMU::Directory
 {
-
-private:
-    using MMU::Directory::activate;
-
 public:
     typedef CPU::Phy_Addr Phy_Addr;
     typedef CPU::Log_Addr Log_Addr;
@@ -23,6 +19,7 @@ public:
     ~Address_Space();
 
     using MMU::Directory::pd;
+    using MMU::Directory::activate;
 
     Log_Addr attach(Segment * seg);
     Log_Addr attach(Segment * seg, const Log_Addr & addr);
@@ -43,8 +40,8 @@ public:
     typedef MMU::Flags Flags;
 
 public:
-    Segment(unsigned int bytes, const Color & color = Color::WHITE, const Flags & flags = Flags::APP);
-    Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
+    Segment(unsigned int bytes, const Flags & flags);
+    // Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags);
     ~Segment();
 
     unsigned int size() const;
diff --git a/include/process.h b/include/process.h
index 5978227..0364c86 100644
--- a/include/process.h
+++ b/include/process.h
@@ -7,6 +7,7 @@
 #include <machine.h>
 #include <utility/queue.h>
 #include <utility/handler.h>
+#include <scheduler.h>
 
 extern "C" { void __exit(); }
 
@@ -16,12 +17,14 @@ class Thread
 {
     friend class Init_First;            // context->load()
     friend class Init_System;           // for init() on CPU != 0
+    friend class Scheduler<Thread>;     // for link()
     friend class Synchronizer_Common;   // for lock() and sleep()
     friend class Alarm;                 // for lock()
     friend class System;                // for init()
+    friend class IC;                    // for link() for priority ceiling
 
 protected:
-    static const bool preemptive = Traits<Thread>::preemptive;
+    static const bool preemptive = Traits<Thread>::Criterion::preemptive;
     static const bool reboot = Traits<System>::reboot;
 
     static const unsigned int QUANTUM = Traits<Thread>::QUANTUM;
@@ -40,26 +43,26 @@ public:
         FINISHING
     };
 
-    // Thread Priority
-    typedef unsigned int Priority;
+    // Thread Scheduling Criterion
+    typedef Traits<Thread>::Criterion Criterion;
     enum {
-        MAIN   = 0,
-        HIGH   = 1,
-        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 4,
-        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
-        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2
+        HIGH    = Criterion::HIGH,
+        NORMAL  = Criterion::NORMAL,
+        LOW     = Criterion::LOW,
+        MAIN    = Criterion::MAIN,
+        IDLE    = Criterion::IDLE
     };
 
     // Thread Queue
-    typedef Ordered_Queue<Thread, Priority> Queue;
+    typedef Ordered_Queue<Thread, Criterion, Scheduler<Thread>::Element> Queue;
 
     // Thread Configuration
     struct Configuration {
-        Configuration(const State & s = READY, const Priority & p = NORMAL, unsigned int ss = STACK_SIZE)
-        : state(s), priority(p), stack_size(ss) {}
+        Configuration(const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+        : state(s), criterion(c), stack_size(ss) {}
 
         State state;
-        Priority priority;
+        Criterion criterion;
         unsigned int stack_size;
     };
 
@@ -78,8 +81,8 @@ public:
 
     int join();
     void pass();
-    void suspend() { suspend(false); }
-    void resume() { resume(false); }
+    void suspend();
+    void resume();
 
     static Thread * volatile self() { return running(); }
     static void yield();
@@ -89,15 +92,15 @@ protected:
     void constructor_prologue(unsigned int stack_size);
     void constructor_epilogue(const Log_Addr & entry, unsigned int stack_size);
 
-    static Thread * volatile running() { return _running; }
+    Criterion & criterion() { return const_cast<Criterion &>(_link.rank()); }
+    Queue::Element * link() { return &_link; }
+
+    static Thread * volatile running() { return _scheduler.chosen(); }
 
     static void lock() { CPU::int_disable(); }
     static void unlock() { CPU::int_enable(); }
     static bool locked() { return CPU::int_disabled(); }
 
-    void suspend(bool locked);
-    void resume(bool unpreemptive);
-
     static void sleep(Queue * q);
     static void wakeup(Queue * q);
     static void wakeup_all(Queue * q);
@@ -105,7 +108,7 @@ protected:
     static void reschedule();
     static void time_slicer(IC::Interrupt_Id interrupt);
 
-    static void dispatch(Thread * prev, Thread * next);
+    static void dispatch(Thread * prev, Thread * next, bool charge = true);
 
     static int idle();
 
@@ -119,14 +122,12 @@ protected:
     Queue * _waiting;
     Thread * volatile _joining;
     Queue::Element _link;
+    
+    volatile Task * _task;
 
     static volatile unsigned int _thread_count;
     static Scheduler_Timer * _timer;
-
-private:
-    static Thread * volatile _running;
-    static Queue _ready;
-    static Queue _suspended;
+    static Scheduler<Thread> _scheduler;
 };
 
 
@@ -141,7 +142,7 @@ inline Thread::Thread(int (* entry)(Tn ...), Tn ... an)
 
 template<typename ... Tn>
 inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
-: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.priority)
+: _state(conf.state), _waiting(0), _joining(0), _link(this, conf.criterion)
 {
     constructor_prologue(conf.stack_size);
     _context = CPU::init_stack(0, _stack + conf.stack_size, &__exit, entry, an ...);
@@ -149,6 +150,22 @@ inline Thread::Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ...
 }
 
 
+// A Java-like Active Object
+class Active: public Thread
+{
+public:
+    Active(): Thread(Configuration(Thread::SUSPENDED), &entry, this) {}
+    virtual ~Active() {}
+
+    virtual int run() = 0;
+
+    void start() { resume(); }
+
+private:
+    static int entry(Active * runnable) { return runnable->run(); }
+};
+
+
 // An event handler that triggers a thread (see handler.h)
 class Thread_Handler : public Handler
 {
@@ -162,6 +179,54 @@ private:
     Thread * _handler;
 };
 
+
+class Task
+{
+private:
+    static const bool multitask = Traits<System>::multitask;
+    typedef CPU::Log_Addr Log_Addr;
+
+public:
+    static volatile Task * _active;
+    Heap * _heap;
+    
+    Task(Segment * cs, Segment * ds)
+    : _as (new (SYSTEM) Address_Space), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    Task(Address_Space * as, Segment * cs, Segment * ds)
+    : _as(as), _cs(cs), _ds(ds), _code(_as->attach(_cs, Memory_Map::APP_CODE)), _data(_as->attach(_ds, Memory_Map::APP_DATA)) {
+        db<Task>(TRC) << "Task(as=" << _as << ",cs=" << _cs << ",ds=" << _ds <<  ",code=" << _code << ",data=" << _data << ") => " << this << endl;
+    }
+    ~Task();
+    
+    static void activate(volatile Task * t) {
+        Task::_active = t;
+        t->_as->activate();
+    }
+    
+    static unsigned int get_active_pd(){
+        return Task::_active->_as->pd();
+    }
+    
+    Address_Space * address_space() const { return _as; }
+
+    Segment * code_segment() const { return _cs; }
+    Segment * data_segment() const { return _ds; }
+
+    Log_Addr code() const { return _code; }
+    Log_Addr data() const { return _data; }
+
+
+private:
+    Address_Space * _as;
+    Segment * _cs;
+    Segment * _ds;
+    Log_Addr _code;
+    Log_Addr _data;
+    
+};
+
 __END_SYS
 
 #endif
diff --git a/include/real-time.h b/include/real-time.h
new file mode 100644
index 0000000..b6a895c
--- /dev/null
+++ b/include/real-time.h
@@ -0,0 +1,137 @@
+// EPOS Real-time Declarations
+
+#ifndef __real_time_h
+#define __real_time_h
+
+#include <utility/handler.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+#include <time.h>
+#include <process.h>
+#include <synchronizer.h>
+
+__BEGIN_SYS
+
+// Aperiodic Thread
+typedef Thread Aperiodic_Thread;
+
+// Periodic threads are achieved by programming an alarm handler to invoke
+// p() on a control semaphore after each job (i.e. task activation). Base
+// threads are created in BEGINNING state, so the scheduler won't dispatch
+// them before the associate alarm and semaphore are created. The first job
+// is dispatched by resume() (thus the _state = SUSPENDED statement)
+
+// Periodic Thread
+class Periodic_Thread: public Thread
+{
+
+protected:
+    // Alarm Handler for periodic threads under static scheduling policies
+    class Static_Handler: public Semaphore_Handler
+    {
+    public:
+        Static_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s) {}
+        ~Static_Handler() {}
+    };
+
+    // Alarm Handler for periodic threads under dynamic scheduling policies
+    class Dynamic_Handler: public Semaphore_Handler
+    {
+    public:
+        Dynamic_Handler(Semaphore * s, Periodic_Thread * t): Semaphore_Handler(s), _thread(t) {}
+        ~Dynamic_Handler() {}
+
+        void operator()() {
+            _thread->criterion().update();
+
+            Semaphore_Handler::operator()();
+        }
+
+    private:
+        Periodic_Thread * _thread;
+    };
+
+    typedef IF<Criterion::dynamic, Dynamic_Handler, Static_Handler>::Result Handler;
+
+public:
+    // struct Configuration: public Thread::Configuration {
+    //     Configuration(const Microsecond & p, const Microsecond & d = SAME, const Microsecond & cap = UNKNOWN, const Microsecond & act = NOW, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = NORMAL, unsigned int ss = STACK_SIZE)
+    //     : Thread::Configuration(s, c, ss), period(p), deadline(d == SAME ? p : d), capacity(cap), activation(act), times(n) {}
+
+    //     Microsecond period;
+    //     Microsecond deadline;
+    //     Microsecond capacity;
+    //     Microsecond activation;
+    //     unsigned int times;
+    // };
+
+struct Configuration {
+        Configuration(const Microsecond & p, const unsigned int n = INFINITE, const State & s = READY, const Criterion & c = HIGH, unsigned int ss = STACK_SIZE)
+        : period(p), times(n), state(s), criterion(p, c), stack_size(ss) {}
+
+        Microsecond period;
+        unsigned int times;
+        State state;
+        Criterion criterion;
+        unsigned int stack_size;
+};
+
+public:
+    // template<typename ... Tn>
+    // Periodic_Thread(const Microsecond & p, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(p)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(p, &_handler, INFINITE) { resume(); }
+    // typedef Alarm::Tick Tick;
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Tick & t, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, Criterion(t)), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(t * Alarm::timer_period(), &_handler, INFINITE) { resume(); }
+
+    // template<typename ... Tn>
+    // Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    // : Thread(Thread::Configuration(SUSPENDED, (conf.criterion != NORMAL) ? conf.criterion : Criterion(conf.period), conf.stack_size), entry, an ...),
+    //   _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+    //     if((conf.state == READY) || (conf.state == RUNNING)) {
+    //         _state = SUSPENDED;
+    //         resume();
+    //     } else
+    //         _state = conf.state;
+    // }
+
+    template<typename ... Tn>
+    Periodic_Thread(const Configuration & conf, int (* entry)(Tn ...), Tn ... an)
+    : Thread(Thread::Configuration(SUSPENDED, conf.criterion, conf.stack_size), entry, an ...),
+      _semaphore(0), _handler(&_semaphore, this), _alarm(conf.period, &_handler, conf.times) {
+        if((conf.state == READY) || (conf.state == RUNNING)) {
+            _state = SUSPENDED;
+            resume();
+        } else
+            _state = conf.state;
+    }
+
+    const Microsecond & period() const { return _alarm.period(); }
+    void period(const Microsecond & p) { _alarm.period(p); }
+
+    static volatile bool wait_next() {
+        Periodic_Thread * t = reinterpret_cast<Periodic_Thread *>(running());
+
+        db<Thread>(TRC) << "Thread::wait_next(this=" << t << ",times=" << t->_alarm.times() << ")" << endl;
+
+        if(t->_alarm.times())
+            t->_semaphore.p();
+
+        return t->_alarm.times();
+    }
+
+protected:
+    Semaphore _semaphore;
+    Handler _handler;
+    Alarm _alarm;
+};
+
+typedef Periodic_Thread::Configuration RTConf;
+
+__END_SYS
+
+#endif
diff --git a/include/scheduler.h b/include/scheduler.h
new file mode 100644
index 0000000..8e8a512
--- /dev/null
+++ b/include/scheduler.h
@@ -0,0 +1,229 @@
+// EPOS Scheduler Component Declarations
+
+#ifndef __scheduler_h
+#define __scheduler_h
+
+#include <architecture/cpu.h>
+#include <architecture/pmu.h>
+#include <architecture/tsc.h>
+#include <utility/scheduling.h>
+#include <utility/math.h>
+#include <utility/convert.h>
+
+__BEGIN_SYS
+
+// All scheduling criteria, or disciplines, must define operator int() with
+// the semantics of returning the desired order of a given object within the
+// scheduling list
+class Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+    friend class _SYS::Clerk<System>;         // for _statistics
+
+public:
+    // Priorities
+    enum : int {
+        MAIN   = 0,
+        HIGH   = 1,
+        NORMAL = (unsigned(1) << (sizeof(int) * 8 - 1)) - 3,
+        LOW    = (unsigned(1) << (sizeof(int) * 8 - 1)) - 2,
+        IDLE   = (unsigned(1) << (sizeof(int) * 8 - 1)) - 1
+    };
+
+    // Constructor helpers
+    enum : unsigned int {
+        SAME        = 0,
+        NOW         = 0,
+        UNKNOWN     = 0,
+        ANY         = -1U
+    };
+
+    // Policy types
+    enum : int {
+        PERIODIC    = HIGH,
+        APERIODIC   = NORMAL,
+        SPORADIC    = NORMAL
+    };
+
+    // Policy traits
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+    static const bool collecting = false;
+    static const bool charging = false;
+    static const bool awarding = false;
+    static const bool migrating = false;
+    static const bool track_idle = false;
+    static const bool task_wide = false;
+    static const bool cpu_wide = false;
+    static const bool system_wide = false;
+    static const unsigned int QUEUES = 1;
+
+    // Runtime Statistics (for policies that don't use any; thats why its a union)
+    union Statistics {
+        // Thread Execution Time
+        TSC::Time_Stamp thread_execution_time;  // accumulated thread execution time
+        TSC::Time_Stamp last_thread_dispatch;   // time stamp of last dispatch
+
+        // Deadline Miss count - Used By Clerk
+        Alarm * alarm_times;                    // pointer to RT_Thread private alarm (for monitoring purposes)
+        unsigned int finished_jobs;             // number of finished jobs given by the number of times alarm->p() was called for this thread
+        unsigned int missed_deadlines;          // number of missed deadlines given by the number of finished jobs (finished_jobs) minus the number of dispatched jobs (alarm_times->times)
+
+        // CPU Execution Time (capture ts)
+        static TSC::Time_Stamp _cpu_time[Traits<Build>::CPUS];              // accumulated CPU time in the current hyperperiod for each CPU
+        static TSC::Time_Stamp _last_dispatch_time[Traits<Build>::CPUS];    // time Stamp of last dispatch in each CPU
+        static TSC::Time_Stamp _last_activation_time;                       // global time stamp of the last heuristic activation
+    };
+
+protected:
+    Scheduling_Criterion_Common() {}
+
+public:
+    const Microsecond period() { return 0;}
+    void period(const Microsecond & p) {}
+
+    unsigned int queue() const { return 0; }
+    void queue(unsigned int q) {}
+
+    bool update() { return false; }
+
+    bool collect(bool end = false) { return false; }
+    bool charge(bool end = false) { return true; }
+    bool award(bool end = false) { return true; }
+
+    volatile Statistics & statistics() { return _statistics; }
+
+    static void init() {}
+
+protected:
+    Statistics _statistics;
+};
+
+// Priority (static and dynamic)
+class Priority: public Scheduling_Criterion_Common
+{
+    friend class _SYS::Thread;
+    friend class _SYS::Periodic_Thread;
+    friend class _SYS::RT_Thread;
+
+public:
+    template <typename ... Tn>
+    Priority(int p = NORMAL, Tn & ... an): _priority(p) {}
+
+    operator const volatile int() const volatile { return _priority; }
+
+protected:
+    volatile int _priority;
+};
+
+// Round-Robin
+class RR: public Priority
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    template <typename ... Tn>
+    RR(int p = NORMAL, Tn & ... an): Priority(p) {}
+};
+
+// First-Come, First-Served (FIFO)
+class FCFS: public Priority
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = false;
+
+public:
+    template <typename ... Tn>
+    FCFS(int p = NORMAL, Tn & ... an);
+};
+
+
+// Real-time Algorithms
+class Real_Time_Scheduler_Common: public Priority
+{
+protected:
+    Real_Time_Scheduler_Common(int p): Priority(p), _deadline(0), _period(0), _capacity(0) {} // aperiodic
+    Real_Time_Scheduler_Common(int i, const Microsecond & d, const Microsecond & p, const Microsecond & c)
+    : Priority(i), _deadline(d), _period(p), _capacity(c) {}
+
+public:
+    const Microsecond period() { return _period; }
+    void period(const Microsecond & p) { _period = p; }
+
+public:
+    Microsecond _deadline;
+    Microsecond _period;
+    Microsecond _capacity;
+};
+
+// Rate Monotonic
+// class RM:public Real_Time_Scheduler_Common
+// {
+// public:
+//     static const bool timed = false;
+//     static const bool dynamic = false;
+//     static const bool preemptive = true;
+
+// public:
+//     RM(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+//     RM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+//     : Real_Time_Scheduler_Common(p ? p : d, d, p, c) {}
+// };
+
+//!SMODE:
+// Rate Monotonic
+class RM: public Priority
+{
+public:
+    static const bool preemptive = true;
+    static const bool timed = true;
+
+public:
+    // used for aperiodic threads
+    RM(int priority): Priority(priority) {}
+
+    // used for periodic threads
+    template <typename ... Tn>
+    RM(const Microsecond & period, int priority, Tn & ... an);
+};
+
+// Deadline Monotonic
+class DM: public Real_Time_Scheduler_Common
+{
+public:
+    static const bool timed = false;
+    static const bool dynamic = false;
+    static const bool preemptive = true;
+
+public:
+    DM(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+    DM(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY)
+    : Real_Time_Scheduler_Common(d, d, p, c) {}
+};
+
+// Earliest Deadline First
+class EDF: public Real_Time_Scheduler_Common
+{
+public:
+    static const bool timed = true;
+    static const bool dynamic = true;
+    static const bool preemptive = true;
+
+public:
+    EDF(int p = APERIODIC): Real_Time_Scheduler_Common(p) {}
+    EDF(const Microsecond & d, const Microsecond & p = SAME, const Microsecond & c = UNKNOWN, unsigned int cpu = ANY);
+
+    void update();
+};
+
+__END_SYS
+
+#endif
diff --git a/include/system/meta.h b/include/system/meta.h
index b5b29aa..09b1572 100644
--- a/include/system/meta.h
+++ b/include/system/meta.h
@@ -213,17 +213,30 @@ public:
 // Serializer
 inline void SERIALIZE(char * buf, int index) {}
 
+// template<typename T>
+// void SERIALIZE(char * buf, int index, T && a) {
+//     __builtin_memcpy(&buf[index], &a, sizeof(T));
+// }
+
 template<typename T>
-void SERIALIZE(char * buf, int index, T && a) {
+void SERIALIZE(char * buf, int index, const T & a) {
     __builtin_memcpy(&buf[index], &a, sizeof(T));
 }
 
+
+// template<typename T, typename ... Tn>
+// void SERIALIZE(char * buf, int index, const T && a, Tn & ... an) {
+//     __builtin_memcpy(&buf[index], &a, sizeof(T));
+//     SERIALIZE(buf, index + sizeof(T), an ...);
+// }
+
 template<typename T, typename ... Tn>
-void SERIALIZE(char * buf, int index, const T && a, Tn & ... an) {
+void SERIALIZE(char * buf, int index, const T & a, const Tn & ... an) {
     __builtin_memcpy(&buf[index], &a, sizeof(T));
     SERIALIZE(buf, index + sizeof(T), an ...);
 }
 
+
 // Deserializer
 inline void DESERIALIZE(char * buf, int index) {}
 
diff --git a/include/system/types.h b/include/system/types.h
index 8d29259..0c58488 100644
--- a/include/system/types.h
+++ b/include/system/types.h
@@ -158,17 +158,18 @@ enum
 {
     FIRST_COMPONENT_ID = 0,
     THREAD_ID = FIRST_COMPONENT_ID,
-    TASK_ID,
-    ACTIVE_ID,
-    ADDRESS_SPACE_ID,
-    SEGMENT_ID,
+    DISPLAY_ID,
+    // TASK_ID,
+    // ACTIVE_ID,
+    // ADDRESS_SPACE_ID,
+    // SEGMENT_ID,
     MUTEX_ID,
     SEMAPHORE_ID,
     CONDITION_ID,
     CLOCK_ID,
     ALARM_ID,
     CHRONOMETER_ID,
-    IPC_COMMUNICATOR_ID,
+    // IPC_COMMUNICATOR_ID,
     UTILITY_ID,
     LAST_COMPONENT_ID,
 
@@ -187,7 +188,7 @@ enum
     EEPROM_ID,
     SCRATCHPAD_ID,
     UART_ID,
-    DISPLAY_ID,
+    // DISPLAY_ID,
     KEYBOARD_ID,
     NIC_ID,
     LAST_MEDIATOR_ID,
@@ -221,11 +222,11 @@ template<> struct Type<IEEE802_15_4> { static const Type_Id ID = NIC_ID; };
 template<> struct Type<Thread> { static const Type_Id ID = THREAD_ID; };
 template<> struct Type<Periodic_Thread> { static const Type_Id ID = THREAD_ID; };
 template<> struct Type<RT_Thread> { static const Type_Id ID = THREAD_ID; };
-template<> struct Type<Active> { static const Type_Id ID = ACTIVE_ID; };
-template<> struct Type<Task> { static const Type_Id ID = TASK_ID; };
+// template<> struct Type<Active> { static const Type_Id ID = ACTIVE_ID; };
+// template<> struct Type<Task> { static const Type_Id ID = TASK_ID; };
 
-template<> struct Type<Address_Space> { static const Type_Id ID = ADDRESS_SPACE_ID; };
-template<> struct Type<Segment> { static const Type_Id ID = SEGMENT_ID; };
+// template<> struct Type<Address_Space> { static const Type_Id ID = ADDRESS_SPACE_ID; };
+// template<> struct Type<Segment> { static const Type_Id ID = SEGMENT_ID; };
 
 template<> struct Type<Mutex> { static const Type_Id ID = MUTEX_ID; };
 template<> struct Type<Semaphore> { static const Type_Id ID = SEMAPHORE_ID; };
diff --git a/include/time.h b/include/time.h
index a024cb7..fc390cd 100644
--- a/include/time.h
+++ b/include/time.h
@@ -23,7 +23,7 @@ public:
     Second now() { return RTC::seconds_since_epoch(); }
 
     Date date() { return RTC::date(); }
-    void date(const Date & d) { return RTC::date(d); }
+    void date(const Date & d) {  RTC::date(d); }
 };
 
 
@@ -31,7 +31,10 @@ class Alarm
 {
     friend class System;                        // for init()
     friend class Alarm_Chronometer;             // for elapsed()
+    friend class Periodic_Thread;               // for ticks(), times(), and elapsed()
     friend class FCFS;                          // for ticks() and elapsed()
+    friend class EDF;                           // for ticks() and elapsed()
+    friend class RM;                            // for ticks()
 
 private:
     typedef Timer_Common::Tick Tick;
@@ -51,18 +54,18 @@ public:
     static void delay(const Microsecond & time);
 
 private:
-    static void init();
-
-    static volatile Tick & elapsed() { return _elapsed; }
-
-    static Microsecond timer_period() { return 1000000 / frequency(); }
     static Tick ticks(const Microsecond & time) { return (time + timer_period() / 2) / timer_period(); }
+    static Microsecond timer_period() { return 1000000 / frequency(); }
+    static volatile Tick & elapsed() { return _elapsed; }
+    unsigned int times() const { return _times; }
 
     static void lock();
     static void unlock();
 
     static void handler(IC::Interrupt_Id i);
 
+    static void init();
+
 private:
     Microsecond _time;
     Handler * _handler;
@@ -88,10 +91,10 @@ private:
 
 class TSC_Chronometer
 {
-private:
-    typedef TSC::Time_Stamp Time_Stamp;
+// private:
 
 public:
+    typedef TSC::Time_Stamp Time_Stamp;
     TSC_Chronometer() : _start(0), _stop(0) {}
 
     Hertz frequency() { return tsc.frequency(); }
@@ -102,8 +105,6 @@ public:
     void stop() { lap(); }
 
     Microsecond read() { return ticks() * 1000000 / frequency(); }
-
-private:
     Time_Stamp ticks() {
         if(_start == 0)
             return 0;
@@ -112,6 +113,8 @@ private:
         return _stop - _start;
     }
 
+private:
+
 private:
     TSC tsc;
     Time_Stamp _start;
@@ -121,10 +124,10 @@ private:
 
 class Alarm_Chronometer
 {
-private:
-    typedef Alarm::Tick Time_Stamp;
+// private:
 
 public:
+    typedef Alarm::Tick Time_Stamp;
     Alarm_Chronometer() : _start(0), _stop(0) {}
 
     Hertz frequency() { return Alarm::frequency(); }
@@ -137,8 +140,6 @@ public:
     // The parenthesis reduces precision even more, but avoids overflow
     // Casting to LARGER<Ticks> would provide resolution for intermediate calculations, but it is very inefficient on most microcontrollers
     Microsecond read() { return ticks() * (1000000 / frequency()); }
-
-private:
     Time_Stamp ticks() {
         if(_start == 0)
             return 0;
diff --git a/include/utility/elf.h b/include/utility/elf.h
index 0ef4158..df2b4b5 100644
--- a/include/utility/elf.h
+++ b/include/utility/elf.h
@@ -31,7 +31,7 @@ public:
         : seg(i)->p_align ? seg(i)->p_vaddr
         : (seg(i)->p_vaddr & ~(seg(i)->p_align - 1));
     }
-
+    
     int segment_size(int i) {
         return (i > segments()) ? -1 : (int)(
             ((seg(i)->p_offset % seg(i)->p_align)
diff --git a/include/utility/heap.h b/include/utility/heap.h
index f377454..57fd84b 100644
--- a/include/utility/heap.h
+++ b/include/utility/heap.h
@@ -18,6 +18,9 @@ protected:
 public:
     using Grouping_List<char>::empty;
     using Grouping_List<char>::size;
+    using Grouping_List<char>::search_decrementing;
+    using Grouping_List<char>::find_first;
+    using Grouping_List<char>::find_worst;
 
     Heap() {
         db<Init, Heaps>(TRC) << "Heap() => " << this << endl;
@@ -30,8 +33,7 @@ public:
     }
 
     void * alloc(unsigned int bytes) {
-        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes;
-
+        db<Heaps>(TRC) << "Heap::alloc(this=" << this << ",bytes=" << bytes << endl;
         if(!bytes)
             return 0;
 
@@ -45,6 +47,8 @@ public:
         if(bytes < sizeof(Element))
             bytes = sizeof(Element);
 
+        db<Heaps>(TRC) << "First Fit: " << find_first(bytes) << endl;
+        db<Heaps>(TRC) << "Worst Fit: " << find_worst(bytes) << endl;
         Element * e = search_decrementing(bytes);
         if(!e) {
             out_of_memory();
@@ -65,7 +69,7 @@ public:
     void free(void * ptr, unsigned int bytes) {
         db<Heaps>(TRC) << "Heap::free(this=" << this << ",ptr=" << ptr << ",bytes=" << bytes << ")" << endl;
 
-        if(ptr && (bytes >= sizeof(Element))) {
+        if(ptr && (bytes >= sizeof(Element))) { // cant merge if bytes < sizeof(Element)?
             Element * e = new (ptr) Element(reinterpret_cast<char *>(ptr), bytes);
             Element * m1, * m2;
             insert_merging(e, &m1, &m2);
diff --git a/include/utility/list.h b/include/utility/list.h
index ccc8954..eca1174 100644
--- a/include/utility/list.h
+++ b/include/utility/list.h
@@ -1348,7 +1348,7 @@ public:
 
     Element * search_size(unsigned int s) {
         Element * e = head();
-        if(sizeof(Object_Type) < sizeof(Element))
+        if(sizeof(Object_Type) < sizeof(Element)) // isnt this requiring sizeof(Element) twice?
             for(; e && (e->size() < sizeof(Element) / sizeof(Object_Type) + s) && (e->size() != s); e = e->next());
         else
             for(; e && (e->size() < s); e = e->next());
@@ -1381,7 +1381,7 @@ public:
         print_head();
         print_tail();
 
-        Element * e = search_size(s);
+        Element * e = find_worst(s);
         if(e) {
             e->shrink(s);
             _grouped_size -= s;
@@ -1392,6 +1392,33 @@ public:
         return e;
     }
 
+    // Used by Heap/Worst-Fit
+    // for empty lists, return 0
+    // for nonempty lists,
+    //      return 0 if there is no element big enough to fit s
+    //      return the element with biggest size otherwise
+    // precons:
+    //  1. s >= sizeof(Element) [s >= 16]
+    Element * find_worst(unsigned int s) {
+        Element * max = 0;
+        unsigned max_size = 0;
+        for(Element * e = head(); e; e = e->next()) {
+            if (e->size() > max_size) {
+                max_size = e->size();
+                max = e;
+            }
+        }
+
+        if (max_size < s)
+            return 0;
+
+        return max;
+    }
+
+    Element * find_first(unsigned int s) {
+        return search_size(s);
+    }
+
 private:
     Element * search_left(const Object_Type * obj) {
         Element * e = head();
diff --git a/makedefs b/makedefs
index 21674d9..cb9cfb2 100644
--- a/makedefs
+++ b/makedefs
@@ -86,6 +86,7 @@ MEM_SIZE                = $(shell $(BIN)/eposcfg MEM_SIZE_KB 2> /dev/null)
 BOOT_ADDR               = $(shell $(BIN)/eposcfg BOOT 2> /dev/null)
 SETUP_ADDR              = $(shell $(BIN)/eposcfg SETUP 2> /dev/null)
 INIT_ADDR               = $(shell $(BIN)/eposcfg INIT 2> /dev/null)
+MMODE_F                 = $(shell $(BIN)/eposcfg MMODE_F 2> /dev/null)
 SYS_CODE_ADDR           = $(shell $(BIN)/eposcfg SYS_CODE 2> /dev/null)
 SYS_DATA_ADDR           = $(shell $(BIN)/eposcfg SYS_DATA 2> /dev/null)
 UUID                    = $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g')
@@ -103,7 +104,7 @@ pc_CC_FLAGS		:= -m32 -Wa,--32
 pc_AS_FLAGS		:= --32
 pc_LD_FLAGS		:= -m elf_i386
 pc_EMULATOR		= qemu-system-i386 -smp $(CPUS) -m $(MEM_SIZE)k -nographic -no-reboot -drive format=raw,index=0,if=floppy,read-only,file=
-pc_DEBUGGER		:= gdb
+pc_DEBUGGER		:= gdb -tui
 pc_FLASHER		:=
 pc_MAGIC		:= --nmagic
 pc_CODE_NAME		:= .init
@@ -114,7 +115,7 @@ ifeq ($(MMOD),realview_pbx)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine realview-pbx-a9 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -126,7 +127,7 @@ endif
 ifeq ($(MMOD),zynq)
 cortex_CC_FLAGS		:= -mcpu=cortex-a9
 cortex_AS_FLAGS		:= -mcpu=cortex-a9
-cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine xilinx-zynq-a9  -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -139,7 +140,7 @@ ifeq ($(MMOD),raspberry_pi3)
 cortex_CC_FLAGS		:= -mcpu=cortex-a53 -mfloat-abi=hard -mfpu=vfp
 cortex_AS_FLAGS		:= -mcpu=cortex-a53
 cortex_LD_FLAGS		:=
-cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-aarch64 -machine type=virt -cpu cortex-a53 -smp $(CPUS) -m $(MEM_SIZE)k -serial null -serial mon:stdio -nographic -no-reboot -kernel
 cortex_DEBUGGER		:= arm-none-eabi-gdb
 cortex_FLASHER		= $(TLS)/eposflash/eposflash-$(MMOD) -d /dev/ttyACM0 -f
 cortex_MAGIC		:= --omagic
@@ -149,7 +150,7 @@ cortex_IMG_SUFFIX	:= .bin
 endif
 
 ifeq ($(MMOD),lm3s811)
-cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel 
+cortex_EMULATOR		= qemu-system-arm -machine lm3s811evb -m $(MEM_SIZE)k -serial mon:stdio -serial null -nographic -no-reboot -kernel
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -162,7 +163,7 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),emote3)
-cortex_EMULATOR		= 
+cortex_EMULATOR		=
 cortex_CC_FLAGS		:= -mcpu=cortex-m3 -mthumb -mabi=atpcs
 cortex_AS_FLAGS		:= -mcpu=cortex-m3 -mthumb -meabi=gnu
 cortex_LD_FLAGS		:=
@@ -175,25 +176,26 @@ cortex_IMG_SUFFIX	:= .img
 endif
 
 ifeq ($(MMOD),sifive_e)
-riscv_CC_FLAGS          := -Wl, -mno-relax
-riscv_AS_FLAGS          := 
+riscv_CC_FLAGS          := -Wl, -mno-relax -march='rv32g'
+riscv_AS_FLAGS          :=
 riscv_LD_FLAGS          := --no-relax
-riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+# riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_EMULATOR			= qemu-system-riscv32 -machine virt -cpu rv32gcsu-v1.10.0 -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -device loader,force-raw=on,addr=0x80000000,file=
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --nmagic
-riscv_CODE_NAME := .init
-riscv_DATA_NAME :=
+riscv_CODE_NAME 		:= .init
+riscv_DATA_NAME 		:= .sdata
 riscv_IMG_SUFFIX        := .img
 endif
 
 ifeq ($(MMOD),sifive_u)
 riscv_CC_FLAGS          := -mcmodel=medany
-riscv_AS_FLAGS          := 
-riscv_LD_FLAGS          := 
-riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel 
+riscv_AS_FLAGS          :=
+riscv_LD_FLAGS          :=
+riscv_EMULATOR          = qemu-system-riscv64 -machine virt -smp $(CPUS) -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot -kernel
 riscv_DEBUGGER          := $(COMP_PREFIX)gdb
-riscv_FLASHER           := 
+riscv_FLASHER           :=
 riscv_MAGIC             := --omagic
 riscv_CODE_NAME := .init
 riscv_DATA_NAME :=
@@ -212,13 +214,13 @@ atmega_DATA_NAME	:= .data
 atmega_IMG_SUFFIX	:= .hex
 
 MACH_CC_FLAGS           := $($(MACH)_CC_FLAGS) -O -nostdinc -fno-stack-protector -fno-pie -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-address-of-packed-member
-MACH_CXX_FLAGS          := $($(MACH)_CC_FLAGS) -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit --no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-attribute-alias -Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member
+MACH_CXX_FLAGS          := $($(MACH)_CC_FLAGS) -O -std=c++14 -nostdinc --no-exceptions --no-rtti --no-use-cxa-atexit --no-asynchronous-unwind-tables -fno-stack-protector -fno-pie -fdata-sections -ffunction-sections -Wall -Werror -Wno-builtin-declaration-mismatch -Wno-array-bounds -Wno-attribute-alias -Wno-placement-new -Wno-class-memaccess -Wno-address-of-packed-member -Wattributes
 MACH_AS_FLAGS           := $($(MACH)_AS_FLAGS)
 MACH_LD_FLAGS           := $($(MACH)_LD_FLAGS)
 MACH_CODE_NAME          := $($(MACH)_CODE_NAME)
 MACH_DATA_NAME          := $($(MACH)_DATA_NAME)
-MACH_EMULATOR           := $($(MACH)_EMULATOR)
-MACH_DEBUGGER           := $(TERM) $($(MACH)_DEBUGGER) -ex "target remote:1235" -ex "set confirm off"
+MACH_EMULATOR           := $(TERM) $($(MACH)_EMULATOR)
+MACH_DEBUGGER           := $(TERM) $($(MACH)_DEBUGGER) -ex "target remote:1236" -ex "set confirm off"
 MACH_FLASHER            := $($(MACH)_FLASHER)
 MACH_MAGIC              := $($(MACH)_MAGIC)
 MACH_IMGSUFF            := $($(MACH)_IMG_SUFFIX)
@@ -227,7 +229,7 @@ ifeq ($(DEBUG),1)
 MACH_CC_FLAGS		:= -g -feliminate-unused-debug-symbols $(MACH_CC_FLAGS)
 MACH_CXX_FLAGS          := -g -feliminate-unused-debug-symbols $(MACH_CXX_FLAGS)
 MACH_AS_FLAGS		:= -g $(MACH_AS_FLAGS)
-MACH_EMULATOR           := $(subst -m ,-gdb tcp::1235 -S -m ,$(MACH_EMULATOR))
+MACH_EMULATOR           := $(subst -m ,-gdb tcp::1236 -S -m ,$(MACH_EMULATOR))
 endif
 
 # Architecture specifics
@@ -251,10 +253,10 @@ TLD		:= gcc
 TLDFLAGS	:= -m32
 
 # Tools and flags to compile applications
-ACC		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
+ACC		= $(BIN)/eposcc --echo $(MACH_CC_FLAGS)  -c -ansi -O
 ACXX		= $(BIN)/eposcc $(MACH_CXX_FLAGS) -c -ansi -O
 AF77		= $(BIN)/eposcc $(MACH_CC_FLAGS)  -c -ansi -O
-ALD		= $(BIN)/eposcc --$(SMOD) --no-warn-mismatch 
+ALD		= $(BIN)/eposcc --echo --$(SMOD) --no-warn-mismatch
 ALDFLAGS	:= --gc-sections $(MACH_MAGIC)
 
 # Tools and flags to compile the system
@@ -306,7 +308,7 @@ OBJDUMPFLAGS	:=
 
 SHELL		:= bash
 
-STRIP		= $(COMP_PREFIX)strip -R .note -R .comment
+STRIP		= $(COMP_PREFIX)strip -R .note -R .comment --strip-debug
 
 TCPDUMP		:= tcpdump -tttttennvvvXXr
 
@@ -315,7 +317,7 @@ TEE		:= tee
 ifndef DISPLAY
 TERM        := sh -c
 else
-TERM        := xterm -e
+TERM        := konsole -e
 endif
 
 TOUCH		:= touch
@@ -360,8 +362,11 @@ lib%.o: lib%.cc
 (%.o): %.o
 		$(AR) $(ARFLAGS) $@ $^
 
+# %.img: %
+# 		$(MKBI) $@ $<
+
 %.img: %
-		$(MKBI) $@ $<
+		$(MKBI) $@  philosophers_dinner hello_usr
 
 %.hex: %
 		$(OBJCOPY) -I elf32-$(ARCH_ENDIANESS) -O ihex $< $<.tmp
diff --git a/makefile b/makefile
index a35fe1f..7ef66bd 100644
--- a/makefile
+++ b/makefile
@@ -2,7 +2,16 @@
 
 include makedefs
 
+ifndef APPS
 SUBDIRS	:= etc tools src app img
+else
+SUBDIRS := etc tools src
+export APPS
+ifndef APPLICATION
+export APPLICATION=$(word 1, $(APPS))
+endif
+endif
+
 
 all: FORCE
 ifndef APPLICATION
@@ -12,6 +21,9 @@ else
 endif
 
 all1: $(SUBDIRS)
+ifdef APPS
+	$(foreach app,$(APPS), (cd $(APP) && $(MAKE) APPLICATION=$(app));)
+endif
 
 $(SUBDIRS): FORCE
 		(cd $@ && $(MAKE))
@@ -20,10 +32,11 @@ run: FORCE
 ifndef APPLICATION
 		$(foreach app,$(APPLICATIONS),$(MAKE) APPLICATION=$(app) prerun_$(app) run1;)
 else
-		$(MAKE) run1
+		$(MAKE) all1 run1
 endif
 
-run1: etc img/$(APPLICATION)$(MACH_IMGSUFF)
+run1: FORCE
+		(cd img && $(MKBI) $(word 1, $(APPS)).img $(addprefix $(IMG)/,$(APPS)))
 		(cd img && $(MAKE) run1)
 		
 img/$(APPLICATION)$(MACH_IMGSUFF):
@@ -36,7 +49,8 @@ else
 		$(MAKE) DEBUG=1 all1 debug1
 endif
 
-debug1: etc img/$(APPLICATION)$(MACH_IMGSUFF)
+debug1: FORCE
+		(cd img && $(MKBI) $(word 1, $(APPS)).img $(addprefix $(IMG)/,$(APPS)))
 		(cd img && $(MAKE) DEBUG=1 debug)
 
 flash: FORCE
diff --git a/src/api/alarm.cc b/src/api/alarm.cc
index 3352a3a..60897ff 100644
--- a/src/api/alarm.cc
+++ b/src/api/alarm.cc
@@ -25,6 +25,7 @@ Alarm::Alarm(const Microsecond & time, Handler * handler, unsigned int times)
         _request.insert(&_link);
         unlock();
     } else {
+        assert(times == 1);
         unlock();
         (*handler)();
     }
@@ -122,7 +123,8 @@ void Alarm::handler(IC::Interrupt_Id i)
     unlock();
 
     if(alarm) {
-        db<Alarm>(TRC) << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->handler) << ")" << endl;
+        db<Alarm>(TRC) << "Alarm::handler(this=" << alarm << ",e=" << _elapsed << ",h=" << reinterpret_cast<void*>(alarm->_handler) << ")" << endl;
+        ASM("alarm_bk:");
         (*alarm->_handler)();
     }
 }
diff --git a/src/api/scheduler.cc b/src/api/scheduler.cc
new file mode 100644
index 0000000..a11e07e
--- /dev/null
+++ b/src/api/scheduler.cc
@@ -0,0 +1,35 @@
+// EPOS CPU Scheduler Component Implementation
+
+#include <process.h>
+#include <time.h>
+
+__BEGIN_SYS
+
+// The following Scheduling Criteria depend on Alarm, which is not available at scheduler.h
+template <typename ... Tn>
+FCFS::FCFS(int p, Tn & ... an): Priority((p == IDLE) ? IDLE : Alarm::elapsed()) {}
+
+EDF::EDF(const Microsecond & d, const Microsecond & p, const Microsecond & c, unsigned int): Real_Time_Scheduler_Common(Alarm::ticks(d), Alarm::ticks(d), p, c) {}
+
+void EDF::update() {
+    if((_priority >= PERIODIC) && (_priority < APERIODIC))
+        _priority = Alarm::elapsed() + _deadline;
+}
+
+// Since the definition of FCFS above is only known to this unit, forcing its instantiation here so it gets emitted in scheduler.o for subsequent linking with other units is necessary.
+template FCFS::FCFS<>(int p);
+
+template <typename ... Tn>
+RM::RM(const Microsecond & period, int priority, Tn & ... an) {
+    if(priority == HIGH) {
+        _priority = HIGH + Alarm::ticks(period);
+    }else {
+        _priority = priority;
+    }
+
+     db<Init>(TRC) << "_priority=" << _priority << endl;
+}
+
+template RM::RM<>(const Microsecond & period, int priority);
+
+__END_SYS
diff --git a/src/api/segment.cc b/src/api/segment.cc
index 9ae9b96..8ef60ff 100644
--- a/src/api/segment.cc
+++ b/src/api/segment.cc
@@ -5,19 +5,25 @@
 __BEGIN_SYS
 
 // Methods
-Segment::Segment(unsigned int bytes, const Color & color, const Flags & flags): Chunk(bytes, flags, color)
+Segment::Segment(unsigned int bytes, const Flags & flags): Chunk(bytes, flags)
 {
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",color=" << color << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
 }
 
 
-Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags | Flags::IO)
-// The MMU::IO flag signalizes the MMU that the attached memory shall
-// not be released when the chunk is deleted
-{
-    db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
-}
+// Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags | Flags::IO)
+// // The MMU::IO flag signalizes the MMU that the attached memory shall
+// // not be released when the chunk is deleted
+// {
+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+// }
 
+// Segment::Segment(const Phy_Addr & phy_addr, unsigned int bytes, const Flags & flags): Chunk(phy_addr, bytes, flags)
+// // The MMU::IO flag signalizes the MMU that the attached memory shall
+// // not be released when the chunk is deleted
+// {
+//     db<Segment>(TRC) << "Segment(bytes=" << bytes << ",phy_addr=" << phy_addr << ",flags=" << flags << ") [Chunk::_pt=" << Chunk::pt() << "] => " << this << endl;
+// }
 
 Segment::~Segment()
 {
@@ -31,10 +37,10 @@ unsigned int Segment::size() const
 }
 
 
-Segment::Phy_Addr Segment::phy_address() const
-{
-    return Chunk::phy_address();
-}
+// Segment::Phy_Addr Segment::phy_address() const
+// {
+//     return Chunk::phy_address();
+// }
 
 
 int Segment::resize(int amount)
diff --git a/src/api/thread.cc b/src/api/thread.cc
index fdd0583..ee7fb5c 100644
--- a/src/api/thread.cc
+++ b/src/api/thread.cc
@@ -11,22 +11,31 @@ __END_UTIL
 
 __BEGIN_SYS
 
-extern "C" { void __epos_app_entry(); }
-
 volatile unsigned int Thread::_thread_count;
+volatile Task * Task::_active;
 Scheduler_Timer * Thread::_timer;
+Scheduler<Thread> Thread::_scheduler;
 
-Thread* volatile Thread::_running;
-Thread::Queue Thread::_ready;
-Thread::Queue Thread::_suspended;
 
 void Thread::constructor_prologue(unsigned int stack_size)
 {
     lock();
-
+    
+    _task = Task::_active;
     _thread_count++;
-
-    _stack = new (SYSTEM) char[stack_size];
+    _scheduler.insert(this);
+
+    // The main stack is statically allocated right bellow its Heap (at the last addresses of APP_DATA).
+    // After Init_Application, newly created Threads will have their stacks located at the App's Heap.
+    // Lastly, the first application has an extra stack for the idle Thread.
+    if (this->_link.rank() == MAIN) {
+        _stack =  reinterpret_cast<char *>(Traits<Application>::APP_HEAP - 4 - (16 * 1024)); 
+    } else if (this->_link.rank() == IDLE) {
+        _stack = new (SYSTEM) char[stack_size];
+    } else {
+        // _task->_heap->alloc(stack_size);
+        _stack = reinterpret_cast<char *>(_task->_heap->alloc(stack_size));
+    }
 }
 
 
@@ -42,13 +51,8 @@ void Thread::constructor_epilogue(const Log_Addr & entry, unsigned int stack_siz
 
     assert((_state != WAITING) && (_state != FINISHING)); // Invalid states
 
-    switch(_state) {
-        case RUNNING: assert(entry == __epos_app_entry); break;
-        case READY: _ready.insert(&_link); break;
-        case SUSPENDED: _suspended.insert(&_link); break;
-        case WAITING: break;   // invalid state, for switch completion only
-        case FINISHING: break; // invalid state, for switch completion only
-    }
+    if((_state != READY) && (_state != RUNNING))
+        _scheduler.suspend(this);
 
     if(preemptive && (_state == READY) && (_link.rank() != IDLE))
         reschedule();
@@ -76,15 +80,18 @@ Thread::~Thread()
         exit(-1);
         break;
     case READY:
-        _ready.remove(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case SUSPENDED:
-        _suspended.remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case WAITING:
         _waiting->remove(this);
+        _scheduler.resume(this);
+        _scheduler.remove(this);
         _thread_count--;
         break;
     case FINISHING: // Already called exit()
@@ -100,6 +107,26 @@ Thread::~Thread()
 }
 
 
+void Thread::priority(const Priority & c)
+{
+    lock();
+
+    db<Thread>(TRC) << "Thread::priority(this=" << this << ",prio=" << c << ")" << endl;
+
+    _link.rank(Criterion(c));
+
+    if(_state != RUNNING) { // reorder the scheduling queue
+        _scheduler.remove(this);
+        _scheduler.insert(this);
+    }
+
+    if(preemptive)
+        reschedule();
+
+    unlock();
+}
+
+
 int Thread::join()
 {
     lock();
@@ -113,10 +140,18 @@ int Thread::join()
     assert(!_joining);
 
     if(_state != FINISHING) {
-        _joining = running();
-        _joining->suspend(true);
-    } else
-        unlock();
+        Thread * prev = running();
+
+        _joining = prev;
+        prev->_state = SUSPENDED;
+        _scheduler.suspend(prev); // implicitly choose() if suspending chosen()
+
+        Thread * next = _scheduler.chosen();
+
+        dispatch(prev, next);
+    }
+
+    unlock();
 
     return *reinterpret_cast<int *>(_stack);
 }
@@ -128,56 +163,48 @@ void Thread::pass()
 
     db<Thread>(TRC) << "Thread::pass(this=" << this << ")" << endl;
 
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
-
-    _ready.remove(this);
-    _state = RUNNING;
-    _running = this;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose(this);
 
-    dispatch(prev, this);
+    if(next)
+        dispatch(prev, next, false);
+    else
+        db<Thread>(WRN) << "Thread::pass => thread (" << this << ") not ready!" << endl;
 
     unlock();
 }
 
 
-void Thread::suspend(bool locked)
+void Thread::suspend()
 {
-    if(!locked)
-        lock();
+    lock();
 
     db<Thread>(TRC) << "Thread::suspend(this=" << this << ")" << endl;
 
-    if(_running != this)
-        _ready.remove(this);
+    Thread * prev = running();
 
     _state = SUSPENDED;
-    _suspended.insert(&_link);
+    _scheduler.suspend(this);
 
-    if(_running == this) {
-        _running = _ready.remove()->object();
-        _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-        dispatch(this, _running);
-    }
+    dispatch(prev, next);
 
     unlock();
 }
 
 
-void Thread::resume(bool unpreemptive)
+void Thread::resume()
 {
     lock();
 
     db<Thread>(TRC) << "Thread::resume(this=" << this << ")" << endl;
 
     if(_state == SUSPENDED) {
-        _suspended.remove(this);
         _state = READY;
-        _ready.insert(&_link);
+        _scheduler.resume(this);
 
-        if(preemptive && !unpreemptive)
+        if(preemptive)
             reschedule();
     } else
         db<Thread>(WRN) << "Resume called for unsuspended object!" << endl;
@@ -191,16 +218,12 @@ void Thread::yield()
 {
     lock();
 
-    db<Thread>(TRC) << "Thread::yield(running=" << _running << ")" << endl;
-
-    Thread * prev = _running;
-    prev->_state = READY;
-    _ready.insert(&prev->_link);
+    db<Thread>(TRC) << "Thread::yield(running=" << running() << ")" << endl;
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * prev = running();
+    Thread * next = _scheduler.choose_another();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -212,23 +235,22 @@ void Thread::exit(int status)
 
     db<Thread>(TRC) << "Thread::exit(status=" << status << ") [running=" << running() << "]" << endl;
 
-    Thread * prev = _running;
+    Thread * prev = running();
+    _scheduler.remove(prev);
     prev->_state = FINISHING;
     *reinterpret_cast<int *>(prev->_stack) = status;
 
     _thread_count--;
 
     if(prev->_joining) {
-        Thread * joining = prev->_joining;
+        prev->_joining->_state = READY;
+        _scheduler.resume(prev->_joining);
         prev->_joining = 0;
-        joining->resume(true);
-        lock();
     }
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.choose(); // at least idle will always be there
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 
     unlock();
 }
@@ -241,14 +263,14 @@ void Thread::sleep(Queue * q)
     assert(locked()); // locking handled by caller
 
     Thread * prev = running();
+    _scheduler.suspend(prev);
     prev->_state = WAITING;
     prev->_waiting = q;
     q->insert(&prev->_link);
 
-    _running = _ready.remove()->object();
-    _running->_state = RUNNING;
+    Thread * next = _scheduler.chosen();
 
-    dispatch(prev, _running);
+    dispatch(prev, next);
 }
 
 
@@ -262,7 +284,7 @@ void Thread::wakeup(Queue * q)
         Thread * t = q->remove()->object();
         t->_state = READY;
         t->_waiting = 0;
-        _ready.insert(&t->_link);
+        _scheduler.resume(t);
 
         if(preemptive)
             reschedule();
@@ -281,7 +303,7 @@ void Thread::wakeup_all(Queue * q)
             Thread * t = q->remove()->object();
             t->_state = READY;
             t->_waiting = 0;
-            _ready.insert(&t->_link);
+            _scheduler.resume(t);
         }
 
         if(preemptive)
@@ -292,32 +314,65 @@ void Thread::wakeup_all(Queue * q)
 
 void Thread::reschedule()
 {
-    yield();
-}
+    if(!Criterion::timed || Traits<Thread>::hysterically_debugged)
+        db<Thread>(TRC) << "Thread::reschedule()" << endl;
 
+    assert(locked()); // locking handled by caller
+
+    Thread * prev = running();
+    Thread * next = _scheduler.choose();
+
+    dispatch(prev, next);
+}
 
 void Thread::time_slicer(IC::Interrupt_Id i)
 {
+    lock();
     reschedule();
+    unlock();
 }
 
 
-void Thread::dispatch(Thread * prev, Thread * next)
+void Thread::dispatch(Thread * prev, Thread * next, bool charge)
 {
+    // "next" is not in the scheduler's queue anymore. It's already "chosen"
+
+    if(charge) {
+        if(Criterion::timed)
+            _timer->restart();
+    }
+
     if(prev != next) {
-        assert(prev->_state != RUNNING);
-        assert(next->_state == RUNNING);
+        if(prev->_state == RUNNING)
+            prev->_state = READY;
+        next->_state = RUNNING;
 
         db<Thread>(TRC) << "Thread::dispatch(prev=" << prev << ",next=" << next << ")" << endl;
         db<Thread>(INF) << "prev={" << prev << ",ctx=" << *prev->_context << "}" << endl;
         db<Thread>(INF) << "next={" << next << ",ctx=" << *next->_context << "}" << endl;
-
+        
+        unsigned int change_satp = 0;
+        unsigned int new_satp = 0;
+        // if(prev->_task != next->_task){
+        //     Task::activate(next->_task);
+        // }
+        
+        if(prev->_task != next->_task){
+            ASM("change_addr:");
+            change_satp = 1;
+            Task::_active = next->_task;
+            new_satp = Task::get_active_pd() >> 12; //12 or 10?
+            new_satp |= 1 << 31;
+        }
+        
+        db<Thread>(TRC) << "Thread::dispatch(change_satp=" << change_satp << ",new_satp=" << hex << new_satp << ")" << endl;
+        
         // The non-volatile pointer to volatile pointer to a non-volatile context is correct
         // and necessary because of context switches, but here, we are locked() and
         // passing the volatile to switch_constext forces it to push prev onto the stack,
         // disrupting the context (it doesn't make a difference for Intel, which already saves
         // parameters on the stack anyway).
-        CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context);
+        CPU::switch_context(const_cast<Context **>(&prev->_context), next->_context, change_satp, new_satp);
     }
 }
 
diff --git a/src/api/thread_init.cc b/src/api/thread_init.cc
index db05478..2821f79 100644
--- a/src/api/thread_init.cc
+++ b/src/api/thread_init.cc
@@ -1,9 +1,13 @@
 // EPOS Thread Initialization
 
+#include <utility/elf.h>
+#include <architecture/mmu.h>
 #include <machine/timer.h>
 #include <machine/ic.h>
 #include <system.h>
 #include <process.h>
+#include <memory.h>
+
 
 __BEGIN_SYS
 
@@ -12,14 +16,47 @@ extern "C" { void __epos_app_entry(); }
 void Thread::init()
 {
     db<Init, Thread>(TRC) << "Thread::init()" << endl;
+    typedef int (Main)();
+    System_Info * si = System::info();
+    
+    if(Traits<System>::multitask) {
+        char * bi = reinterpret_cast<char*>(Memory_Map::MEM_BASE);
+        
+        for(unsigned i = 0; i < si->bm.n_apps; i++) {
+            // We need W permission to load the segment
+            Segment * code_seg = new (SYSTEM) Segment(si->lm.app[i].app_code_size, MMU::Flags::ALL);
+            Segment * data_seg = new (SYSTEM) Segment(8*1024*1024, MMU::Flags::UDATA);
+            Task * app_task =  new (SYSTEM) Task(code_seg, data_seg);
 
-    // If EPOS is a library, then adjust the application entry point to __epos_app_entry,
-    // which will directly call main(). In this case, _init will have already been called,
-    // before Init_Application to construct MAIN's global objects.
-    Thread::_running = new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<int (*)()>(__epos_app_entry));
-
+            db<Setup>(TRC) << "app_task = " << app_task << endl;
+            Task::activate(app_task);
+            
+            Task::_active->_heap = reinterpret_cast<Heap *>(Memory_Map::APP_HEAP);
+            
+            if(si->lm.has_app) {
+                ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
+                db<Setup>(TRC) << "Setup_SifiveE::load_app()" << endl;
+                if(app_elf->load_segment(0) < 0) {
+                    db<Setup>(ERR) << "Application code segment was corrupted during INIT!" << endl;
+                    Machine::panic();
+                }
+                for(int j = 1; j < app_elf->segments(); j++)
+                    if(app_elf->load_segment(j) < 0) {
+                        db<Setup>(ERR) << "Application data segment was corrupted during INIT!" << endl;
+                        Machine::panic();
+                    }
+            }
+            
+            new (SYSTEM) Thread(Thread::Configuration(Thread::RUNNING, Thread::MAIN), reinterpret_cast<Main *>(si->lm.app[i].app_entry));
+        }
+        
+        // We need to be in the AS of the first thread.
+        Task::activate(Thread::self()->_task);
+    }
+   
     // Idle thread creation does not cause rescheduling (see Thread::constructor_epilogue)
-    new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), &Thread::idle);
+    Thread * idle = new (SYSTEM) Thread(Thread::Configuration(Thread::READY, Thread::IDLE), Thread::idle);
+    idle->_context->_st |= CPU::SPP_S;
 
     // The installation of the scheduler timer handler does not need to be done after the
     // creation of threads, since the constructor won't call reschedule() which won't call
@@ -27,7 +64,7 @@ void Thread::init()
     // Letting reschedule() happen during thread creation is also harmless, since MAIN is
     // created first and dispatch won't replace it nor by itself neither by IDLE (which
     // has a lower priority)
-    if(preemptive)
+    if(Criterion::timed)
         _timer = new (SYSTEM) Scheduler_Timer(QUANTUM, time_slicer);
 
     // No more interrupts until we reach init_first
diff --git a/src/architecture/armv7/armv7_crtend.c b/src/architecture/armv7/armv7_crtend.c
index 84ae9b3..78a6b11 100644
--- a/src/architecture/armv7/armv7_crtend.c
+++ b/src/architecture/armv7/armv7_crtend.c
@@ -16,5 +16,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/ia32/ia32_crtend.c b/src/architecture/ia32/ia32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/ia32/ia32_crtend.c
+++ b/src/architecture/ia32/ia32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_cpu.cc b/src/architecture/rv32/rv32_cpu.cc
index 2e5830e..f370e2a 100644
--- a/src/architecture/rv32/rv32_cpu.cc
+++ b/src/architecture/rv32/rv32_cpu.cc
@@ -3,6 +3,8 @@
 #include <architecture/rv32/rv32_cpu.h>
 #include <system.h>
 
+extern "C" { void _exec(void *); }
+
 __BEGIN_SYS
 
 // Class attributes
@@ -10,10 +12,12 @@ unsigned int CPU::_cpu_clock;
 unsigned int CPU::_bus_clock;
 
 // Class methods
-void CPU::Context::save() volatile
+void CPU::Context::save() volatile //!P4: Unused, as of now
 {
-    ASM("       la       x4,      pc            \n"
-        "       sw       x4, -116(sp)           \n"     // push pc
+    ASM("       csrr     gp,  sstatus           \n"
+        "       sw       gp, -120(sp)           \n"     // push sstatus
+        "       auipc    gp, 0                  \n" 
+        "       sw       gp, -116(sp)           \n"     // push pc
         "       sw       x1, -112(sp)           \n"     // push ra
         "       sw       x5, -108(sp)           \n"     // push x5-x31
         "       sw       x6, -104(sp)           \n"
@@ -43,17 +47,18 @@ void CPU::Context::save() volatile
         "       sw      x30,   -8(sp)           \n"
         "       sw      x31,   -4(sp)           \n");
 
-    ASM("       addi     sp, sp, -116           \n"                     // complete the pushes above by adjusting the SP
+    ASM("       addi     sp, sp, -120           \n"                     // complete the pushes above by adjusting the SP
         "       sw       sp, 0(%0)              \n" : : "r"(this));     // update the this pointer to match the context saved on the stack
 }
 
+// Context load does not verify if interrupts were previously enabled by the Context's constructor
+// We are setting sstatus to SPP_U | SPIE, therefore, interrupts will be enabled only after sret
 void CPU::Context::load() const volatile
 {
     ASM("       mv      sp, %0                  \n"                     // load the stack pointer with the this pointer
-        "       addi    sp, sp, 116             \n" : : "r"(this));     // adjust the stack pointer to match the subsequent series of pops
+        "       addi    sp, sp, 120             \n" : : "r"(this));     // adjust the stack pointer to match the subsequent series of pops
 
-    ASM("       lw       x4, -116(sp)           \n"     // pop pc
-        "       lw       x1, -112(sp)           \n"     // pop ra
+    ASM("       lw       x1, -112(sp)           \n"     // pop ra
         "       lw       x5, -108(sp)           \n"     // pop x5-x31
         "       lw       x6, -104(sp)           \n"
         "       lw       x7, -100(sp)           \n"
@@ -81,14 +86,17 @@ void CPU::Context::load() const volatile
         "       lw      x29,  -12(sp)           \n"
         "       lw      x30,   -8(sp)           \n"
         "       lw      x31,   -4(sp)           \n"
-        "       jalr     x0,     (x4)           \n");   // jump to pc stored in x4 (jalr with x0 is equivalent to jr)
+        "       lw       gp, -120(sp)           \n"     // pop sstatus
+        "       csrs    sstatus,   gp           \n"     // set sstatus for sret
+        "       lw       gp, -116(sp)           \n"     // pop pc
+        "       csrw     sepc,     gp           \n"     // move pc to sepc for sret
+        "       sret                            \n");
 }
 
-void CPU::switch_context(Context ** o, Context * n)
+void CPU::switch_context(Context ** o, Context * n, unsigned int change_satp, unsigned int new_satp)
 {   
     // Push the context into the stack and update "o"
-    ASM("       la       x4,    .ret            \n"     // get the return address in a temporary
-        "       sw       x4, -116(sp)           \n"     // push the return address as pc
+    ASM("       sw       x1, -116(sp)           \n"     // push the return address as pc
         "       sw       x1, -112(sp)           \n"     // push ra
         "       sw       x5, -108(sp)           \n"     // push x5-x31
         "       sw       x6, -104(sp)           \n"
@@ -117,13 +125,25 @@ void CPU::switch_context(Context ** o, Context * n)
         "       sw      x29,  -12(sp)           \n"
         "       sw      x30,   -8(sp)           \n"
         "       sw      x31,   -4(sp)           \n"
-        "       addi     sp,      sp,   -116    \n"     // complete the pushes above by adjusting the SP
+        "       li      x31,    1 << 8          \n"     // we are inside the kernel, and so we must return in S-mode
+        "       csrs    sstatus, x31            \n"
+        "       csrr    x31,  sstatus           \n"     // get sstatus
+        "       sw      x31, -120(sp)           \n"     // push sstatus
+        "       addi     sp,      sp,   -120    \n"     // complete the pushes above by adjusting the SP
         "       sw       sp,    0(a0)           \n");   // update Context * volatile * o
-
+        
+    //!P4: We should switch AS here
+    ASM("       beq     a2,  x0, load_new_context      \n"
+        "       csrw    satp, a3                       \n"
+        "       sfence.vma                             \n");
+    
+    
+    ASM("load_new_context:");
     // Set the stack pointer to "n" and pop the context from the stack
     ASM("       mv       sp,      a1            \n"     // get Context * volatile n into SP
-        "       addi     sp,      sp,    116    \n"     // adjust stack pointer as part of the subsequent pops
-        "       lw       x4, -116(sp)           \n"     // pop pc to a temporary
+        "       addi     sp,      sp,    120    \n"     // adjust stack pointer as part of the subsequent pops
+        "       lw      x31, -116(sp)           \n"     // pop pc to a temporary
+        "       csrw    sepc, x31               \n"
         "       lw       x1, -112(sp)           \n"     // pop ra
         "       lw       x5, -108(sp)           \n"     // pop x5-x31
         "       lw       x6, -104(sp)           \n"
@@ -150,10 +170,29 @@ void CPU::switch_context(Context ** o, Context * n)
         "       lw      x27,  -20(sp)           \n"
         "       lw      x28,  -16(sp)           \n"
         "       lw      x29,  -12(sp)           \n"
+        "       lw      x31, -120(sp)           \n"     // pop sstatus
+        "       csrw     sstatus, x31           \n"
         "       lw      x30,   -8(sp)           \n"
         "       lw      x31,   -4(sp)           \n"
-        "       jalr     x0,     (x4)           \n"     // return (for the thread entering the CPU)
-        ".ret:  jalr     x0,     (x1)           \n");   // return (for the thread leaving the CPU)
+        "       sret                            \n");
 }
 
+
+void CPU::syscall(void * message){
+    ASM("  ecall  \n");
+}
+
+void CPU::syscalled() {
+    ASM(
+        " addi sp, sp, -12   \n"
+        " sw   a0, 4(sp)    \n"
+        " sw   ra, 8(sp)    \n"
+        " call _exec        \n"
+        " lw   a0, 4(sp)    \n"
+        " lw   ra, 8(sp)    \n"
+        " addi sp, sp,  12   \n"
+    );
+}
+
+
 __END_SYS
diff --git a/src/architecture/rv32/rv32_crt0.S b/src/architecture/rv32/rv32_crt0.S
index 22159d3..3c53ac9 100644
--- a/src/architecture/rv32/rv32_crt0.S
+++ b/src/architecture/rv32/rv32_crt0.S
@@ -10,19 +10,6 @@
 _start:
         // Temporary stack(s) for INIT are created and configure by SETUP
 
-        // Only hart (core) 0 cleans cache
-        csrr    t0, mhartid
-        bnez    t0, 2f
-
-        // Set all bytes in the BSS section to zero.
-        la      a0, __bss_start
-        la      a1, _end
-        bgeu    a0, a1, 2f
-1:
-        sw      zero, (a0)
-        addi    a0, a0, 4
-        bltu    a0, a1, 1b
-2:
         // Call _init
         call      _init
 
diff --git a/src/architecture/rv32/rv32_crtend.c b/src/architecture/rv32/rv32_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv32/rv32_crtend.c
+++ b/src/architecture/rv32/rv32_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/architecture/rv32/rv32_mmu.cc b/src/architecture/rv32/rv32_mmu.cc
index 1008524..fa3a7d7 100644
--- a/src/architecture/rv32/rv32_mmu.cc
+++ b/src/architecture/rv32/rv32_mmu.cc
@@ -6,5 +6,6 @@ __BEGIN_SYS
 
 // Class attributes
 MMU::List MMU::_free;
+MMU::Page_Directory * MMU::_master;
 
 __END_SYS
diff --git a/src/architecture/rv32/rv32_mmu_init.cc b/src/architecture/rv32/rv32_mmu_init.cc
index 127200c..e2719d4 100644
--- a/src/architecture/rv32/rv32_mmu_init.cc
+++ b/src/architecture/rv32/rv32_mmu_init.cc
@@ -1,26 +1,30 @@
 // EPOS RISC-V 32 MMU Mediator Initialization
 
 #include <architecture/mmu.h>
-
-extern "C" void * _edata;
-extern "C" void * __bss_start;
-extern "C" void * _end;
+#include <system.h>
 
 __BEGIN_SYS
 
 void MMU::init()
 {
-    db<Init, MMU>(TRC) << "MMU::init()" << endl;
-
-    db<Init, MMU>(INF) << "MMU::init::dat.e=" << &_edata << ",bss.b=" << &__bss_start << ",bss.e=" << &_end << endl;
-
     // For machines that do not feature a real MMU, frame size = 1 byte
     // Allocations (using Grouping_List<Frame>::search_decrementing() start from the end
     // To preserve the BOOT stacks until the end of INIT, the free memory list initialization is split in two sections
     // with allocations (from the end) of the first section taking place first
-    free(&_end, pages(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS - reinterpret_cast<unsigned int>(&_end)));
-    free(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS, pages(Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS));
-}
+    db<Init, MMU>(TRC) << "MMU::init()" << endl;
 
-__END_SYS
+    System_Info * si = System::info();
+    unsigned sys_data_end = si->lm.sys_data + si->lm.sys_data_size + 1;
+    MMU::_master = reinterpret_cast<Page_Directory*>(Memory_Map::PAGE_TABLES);
+
+    free(align_page(sys_data_end), pages(Memory_Map::MMODE_F - align_page(sys_data_end)));
+    // Worst-Fit guarantees this will work; we plan to leave the boot stack as a System stack
+    // free(Memory_Map::MEM_TOP + 1 - Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS, pages(Traits<Machine>::STACK_SIZE * Traits<Machine>::CPUS));
+    
+    // Free init/setup memory
+    free(Memory_Map::MEM_BASE, pages(Memory_Map::SYS - Memory_Map::MEM_BASE));
+    db<Init, MMU>(TRC) << "MMU has been given the regions: [" << hex << align_page(sys_data_end) << "," << hex << Memory_Map::MMODE_F << "], [" \
+        << hex << Memory_Map::MEM_BASE << "," << hex << Memory_Map::SYS << "]" << endl;
+}
 
+__END_SYS
\ No newline at end of file
diff --git a/src/architecture/rv64/rv64_crtend.c b/src/architecture/rv64/rv64_crtend.c
index 8aa31da..b7897e9 100644
--- a/src/architecture/rv64/rv64_crtend.c
+++ b/src/architecture/rv64/rv64_crtend.c
@@ -17,5 +17,3 @@ void _init()
 {
     __do_global_ctors_aux();
 }
-
-void __epos_app_entry() __attribute__ ((section(".init"), weak, alias ("_init")));
diff --git a/src/init/init_application.cc b/src/init/init_application.cc
index c3c4b15..9b4745a 100644
--- a/src/init/init_application.cc
+++ b/src/init/init_application.cc
@@ -5,13 +5,14 @@
 #include <machine.h>
 #include <system.h>
 
-extern "C" { char _end; } // defined by GCC
+extern "C" char _end; // defined by GCC
 
 __BEGIN_SYS
 
 class Init_Application
 {
 private:
+    void * APP_HEAP = reinterpret_cast<void*>(Traits<Application>::APP_HEAP);
     static const unsigned int HEAP_SIZE = Traits<Application>::HEAP_SIZE;
     static const unsigned int STACK_SIZE = Traits<Application>::STACK_SIZE;
 
@@ -21,14 +22,9 @@ public:
 
         // Initialize Application's heap
         db<Init>(INF) << "Initializing application's heap: " << endl;
-        if(Traits<System>::multiheap) { // heap in data segment arranged by SETUP
-            char * heap = MMU::align_page(&_end);
-            if(Traits<Build>::MODE != Traits<Build>::KERNEL) // if not a kernel, then use the stack allocated by SETUP, otherwise make that part of the heap
-                heap += MMU::align_page(Traits<Application>::STACK_SIZE);
-            Application::_heap = new (&Application::_preheap[0]) Heap(heap, HEAP_SIZE);
-        } else
-            for(unsigned int frames = MMU::allocable(); frames; frames = MMU::allocable())
-                System::_heap->free(MMU::alloc(frames), frames * sizeof(MMU::Page));
+        // Application::_heap = new (&Application::_preheap[0]) Heap(APP_HEAP, HEAP_SIZE);
+        Application::_heap = new (APP_HEAP) Heap(reinterpret_cast<void*>(Traits<Application>::APP_HEAP+sizeof(Heap)), HEAP_SIZE-sizeof(Heap));
+        
         db<Init>(INF) << "done!" << endl;
     }
 };
diff --git a/src/init/init_first.cc b/src/init/init_first.cc
index cef9299..975dfc4 100644
--- a/src/init/init_first.cc
+++ b/src/init/init_first.cc
@@ -16,15 +16,19 @@ public:
             return;
         }
 
-        db<Init>(INF) << "INIT ends here!" << endl;
+        db<Init>(TRC) << "INIT ends here!" << endl;
 
-        db<Init, Thread>(INF) << "Dispatching the first thread: " << Thread::running() << endl;
+        // Thread::self() and Task::self() can be safely called after the construction of MAIN
+        // even if no reschedule() was called (running is set by the Scheduler at each insert())
+        Thread * first = Thread::self();
+
+        db<Init, Thread>(TRC) << "Dispatching the first thread: " << first << endl;
 
         // Interrupts have been disable at Thread::init() and will be reenabled by CPU::Context::load()
         // but we first reset the timer to avoid getting a time interrupt during load()
-        Timer::reset();
-        CPU::int_enable();
-        Thread::running()->_context->load();
+        if (Traits<Timer>::enabled)
+            Timer::reset();
+        first->_context->load();
     }
 };
 
diff --git a/src/init/init_system.cc b/src/init/init_system.cc
index d3c373f..bc19699 100644
--- a/src/init/init_system.cc
+++ b/src/init/init_system.cc
@@ -6,6 +6,8 @@
 #include <system.h>
 #include <process.h>
 
+extern "C" void _int_entry();
+
 __BEGIN_SYS
 
 class Init_System
@@ -17,6 +19,8 @@ public:
     Init_System() {
         db<Init>(TRC) << "Init_System()" << endl;
 
+        Machine::pre_init(System::info());
+
         // Initialize the processor
         db<Init>(INF) << "Initializing the CPU: " << endl;
         CPU::init();
@@ -24,12 +28,7 @@ public:
 
         // Initialize System's heap
         db<Init>(INF) << "Initializing system's heap: " << endl;
-        if(Traits<System>::multiheap) {
-            Segment * tmp = reinterpret_cast<Segment *>(&System::_preheap[0]);
-            System::_heap_segment = new (tmp) Segment(HEAP_SIZE, WHITE, Segment::Flags::SYS);
-            System::_heap = new (&System::_preheap[sizeof(Segment)]) Heap(Address_Space(MMU::current()).attach(System::_heap_segment, Memory_Map::SYS_HEAP), System::_heap_segment->size());
-        } else
-            System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
+        System::_heap = new (&System::_preheap[0]) Heap(MMU::alloc(MMU::pages(HEAP_SIZE)), HEAP_SIZE);
         db<Init>(INF) << "done!" << endl;
 
         // Initialize the machine
diff --git a/src/init/makefile b/src/init/makefile
index d373c22..f585c73 100644
--- a/src/init/makefile
+++ b/src/init/makefile
@@ -38,10 +38,11 @@ init_builtin_$(MMOD): $(SRC)/system/system_$(MMOD) $(OBJS) $(LIBINIT)
 		-R $(SRC)/system/system_$(MMOD) \
 		-l$(LUTIL) -lgcc
 		$(INSTALL) init_application.o init_application_$(MMOD).o
-
+# --section-start .init=$(INIT_ADDR) \
+# 
 init_kernel_$(MMOD): $(SRC)/system/system_$(MMOD) $(OBJS) $(LIBINIT)
 		$(LD) $(LDFLAGS) -L$(CCLIB) --omagic \
-		--section-start .init=$(INIT_ADDR) \
+		--section-start $(MACH_CODE_NAME)=$(INIT_ADDR) \
 		--entry=_init -o init_$(MMOD) \
 		$(LIB)/crtbegin_$(MMOD).o \
 		init_first.o init_system.o \
diff --git a/src/machine/riscv/riscv_ic.cc b/src/machine/riscv/riscv_ic.cc
index 96a53c3..c025628 100644
--- a/src/machine/riscv/riscv_ic.cc
+++ b/src/machine/riscv/riscv_ic.cc
@@ -3,21 +3,22 @@
 #include <machine/machine.h>
 #include <machine/ic.h>
 
-extern "C" { void _int_entry() __attribute__ ((alias("_ZN4EPOS1S2IC5entryEv"))); }
-
 __BEGIN_SYS
 
+extern "C" { [[gnu::alias("_ZN4EPOS1S2IC5entryEv"), gnu::nothrow]] void _int_entry(); }
+extern "C" { void __exit(); }
+
 // Class attributes
 IC::Interrupt_Handler IC::_int_vector[IC::INTS];
 
 // Class methods
 void IC::entry()
 {
-    // Handle interrupts in machine mode
+    // Handle interrupts in supervisor mode
     ASM("        .align 4                                               \n"
         "                                                               \n"
         "# Save context                                                 \n"
-        "        addi        sp,     sp,   -140                         \n"          // 32 regs of 4 bytes each = 128 Bytes
+        "        addi        sp,     sp,   -136                         \n"          // 32 regs of 4 bytes each = 128 Bytes
         "        sw          x1,   4(sp)                                \n"
         "        sw          x2,   8(sp)                                \n"
         "        sw          x3,  12(sp)                                \n"
@@ -49,14 +50,19 @@ void IC::entry()
         "        sw         x29, 116(sp)                                \n"
         "        sw         x30, 120(sp)                                \n"
         "        sw         x31, 124(sp)                                \n"
-        "        csrr       x31, mie                                    \n"
+        "        csrr       x31, sstatus                                \n"
         "        sw         x31, 128(sp)                                \n"
-        "        csrr       x31, mstatus                                \n"
+        "        csrr       x31, sepc                                   \n"
         "        sw         x31, 132(sp)                                \n"
-        "        csrr       x31, mepc                                   \n"
-        "        sw         x31, 136(sp)                                \n"
         "        la          ra, .restore                               \n" // Set LR to restore context before returning
+        "        addi       t0, x0, 8                                   \n" // Is it an ecall from U-mode?
+        "        csrr       t1, scause                                  \n"
+        "        beq        t0, t1, .entry_ecall                        \n"
         "        j          %0                                          \n"
+        ".entry_ecall:                                                  \n"
+        "        addi       x31, x31, 4                                 \n"  // We must return to PC+4
+        "        sw         x31, 132(sp)                                \n"
+        "        j          %1                                          \n"
         "                                                               \n"
         "# Restore context                                              \n"
         ".restore:                                                      \n"
@@ -90,52 +96,60 @@ void IC::entry()
         "        lw         x28, 112(sp)                                \n"
         "        lw         x29, 116(sp)                                \n"
         "        lw         x30, 120(sp)                                \n"
-        "        lw         x31, 124(sp)                                \n"
         "        lw         x31, 128(sp)                                \n"
-        "        csrs       mie, x31                                    \n"
+        "        csrw   sstatus, x31                                    \n"
         "        lw         x31, 132(sp)                                \n"
-        "        csrs   mstatus, x31                                    \n"
-        "        lw         x31, 136(sp)                                \n"
-        "        csrw      mepc, x31                                    \n"
-        "        addi        sp, sp,    140                             \n"
-        "        mret                                                   \n" : : "i"(&dispatch));
+        "        csrw      sepc, x31                                    \n"
+        "        lw         x31, 124(sp)                                \n"
+        "        addi        sp, sp,    136                             \n"
+        "        sret                                                   \n" : : "i"(&dispatch), "i"(&CPU::syscalled));
 }
 
 void IC::dispatch()
 {
     Interrupt_Id id = int_id();
-
+        
     if((id != INT_SYS_TIMER) || Traits<IC>::hysterically_debugged)
         db<IC>(TRC) << "IC::dispatch(i=" << id << ")" << endl;
 
-    if(id == INT_RESCHEDULER)
-        IC::ipi_eoi(id);
+    if(id == INT_SYS_TIMER)
+        CPU::sie_clear(CPU::STI);
+
+    //!P4: Sanity check
+    if (id == 11)
+        Machine::panic();
+    
+    if (id == EXC_INSTR_PAGE_FAULT)
+        __exit();
 
     _int_vector[id](id);
 }
 
 void IC::int_not(Interrupt_Id id)
 {
-    db<IC>(WRN) << "IC::int_not(i=" << id << ")";
-    if(Traits<Build>::hysterically_debugged)
+    CPU::Reg sstatus = CPU::sstatus();
+    CPU::Reg scause = CPU::scause();
+    CPU::Reg mhartid = CPU::id();
+    CPU::Reg sepc = CPU::sepc();
+
+    db<IC>(WRN) << "IC::int_not(i=" << id << ") => {" << hex << "sstatus=" << sstatus << ",scause=" << scause << ",mhartid=" << mhartid << ",sepc=" << sepc  << "}" << dec;
+    if(Traits<Build>::hysterically_debugged) {
+        // ERR wasn't working; so force halt
         db<IC>(ERR) << endl;
+        Machine::panic();
+    }
     else
         db<IC>(WRN) << endl;
 }
 
 void IC::exception(Interrupt_Id id)
 {
-    CPU::Reg mstatus = CPU::mstatus();
-    CPU::Reg mcause = CPU::mcause();
+    CPU::Reg sstatus = CPU::sstatus();
+    CPU::Reg scause = CPU::scause();
     CPU::Reg mhartid = CPU::id();
-    CPU::Reg mepc;
-    ASM("csrr %0, mepc" : "=r"(mepc) : :);
-    CPU::Reg sepc;
-    ASM("csrr %0, sepc" : "=r"(sepc) : :);
-    CPU::Reg mtval;
-    ASM("csrr %0, mtval" : "=r"(mtval) : :);
+    CPU::Reg sepc = CPU::sepc();
 
-    db<IC>(WRN) << "IC::Exception(" << id << ") => {" << hex << "mstatus=" << mstatus << ",mcause=" << mcause << ",mhartid=" << mhartid << ",mepc=" << hex << mepc << ",sepc=" << sepc << ",mtval=" << mtval << "}" << dec;
+    db<IC>(WRN) << "IC::Exception(" << id << ") => {" << hex << "sstatus=" << sstatus << ",scause=" << scause << ",mhartid=" << mhartid << ",sepc=" << sepc  << "}" << dec;
 
     switch(id) {
         case 0: // unaligned Instruction
@@ -171,8 +185,11 @@ void IC::exception(Interrupt_Id id)
             break;
     }
 
-    if(Traits<Build>::hysterically_debugged)
+    if(Traits<Build>::hysterically_debugged) {
+        // ERR wasn't working; so force halt
         db<IC>(ERR) << endl;
+        Machine::panic();
+    }
     else
         db<IC>(WRN) << endl;
 }
diff --git a/src/machine/riscv/riscv_ic_init.cc b/src/machine/riscv/riscv_ic_init.cc
index 8904a70..a33cb1a 100644
--- a/src/machine/riscv/riscv_ic_init.cc
+++ b/src/machine/riscv/riscv_ic_init.cc
@@ -4,6 +4,8 @@
 #include <machine/ic.h>
 #include <machine/timer.h>
 
+extern "C" void _int_entry();
+
 __BEGIN_SYS
 
 // Class methods
@@ -11,17 +13,17 @@ void IC::init()
 {
     db<Init, IC>(TRC) << "IC::init()" << endl;
 
-    CPU::int_disable(); // will be reenabled at Thread::init() by Context::load()
-
-    disable(); // will be enabled on demand as handlers are registered
+    // CPU::int_disable();
+    // Will be enabled on demand as handlers are registered
+    disable();
 
     // Set all exception handlers to exception()
     for(Interrupt_Id i = 0; i < CPU::EXCEPTIONS; i++)
-        _int_vector[i] = exception;
+        _int_vector[i] = &exception;
 
     // Set all interrupt handlers to int_not()
     for(Interrupt_Id i = HARD_INT; i < INTS; i++)
-        _int_vector[i] = int_not;
+        _int_vector[i] = &int_not;
 }
 
 __END_SYS
diff --git a/src/machine/riscv/riscv_machine.cc b/src/machine/riscv/riscv_machine.cc
index df32ae3..98dfa6b 100644
--- a/src/machine/riscv/riscv_machine.cc
+++ b/src/machine/riscv/riscv_machine.cc
@@ -10,10 +10,12 @@ void Machine::panic()
     CPU::int_disable();
     if(Traits<Display>::enabled)
         Display::puts("PANIC!\n");
-    if(Traits<System>::reboot)
-        reboot();
-    else
-        poweroff();
+    ASM("wfi");
+    while (true) {};
+    // if(Traits<System>::reboot)
+    //     reboot();
+    // else
+    //     poweroff();
 }
 
 __END_SYS
diff --git a/src/machine/riscv/riscv_machine_init.cc b/src/machine/riscv/riscv_machine_init.cc
index 1e5be41..9875c23 100644
--- a/src/machine/riscv/riscv_machine_init.cc
+++ b/src/machine/riscv/riscv_machine_init.cc
@@ -6,21 +6,10 @@ __BEGIN_SYS
 
 void Machine::pre_init(System_Info * si)
 {
-    if(CPU::id() == 0)
-        Display::init();
-
-    db<Init, Machine>(TRC) << "Machine::pre_init()" << endl;
-
-    if(CPU::id() == 0) {
-        if(Traits<IC>::enabled) {
-            IC::init();
-
-            // Wake up remaining CPUs
-            // si->bm.n_cpus = Traits<Build>::CPUS;
-            if(Traits<System>::multicore)
-                smp_barrier_init(Traits<Build>::CPUS);
-        }
-    }
+    CPU::stvec_write((unsigned)&IC::entry & 0xfffffffc);
+    // Allow system to access user pages
+    CPU::sstatus(CPU::SUM);
+    IC::init();
 }
 
 void Machine::init()
diff --git a/src/machine/riscv/riscv_timer.cc b/src/machine/riscv/riscv_timer.cc
index 1773715..fa57b41 100644
--- a/src/machine/riscv/riscv_timer.cc
+++ b/src/machine/riscv/riscv_timer.cc
@@ -11,6 +11,7 @@ Timer * Timer::_channels[CHANNELS];
 // Class methods
 void Timer::int_handler(Interrupt_Id i)
 {
+    // kout << "ESTOU DE SACANAGEM" << endl;
     config(FREQUENCY);
     if(_channels[SCHEDULER] && (--_channels[SCHEDULER]->_current[CPU::id()] <= 0)) {
         _channels[SCHEDULER]->_current[CPU::id()] = _channels[SCHEDULER]->_initial;
diff --git a/src/machine/riscv/riscv_timer_init.cc b/src/machine/riscv/riscv_timer_init.cc
index 6013906..beb3589 100644
--- a/src/machine/riscv/riscv_timer_init.cc
+++ b/src/machine/riscv/riscv_timer_init.cc
@@ -9,6 +9,7 @@ __BEGIN_SYS
 void Timer::init()
 {
     db<Init, Timer>(TRC) << "Timer::init()" << endl;
+    db<Init, Timer>(TRC) << "Time=" << CPU::rdtime() << endl;
 
     CPU::int_disable();
 
@@ -17,9 +18,6 @@ void Timer::init()
 
     config(FREQUENCY);
     IC::enable(IC::INT_SYS_TIMER);
-
-    CPU::int_enable();
-
 }
 
 __END_SYS
diff --git a/src/setup/makefile b/src/setup/makefile
index b5ead57..fe0620a 100644
--- a/src/setup/makefile
+++ b/src/setup/makefile
@@ -7,10 +7,11 @@ TARGET := $(if $(shell find setup_$(MMOD)* 2> /dev/null), $(if $(SETUP_ADDR), in
 all:	$(TARGET)
 
 setup_$(MMOD):	setup_$(MMOD).o
-		$(LD) $(LDFLAGS) -L$(CCLIB) --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
+		$(LD) $(LDFLAGS) -L$(CCLIB) --trace --omagic --section-start .init=$(SETUP_ADDR) -o $@ $^ -l$(LINIT) -l$(LMACH) -l$(LARCH) -l$(LUTIL) -lgcc
 
 install:	setup_$(MMOD)
-		$(INSTALL) $< $(IMG)
+		$(OBJCOPY) $< $<_raw -O binary
+		mv $<_raw $(IMG)/$<
 
 install.o:	setup_$(MMOD).o
 		$(INSTALL) $< $(LIB)
diff --git a/src/setup/setup_sifive_e.cc b/src/setup/setup_sifive_e.cc
index 67287a6..ed9ae70 100644
--- a/src/setup/setup_sifive_e.cc
+++ b/src/setup/setup_sifive_e.cc
@@ -1,74 +1,410 @@
 // EPOS RISC-V sifive SETUP
 
-#include <system/config.h>
+#include <utility/ostream.h>
+#include <utility/elf.h>
+#include <utility/debug.h>
+#include <system/info.h>
+#include <architecture.h>
+#include <machine.h>
 
-extern "C" { void _setup() __attribute__ ((used, naked, section(".init"))); }
+using namespace EPOS::S;
+typedef unsigned int Reg;
 
-// Interrupt Vector Table
-void _setup()
+extern "C"
 {
-    ASM("\t\n\
-        j       .reset                                                          \t\n\
-                                                                                \t\n\
-.reset:                                                                         \t\n\
-        # Disable interrupts                                                    \t\n\
-        csrs    mstatus, 1 << 3                                                 \t\n\
-                                                                                \t\n\
-        # Disable paging                                                        \t\n\
-        csrw    sptbr, zero                                                     \t\n\
-                                                                                \t\n\
-        # Put CLINT in direct mode (mtvec.mode = 0) and set mtvec to _int_entry \t\n\
-        la      t0, _int_entry                                                  \t\n\
-        andi    t0, t0, 0xfffffffe  # mtvec.mode = 0                            \t\n\
-        csrw    mtvec, t0                                                       \t\n\
-                                                                                \t\n\
-        # Get the hart's id                                                     \t\n\
-        csrr    a0, mhartid                                                     \t\n\
-                                                                                \t\n\
-        # Set a 16KB stack for each hart (#0 at __boot_stack__)                 \t\n\
-        la      sp, __boot_stack__                                              \t\n\
-        li      t0, 1                                                           \t\n\
-        slli    t0, t0, 14                                                      \t\n\
-        mul     t0, t0, a0                                                      \t\n\
-        sub     sp, sp, t0                                                      \t\n\
-                                                                                \t\n\
-        # Non-bootstrapping harts wait for an IPI                               \t\n\
-        bnez    a0, .secondary                                                  \t\n\
-                                                                                \t\n\
-        # Set mstatus to machine mode with interrupts disabled                  \t\n\
-        # 0b11 << 11: Machine's previous protection mode is 3 (MPP=3)           \t\n\
-        #    1 <<  7: Machine's previous interrupt-enable bit is 1 (MPIE=1)     \t\n\
-        li      t0, (0b11 << 11) | (1 << 7)                                     \t\n\
-        csrw    mstatus, t0                                                     \t\n\
-                                                                                \t\n\
-        # Set mepc to `_start` (will be used by mret)                           \t\n\
-        la      t0, _start                                                      \t\n\
-        csrw    mepc, t0                                                        \t\n\
-                                                                                \t\n\
-        # Go to _start and update mstatus accordingly by returning to mepc      \t\n\
-        mret                                                                    \t\n\
-                                                                                \t\n\
-.secondary:                                                                     \t\n\
-        # Set mstatus to machine mode with interrupts enabled                   \t\n\
-        # 0b11 << 11: Machine's previous protection mode is 3 (MPP=3)           \t\n\
-        #    1 <<  7: Machine's previous interrupt-enable bit is 1 (MPIE=1)     \t\n\
-        #    1 <<  3: Machine's interrupt-enable bit is 1 (MIE=1)               \t\n\
-        li      t0, (0b11 << 11) | (1 << 7) | (1 << 3)                          \t\n\
-        csrw    mstatus, t0                                                     \t\n\
-                                                                                \t\n\
-        # Enable software interrupts so hart #0 can latter wake up this hart    \t\n\
-        li      t0, (1 << 3) | (1 << 7) | (1 << 11)                             \t\n\
-        csrw    mie, t0                                                         \t\n\
-                                                                                \t\n\
-        # Set mepc to `_wait` (will be used by mret)                            \t\n\
-        la  t0, .wait                                                           \t\n\
-        csrw mepc, t0                                                           \t\n\
-                                                                                \t\n\
-        # Go to _wait and update mstatus accordingly by returning to mepc       \t\n\
-        mret                                                                    \t\n\
-                                                                                \t\n\
-.wait:                                                                          \t\n\
-        wfi                                                                     \t\n\
-        j _start                                                                \t\n\
-        ");
+    [[gnu::naked, gnu::section(".init")]] void _setup();
+    void _print(const char * s) { Display::puts(s); }
+    void _panic() { Machine::panic(); }
 }
+
+char placeholder[sizeof(System_Info)] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+System_Info * si;
+
+__BEGIN_SYS
+EPOS::S::U::OStream kout, kerr;
+char * bi;
+
+class Setup_SifiveE {
+private:
+    // Physical memory map (decreasing)
+    static const unsigned int MEM_TOP       = Memory_Map::MEM_TOP;
+    static const unsigned int BOOT_STACK    = Memory_Map::BOOT_STACK;
+    static const unsigned int PAGE_TABLES   = Memory_Map::PAGE_TABLES;
+    static const unsigned int SYS_INFO      = Memory_Map::SYS_INFO;
+    static const unsigned int MMODE_F       = Memory_Map::MMODE_F;
+    static const unsigned int MEM_BASE      = Memory_Map::MEM_BASE;
+
+    // Logical memory map (decreasing)
+    static const unsigned int APP_DATA      = Memory_Map::APP_DATA;
+    static const unsigned int APP_CODE      = Memory_Map::APP_CODE;
+
+    static const unsigned int SYS_STACK     = Memory_Map::SYS_STACK;
+    static const unsigned int SYS_DATA      = Memory_Map::SYS_DATA;
+    static const unsigned int SYS_CODE      = Memory_Map::SYS_CODE;
+
+    static const unsigned int INIT          = Memory_Map::INIT;
+    
+    typedef CPU::Reg Reg;
+    typedef MMU::RV32_Flags RV32_Flags;
+    typedef MMU::Page Page;
+    typedef MMU::Page_Table Page_Table;
+    typedef MMU::Page_Directory Page_Directory;
+    typedef MMU::PT_Entry PT_Entry;
+
+public:
+    static void init() { setup_machine_environment(); }
+    static void setup_machine_environment();
+    static void setup_supervisor_environment();
+    static void build_page_tables();
+    static void clean_bss();
+    static void build_lm();
+    static void load_parts();
+};
+
+extern "C" [[gnu::naked, gnu::aligned(4)]] void _mmode_forward() {
+    // Change $sp to system stack and save registers that will be used
+    ASM("   csrw    mscratch, sp        \n"
+        "   li      sp, %0              \n"
+        "   addi	sp, sp, -16         \n"
+        "   sw	    a2, 12(sp)          \n"
+        "   sw	    a3, 8(sp)           \n"
+        "   sw	    a4, 4(sp)           \n"
+        "   sw	    a5, 0(sp)           \n" : : "i"(Memory_Map::BOOT_STACK - Traits<Machine>::STACK_SIZE + 0x30));
+        
+    Reg id = CPU::mcause();
+    if((id & IC::INT_MASK) == CLINT::IRQ_MAC_TIMER) {
+        Timer::reset();
+        CPU::sie(CPU::STI);
+    }
+    Reg interrupt_id = 1 << ((id & IC::INT_MASK) - 2);
+    if(CPU::int_enabled() && (CPU::sie() & (interrupt_id)))
+        CPU::mip(interrupt_id);
+    
+    // Restore context
+    ASM("   lw	    a2, 12(sp)          \n"
+        "   lw	    a3, 8(sp)           \n"
+        "   lw	    a4, 4(sp)           \n"
+        "   lw	    a5, 0(sp)           \n"
+        "   addi	sp, sp, 16          \n"
+        "   csrr    sp, mscratch        \n"
+        "   mret                        \n");
+}
+
+void Setup_SifiveE::load_parts()
+{
+    db<Setup>(TRC) << "load_parts" << endl;
+
+    // Relocate System_Info
+    if(sizeof(System_Info) > sizeof(Page)) {
+        db<Setup>(ERR) << "System_Info is bigger than a page (" << sizeof(System_Info) << ")!" << endl;
+        _panic();
+    }
+    memcpy(reinterpret_cast<void *>(SYS_INFO), si, sizeof(System_Info));
+    
+    ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+    ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+    
+    // Load INIT
+    if(si->lm.has_ini) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_init()" << endl;
+        if(ini_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "INIT code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        
+        for(int i = 1; i < ini_elf->segments(); i++)
+            if(ini_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "INIT data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    db<Setup>(TRC) << "init has " << hex << sys_elf->segment_address(0) - ini_elf->segment_address(0) - ini_elf->segment_size(0) << " unused bytes of memory" << endl;
+    
+    // Load SYSTEM
+    if(si->lm.has_sys) {
+        db<Setup>(TRC) << "Setup_SifiveE::load_system()" << endl;
+        if(sys_elf->load_segment(0) < 0) {
+            db<Setup>(ERR) << "system code segment was corrupted during SETUP!" << endl;
+            _panic();
+        }
+        for(int i = 1; i < sys_elf->segments(); i++)
+            if(sys_elf->load_segment(i) < 0) {
+                db<Setup>(ERR) << "system data segment was corrupted during SETUP!" << endl;
+                _panic();
+            }
+    }
+    db<Setup>(TRC) << "sys code has " << hex << sys_elf->segment_address(1) - sys_elf->segment_address(0) - sys_elf->segment_size(0) << " unused bytes of memory" << endl;
+    db<Setup>(TRC) << "sys data has " << hex << 0x00100000 - sys_elf->segment_size(1) << " unused bytes of memory" << endl;
+}
+
+
+void Setup_SifiveE::build_lm()
+{
+    db<Setup>(TRC) << "build_lm()" << endl;
+
+    // Get boot image structure
+    si->lm.has_stp = (si->bm.setup_offset != -1u);
+    si->lm.has_ini = (si->bm.init_offset != -1u);
+    si->lm.has_sys = (si->bm.system_offset != -1u);
+    si->lm.has_app = (si->bm.application_offset[0] != -1u);
+    si->lm.has_ext = (si->bm.extras_offset != -1u);
+
+    bi = reinterpret_cast<char *>(Traits<Machine>::MEM_BASE); // bi is loaded at MEM_BASE
+    // Setup won't be loaded since it is already present on binary form at the boot image
+    si->lm.stp_entry = 0;
+    si->lm.stp_segments = 0;
+    si->lm.stp_code = ~0U;
+    si->lm.stp_code_size = 0;
+    si->lm.stp_data = ~0U;
+    si->lm.stp_data_size = 0;
+
+    // Check INIT integrity and get the size of its segments
+    si->lm.ini_entry = 0;
+    si->lm.ini_segments = 0;
+    si->lm.ini_code = ~0U;
+    si->lm.ini_code_size = 0;
+    si->lm.ini_data = ~0U;
+    si->lm.ini_data_size = 0;
+    if(si->lm.has_ini) {
+        ELF * ini_elf = reinterpret_cast<ELF *>(&bi[si->bm.init_offset]);
+        if(!ini_elf->valid()) {
+            db<Setup>(ERR) << "INIT ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.ini_entry = ini_elf->entry();
+        si->lm.ini_segments = ini_elf->segments();
+        si->lm.ini_code = ini_elf->segment_address(0);
+        si->lm.ini_code_size = ini_elf->segment_size(0);
+        if(ini_elf->segments() > 1) {
+            for(int i = 1; i < ini_elf->segments(); i++) {
+                if(ini_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(ini_elf->segment_address(i) < si->lm.ini_data)
+                    si->lm.ini_data = ini_elf->segment_address(i);
+                si->lm.ini_data_size += ini_elf->segment_size(i);
+            }
+        }
+        if(si->lm.ini_code != INIT) {
+            db<Setup>(ERR) << "Init code segment address (" << reinterpret_cast<void *>(si->lm.ini_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(INIT) << ")!" << endl;
+            _panic();
+        }
+        if(si->lm.ini_code + si->lm.ini_code_size > SYS_CODE) {
+            db<Setup>(ERR) << "Init code segment is too large!" << endl;
+            _panic();
+        }
+    }
+
+    // Check SYSTEM integrity and get the size of its segments
+    si->lm.sys_entry = 0;
+    si->lm.sys_segments = 0;
+    si->lm.sys_code = ~0U;
+    si->lm.sys_code_size = 0;
+    si->lm.sys_data = ~0U;
+    si->lm.sys_data_size = 0;
+    si->lm.sys_stack = SYS_STACK;
+    si->lm.sys_stack_size = Traits<System>::STACK_SIZE * si->bm.n_cpus;
+    if(si->lm.has_sys) {
+        ELF * sys_elf = reinterpret_cast<ELF *>(&bi[si->bm.system_offset]);
+        if(!sys_elf->valid()) {
+            db<Setup>(ERR) << "OS ELF image is corrupted!" << endl;
+            _panic();
+        }
+
+        si->lm.sys_entry = sys_elf->entry();
+        si->lm.sys_segments = sys_elf->segments();
+        si->lm.sys_code = sys_elf->segment_address(0);
+        si->lm.sys_code_size = sys_elf->segment_size(0);
+        if(sys_elf->segments() > 1) {
+            for(int i = 1; i < sys_elf->segments(); i++) {
+                if(sys_elf->segment_type(i) != PT_LOAD)
+                    continue;
+                if(sys_elf->segment_address(i) < si->lm.sys_data)
+                    si->lm.sys_data = sys_elf->segment_address(i);
+                si->lm.sys_data_size += sys_elf->segment_size(i);
+            }
+        }
+
+        if(si->lm.sys_code != SYS_CODE) {
+            db<Setup>(ERR) << "OS code segment address (" << reinterpret_cast<void *>(si->lm.sys_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_CODE) << ")!" << endl;
+            _panic();
+        }
+        if(si->lm.sys_code + si->lm.sys_code_size > si->lm.sys_data) {
+            db<Setup>(ERR) << "OS code segment is too large!" << endl;
+            _panic();
+        }
+        if(si->lm.sys_data_size > 0x100000) {
+            db<Setup>(ERR) << "OS data segment is larger than 1Mb!" << endl;
+            _panic();
+        }
+        if(si->lm.sys_data != SYS_DATA) {
+            db<Setup>(ERR) << "OS data segment address (" << reinterpret_cast<void *>(si->lm.sys_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(SYS_DATA) << ")!" << endl;
+            _panic();
+        }
+    }
+
+    // Check APPLICATION integrity and get the size of its segments
+    for(unsigned i=0; i < si->bm.n_apps; i++){
+        si->lm.app[i].app_entry = 0;
+        si->lm.app[i].app_segments = 0;
+        si->lm.app[i].app_code = ~0U;
+        si->lm.app[i].app_code_size = 0;
+        si->lm.app[i].app_data = ~0U;
+        si->lm.app[i].app_data_size = 0;
+        if(si->lm.has_app) {
+            ELF * app_elf = reinterpret_cast<ELF *>(&bi[si->bm.application_offset[i]]);
+            if(!app_elf->valid()) {
+                db<Setup>(ERR) << "Application ELF image is corrupted!" << endl;
+                _panic();
+            }
+            si->lm.app[i].app_entry = app_elf->entry();
+            si->lm.app[i].app_segments = app_elf->segments();
+            si->lm.app[i].app_code = app_elf->segment_address(0);
+            si->lm.app[i].app_code_size = app_elf->segment_size(0);
+            if(app_elf->segments() > 1) {
+                for(int j = 1; j < app_elf->segments(); j++) {
+                    if(app_elf->segment_type(j) != PT_LOAD) {
+                        continue;
+                    }
+                    if(app_elf->segment_address(j) < si->lm.app[i].app_data)
+                        si->lm.app[i].app_data = app_elf->segment_address(j);
+                    si->lm.app[i].app_data_size += app_elf->segment_size(j);
+                }
+            }
+            if(si->lm.app[i].app_code != APP_CODE) {
+                db<Setup>(ERR) << "App code segment address (" << reinterpret_cast<void *>(si->lm.app[i].app_code) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(APP_CODE) << ")!" << endl;
+                _panic();
+            }
+            if(si->lm.app[i].app_code + si->lm.app[i].app_code_size > si->lm.app[i].app_data) {
+                db<Setup>(ERR) << "App code segment is too large!" << endl;
+                _panic();
+            }
+            if(si->lm.app[i].app_data != APP_DATA) {
+                db<Setup>(ERR) << "App data segment address (" << reinterpret_cast<void *>(si->lm.app[i].app_data) << ") does not match the machine's memory map (" << reinterpret_cast<void *>(APP_DATA) << ")!" << endl;
+                _panic();
+            }
+        }
+    }
+}
+
+void Setup_SifiveE::build_page_tables()
+{
+    db<Setup>(TRC) << "build_page_tables()" << endl;
+    // Address of the Directory
+    Reg page_tables = PAGE_TABLES;
+    MMU::_master = new ( (void *) page_tables ) Page_Directory();
+
+    // Number of kernel entries in each directory
+    unsigned sys_entries = 512 + MMU::page_tables(MMU::pages(Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE));
+
+    MMU::_master->remap(page_tables + 4096, RV32_Flags::VALID, 0, sys_entries);
+
+    // Map logical addrs back to themselves; with this, the kernel may access any
+    // physical RAM address directly (as if paging wasn't there)
+    for(unsigned i = 0; i < sys_entries; i++)
+    {
+        Page_Table * pt = new ( (void *)(page_tables + 4*1024*(i+1)) ) Page_Table();
+        pt->remap(i * 1024*4096, RV32_Flags::SYS);
+    }
+}
+
+extern "C" char __bss_start;
+extern "C" char _end;
+extern "C" char _edata;
+
+void Setup_SifiveE::clean_bss()
+{
+    db<Setup>(TRC) << "clean_bss()" << endl;
+    unsigned * bss_start = reinterpret_cast<unsigned *>(&__bss_start);
+    unsigned * bss_end = reinterpret_cast<unsigned *>(&_end);
+    unsigned * edata = reinterpret_cast<unsigned *>(&_edata);
+    
+    db<Setup>(TRC) << "bss_start=" << bss_start << ", bss_end=" << bss_end << ", data_end=" << edata << endl;
+    for (unsigned * word = bss_start; word < bss_end; word++) {
+        unsigned * t = new (word) unsigned;
+        *t = 0;
+    }
+}
+
+void Setup_SifiveE::setup_supervisor_environment()
+{
+    Display::init();
+    db<Setup>(TRC) << "setup_supervisor_environment()" << endl;
+    
+    // We must clean the bss before setting MMU::_master
+    clean_bss();
+
+    //!NOTE: We are not calling the global ctors of Setup; Display::init() is called manually
+    // The last time we've checked, the ctors were the following:
+    // 0x80001718 _print (why is this even here?)
+    // 0x80001740 EPOS::S::Serial_Display::_engine
+    // 0x80001894 EPOS::S::MMU::_free
+
+    // This creates and configures the kernel page tables (which map logical==physical)
+    build_page_tables();
+
+    si = reinterpret_cast<System_Info*>(placeholder);
+    build_lm();
+    load_parts();
+
+    // forward everything
+    CPU::satp((0x1 << 31) | (PAGE_TABLES >> 12));
+    db<Setup>(TRC) << "PAGE_TABLES >> 12 = " << hex << (PAGE_TABLES >> 12) << endl;
+    
+    CPU::sepc_write(si->lm.ini_entry);
+
+    // Interrupts will remain disable until the Context::load at Init_First
+    CPU::sstatus_write(CPU::SPP_S);
+    CPU::sie_write(CPU::SSI | CPU::STI | CPU::SEI);
+
+    ASM("sret");
+}
+
+void Setup_SifiveE::setup_machine_environment()
+{
+    // We first configure the M-mode CSRs and then switch to S-mode
+    // configure paging. After that, we won't return to M-mode; an exception
+    // is the forwarding of ints and excps to S-mode.
+    CPU::mie_write(CPU::MSI | CPU::MTI | CPU::MEI);
+    CPU::mmode_int_disable();
+
+    // We need to set:
+    //      MPP_S: to switch to S-mode after mret
+    //      MPIE:  otherwise we won't ever receive interrupts
+    CPU::mstatus_write(CPU::MPP_S | CPU::MPIE);
+
+    // We store mhartid at tp, since it becomes inaccessible while in S-mode.
+    Reg core = CPU::mhartid();
+    CPU::tp(core);
+
+    // Set stack for each core
+    CPU::sp(Traits<Machine>::BOOT_STACK - Traits<Machine>::STACK_SIZE * core);
+
+    // Guarantee that paging is off before going to S-mode.
+    CPU::satp(0);
+
+    // Forward all ints and excs to S-mode.
+    CPU::mideleg_write(CPU::SSI | CPU::STI | CPU::SEI);
+    CPU::medeleg_write(0xffff);
+
+    // Relocate _mmode_forward - 1024 bytes are enough
+    char * src = reinterpret_cast<char *>(&_mmode_forward);
+    char * dst = reinterpret_cast<char *>(MMODE_F);
+    for(int i=0; i < 1024; i++){
+        *dst = *src;
+        src++;
+        dst++;
+    }
+    
+    // All ints received in M-mode are forwarded to S-mode.
+    // The first two bits indicate the mode: Direct or Vectored;
+    // we opted for Direct.
+    CPU::mtvec(MMODE_F & 0xfffffffc);
+    CPU::mepc((unsigned)&setup_supervisor_environment);
+
+    ASM("mret");
+}
+
+__END_SYS
+
+void _setup() { Setup_SifiveE::init(); }
diff --git a/src/system/application_binding.cc b/src/system/application_binding.cc
new file mode 100644
index 0000000..6ad0a5d
--- /dev/null
+++ b/src/system/application_binding.cc
@@ -0,0 +1,42 @@
+// EPOS Application Binding
+
+#include <utility/spin.h>
+#include <utility/ostream.h>
+#include <architecture/cpu.h>
+#include <system.h>
+#include <framework/main.h>
+
+// Framework class attributes
+__BEGIN_SYS
+Framework::Cache Framework::_cache;
+__END_SYS
+
+
+// Global objects
+__BEGIN_SYS
+OStream kerr;
+__END_SYS
+
+
+// Bindings
+extern "C" {
+    void _panic() { _API::Thread::exit(-1); }
+    void _exit(int s) { _API::Thread::exit(s); for(;;); }
+
+    // Utility methods that differ from kernel and user space.
+    // Heap
+    static _UTIL::Simple_Spin _heap_spin;
+    void _heap_lock() { _heap_spin.acquire(); }
+    void _heap_unlock() { _heap_spin.release();}
+}
+
+__USING_SYS;
+extern "C" {
+    void _syscall(void * m) { CPU::syscall(m); }
+    void _print(const char * s) {
+        Message msg(Id(UTILITY_ID, 0), Message::PRINT, reinterpret_cast<unsigned int>(s));
+        msg.act();
+    }
+    void _print_preamble() {}
+    void _print_trailler(bool error) {}
+}
diff --git a/src/system/kernel_binding.cc b/src/system/kernel_binding.cc
new file mode 100644
index 0000000..d46df3b
--- /dev/null
+++ b/src/system/kernel_binding.cc
@@ -0,0 +1,30 @@
+// EPOS Kernel Binding
+
+#include <framework/main.h>
+#include <framework/agent.h>
+
+// Framework class attributes
+__BEGIN_SYS
+
+// IPC::Observed IPC::_observed;
+
+Agent::Member Agent::_handlers[] = {&Agent::handle_thread,
+                                    &Agent::handle_display,
+                                    // &Agent::handle_task,
+                                    // &Agent::handle_active,
+                                    // &Agent::handle_address_space,
+                                    // &Agent::handle_segment,
+                                    &Agent::handle_mutex,
+                                    &Agent::handle_semaphore,
+                                    &Agent::handle_condition,
+                                    &Agent::handle_clock,
+                                    &Agent::handle_alarm,
+                                    &Agent::handle_chronometer,
+                                    // &Agent::handle_ipc,
+                                    &Agent::handle_utility
+};
+
+__END_SYS
+
+__USING_SYS;
+extern "C" { void _exec(void * m) { reinterpret_cast<Agent *>(m)->exec(); } }
diff --git a/src/system/system_scaffold.cc b/src/system/system_scaffold.cc
index cfb0d35..95f1ce4 100644
--- a/src/system/system_scaffold.cc
+++ b/src/system/system_scaffold.cc
@@ -15,7 +15,7 @@ class First_Object
 {
 public:
     First_Object() {
-        Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
+        // Machine::pre_init(reinterpret_cast<System_Info *>(Memory_Map::SYS_INFO));
     }
 };
 
diff --git a/tests/active_test/active_test.cc b/tests/active_test/active_test.cc
new file mode 100644
index 0000000..a7bd4cc
--- /dev/null
+++ b/tests/active_test/active_test.cc
@@ -0,0 +1,63 @@
+// EPOS Active Object Component Test Program
+
+#include <process.h>
+
+using namespace EPOS;
+
+const int iterations = 100;
+
+OStream cout;
+
+class A: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "a";
+            cout << endl;
+        }
+
+        return 'A';
+    }
+};
+
+class B: public Active
+{
+public:
+    int run() {
+        for(int i = iterations; i > 0; i--) {
+            for(int i = 0; i < 79; i++)
+        	cout << "b";
+            cout << endl;
+        }
+
+        return 'B';
+    }
+};
+
+int main()
+{
+    cout << "Active Object Test" << endl;
+
+    A * a = new A;
+    B * b = new B;
+
+    a->start();
+    b->start();
+
+    cout << "Both threads are now done and have suspended themselves. I'll now wake them up so they can exit ..." << endl;
+
+    int status_a = a->join();
+    int status_b = b->join();
+
+    cout << "Thread A exited with status " << status_a
+ 	 << " and thread B exited with status " << status_b << endl;
+
+    delete a;
+    delete b;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
diff --git a/tests/active_test/active_test_traits.h b/tests/active_test/active_test_traits.h
new file mode 100644
index 0000000..4642f73
--- /dev/null
+++ b/tests/active_test/active_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = IA32;
+    static const unsigned int MACHINE = PC;
+    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 1000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/active_test/makefile b/tests/active_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/active_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/alarm_test/alarm_test_traits.h b/tests/alarm_test/alarm_test_traits.h
index 609d140..0f9a2d0 100644
--- a/tests/alarm_test/alarm_test_traits.h
+++ b/tests/alarm_test/alarm_test_traits.h
@@ -10,9 +10,9 @@ template<> struct Traits<Build>: public Traits_Tokens
 {
     // Basic configuration
     static const unsigned int MODE = LIBRARY;
-    static const unsigned int ARCHITECTURE = IA32;
-    static const unsigned int MACHINE = PC;
-    static const unsigned int MODEL = Legacy_PC;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
     static const unsigned int CPUS = 1;
     static const unsigned int NODES = 1; // (> 1 => NETWORKING)
     static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
@@ -129,7 +129,7 @@ template<> struct Traits<Thread>: public Traits<Build>
     static const bool trace_idle = hysterically_debugged;
     static const bool simulate_capacity = false;
 
-    static const bool preemptive = true;
+    typedef RR Criterion;
     static const unsigned int QUANTUM = 10000; // us
 };
 
diff --git a/tests/scheduler_dm_test/makefile b/tests/scheduler_dm_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_dm_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_dm_test/scheduler_dm_test.cc b/tests/scheduler_dm_test/scheduler_dm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_dm_test/scheduler_dm_test_traits.h b/tests/scheduler_dm_test/scheduler_dm_test_traits.h
new file mode 100644
index 0000000..9479846
--- /dev/null
+++ b/tests/scheduler_dm_test/scheduler_dm_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef DM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/scheduler_edf_test/makefile b/tests/scheduler_edf_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_edf_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_edf_test/scheduler_edf_test.cc b/tests/scheduler_edf_test/scheduler_edf_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_edf_test/scheduler_edf_test_traits.h b/tests/scheduler_edf_test/scheduler_edf_test_traits.h
new file mode 100644
index 0000000..186aaa6
--- /dev/null
+++ b/tests/scheduler_edf_test/scheduler_edf_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef EDF Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/scheduler_rm_test/makefile b/tests/scheduler_rm_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/scheduler_rm_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/scheduler_rm_test/scheduler_rm_test.cc b/tests/scheduler_rm_test/scheduler_rm_test.cc
new file mode 100644
index 0000000..56fd387
--- /dev/null
+++ b/tests/scheduler_rm_test/scheduler_rm_test.cc
@@ -0,0 +1,129 @@
+// EPOS Periodic Thread Component Test Program
+
+#include <time.h>
+#include <real-time.h>
+
+using namespace EPOS;
+
+const unsigned int iterations = 100;
+const unsigned int period_a = 100; // ms
+const unsigned int period_b = 80; // ms
+const unsigned int period_c = 60; // ms
+const unsigned int wcet_a = 50; // ms
+const unsigned int wcet_b = 20; // ms
+const unsigned int wcet_c = 10; // ms
+
+int func_a();
+int func_b();
+int func_c();
+long max(unsigned int a, unsigned int b, unsigned int c) { return ((a >= b) && (a >= c)) ? a : ((b >= a) && (b >= c) ? b : c); }
+
+OStream cout;
+Chronometer chrono;
+Periodic_Thread * thread_a;
+Periodic_Thread * thread_b;
+Periodic_Thread * thread_c;
+
+inline void exec(char c, unsigned int time = 0) // in miliseconds
+{
+    // Delay was not used here to prevent scheduling interference due to blocking
+    Microsecond elapsed = chrono.read() / 1000;
+
+    cout << "\n" << elapsed << "\t" << c
+         << "\t[p(A)=" << thread_a->priority()
+         << ", p(B)=" << thread_b->priority()
+         << ", p(C)=" << thread_c->priority() << "]";
+
+    if(time) {
+        for(Microsecond end = elapsed + time, last = end; end > elapsed; elapsed = chrono.read() / 1000)
+            if(last != elapsed) {
+                cout << "\n" << elapsed << "\t" << c
+                    << "\t[p(A)=" << thread_a->priority()
+                    << ", p(B)=" << thread_b->priority()
+                    << ", p(C)=" << thread_c->priority() << "]";
+                last = elapsed;
+            }
+    }
+}
+
+
+int main()
+{
+    cout << "Periodic Thread Component Test" << endl;
+
+    cout << "\nThis test consists in creating three periodic threads as follows:" << endl;
+    cout << "- Every " << period_a << "ms, thread A execs \"a\", waits for " << wcet_a << "ms and then execs another \"a\";" << endl;
+    cout << "- Every " << period_b << "ms, thread B execs \"b\", waits for " << wcet_b << "ms and then execs another \"b\";" << endl;
+    cout << "- Every " << period_c << "ms, thread C execs \"c\", waits for " << wcet_c << "ms and then execs another \"c\";" << endl;
+
+    cout << "Threads will now be created and I'll wait for them to finish..." << endl;
+
+    // p,d,c,act,t
+    thread_a = new Periodic_Thread(RTConf(period_a * 1000, 0, 0, 0, iterations), &func_a);
+    thread_b = new Periodic_Thread(RTConf(period_b * 1000, 0, 0, 0, iterations), &func_b);
+    thread_c = new Periodic_Thread(RTConf(period_c * 1000, 0, 0, 0, iterations), &func_c);
+
+    exec('M');
+
+    chrono.start();
+
+    int status_a = thread_a->join();
+    int status_b = thread_b->join();
+    int status_c = thread_c->join();
+
+    chrono.stop();
+
+    exec('M');
+
+    cout << "\n... done!" << endl;
+    cout << "\n\nThread A exited with status \"" << char(status_a)
+         << "\", thread B exited with status \"" << char(status_b)
+         << "\" and thread C exited with status \"" << char(status_c) << "." << endl;
+
+    cout << "\nThe estimated time to run the test was "
+         << max(period_a, period_b, period_c) * iterations
+         << " ms. The measured time was " << chrono.read() / 1000 <<" ms!" << endl;
+
+    cout << "I'm also done, bye!" << endl;
+
+    return 0;
+}
+
+int func_a()
+{
+    exec('A');
+
+    do {
+        exec('a', wcet_a);
+    } while (Periodic_Thread::wait_next());
+
+    exec('A');
+
+    return 'A';
+}
+
+int func_b()
+{
+    exec('B');
+
+    do {
+        exec('b', wcet_b);
+    } while (Periodic_Thread::wait_next());
+
+    exec('B');
+
+    return 'B';
+}
+
+int func_c()
+{
+    exec('C');
+
+    do {
+        exec('c', wcet_c);
+    } while (Periodic_Thread::wait_next());
+
+    exec('C');
+
+    return 'C';
+}
diff --git a/tests/scheduler_rm_test/scheduler_rm_test_traits.h b/tests/scheduler_rm_test/scheduler_rm_test_traits.h
new file mode 100644
index 0000000..47e23e5
--- /dev/null
+++ b/tests/scheduler_rm_test/scheduler_rm_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = true;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RM Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tests/segment_test/makefile b/tests/segment_test/makefile
new file mode 100644
index 0000000..8a6578a
--- /dev/null
+++ b/tests/segment_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/tests/segment_test/segment_test.cc b/tests/segment_test/segment_test.cc
new file mode 100644
index 0000000..67c0759
--- /dev/null
+++ b/tests/segment_test/segment_test.cc
@@ -0,0 +1,50 @@
+// EPOS Segment Test Program
+
+#include <memory.h>
+
+using namespace EPOS;
+
+const unsigned ES1_SIZE = 10000;
+const unsigned ES2_SIZE = 100000;
+
+int main()
+{
+    OStream cout;
+
+    cout << "Segment test" << endl;
+
+    cout << "My address space's page directory is located at "
+         << reinterpret_cast<void *>(CPU::pdp()) << "" << endl;
+    Address_Space self(MMU::current());
+
+    cout << "Creating two extra data segments:" << endl;
+    Segment * es1 = new (SYSTEM) Segment(ES1_SIZE);
+    Segment * es2 = new (SYSTEM) Segment(ES2_SIZE);
+    cout << "  extra segment 1 => " << ES1_SIZE << " bytes, done!" << endl;
+    cout << "  extra segment 2 => " << ES2_SIZE << " bytes, done!" << endl;
+
+    cout << "Attaching segments:" << endl;
+    CPU::Log_Addr * extra1 = self.attach(es1);
+    CPU::Log_Addr * extra2 = self.attach(es2);
+    cout << "  extra segment 1 => " << extra1 << " done!" << endl;
+    cout << "  extra segment 2 => " << extra2 << " done!" << endl;
+
+    cout << "Clearing segments:";
+    memset(extra1, 0, ES1_SIZE);
+    memset(extra2, 0, ES2_SIZE);
+    cout << "  done!" << endl;
+
+    cout << "Detaching segments:";
+    self.detach(es1);
+    self.detach(es2);
+    cout << "  done!" << endl;
+
+    cout << "Deleting segments:";
+    delete es1;
+    delete es2;
+    cout << "  done!" << endl;
+
+    cout << "I'm done, bye!" << endl;
+
+    return 0;
+}
diff --git a/tests/segment_test/segment_test_traits.h b/tests/segment_test/segment_test_traits.h
new file mode 100644
index 0000000..d1ca6d5
--- /dev/null
+++ b/tests/segment_test/segment_test_traits.h
@@ -0,0 +1,154 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV32;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_E;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Build>::CPUS > 1) || (Traits<Application>::MAX_THREADS > 1);
+    static const bool multitask = (mode != Traits<Build>::LIBRARY);
+    static const bool multicore = (Traits<Build>::CPUS > 1) && multithread;
+    static const bool multiheap = multitask || Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Task>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multitask;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool smp = Traits<System>::multicore;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool simulate_capacity = false;
+
+    typedef RR Criterion;
+    static const unsigned int QUANTUM = 10000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+
+__END_SYS
+
+#endif
diff --git a/tools/eposcc/eposcc b/tools/eposcc/eposcc
index dbe3578..1e87316 100644
--- a/tools/eposcc/eposcc
+++ b/tools/eposcc/eposcc
@@ -45,26 +45,26 @@ C_LINK_OBJS=
 C_LINK_LIBS=
 
 CPP_COMPILER="$TOOLS_PREFIX""g++"
-CPP_COMP_FLGS="--no-exceptions --no-rtti --no-use-cxa-atexit -std=c++14"
+CPP_COMP_FLGS="$MACH_CC_FLAGS"
 CPP_COMP_HDRS=
 CPP_LINK_FLGS="$MACH_LD_FLAGS"
 CPP_LINK_OBJS=
 CPP_LINK_LIBS=
 
-F77_COMPILER="$TOOLS_PREFIX""g77"
-F77_COMP_FLGS=
-F77_COMP_HDRS=
-F77_LINK_FLGS="$MACH_LD_FLAGS"
-F77_LINK_OBJS=
-F77_LINK_LIBS="f2c"
+# F77_COMPILER="$TOOLS_PREFIX""g77"
+# F77_COMP_FLGS=
+# F77_COMP_HDRS=
+# F77_LINK_FLGS="$MACH_LD_FLAGS"
+# F77_LINK_OBJS=
+# F77_LINK_LIBS="f2c"
 
 LINKER="$TOOLS_PREFIX""ld"
 
 LINKER_LIBRARY=$LINKER
 LINK_FLGS_LIBRARY="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE"
-if [ "$MACH_DATA_NAME" != "" ] ; then
-    LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=$APP_DATA"
-fi
+# if [ "$MACH_DATA_NAME" != "" ] ; then
+#     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --section-start $MACH_DATA_NAME=0x86000000"
+# fi
 if [ "$BOOT_STACK" != "" ] ; then
     LINK_FLGS_LIBRARY="$LINK_FLGS_LIBRARY --defsym=__boot_stack__=$BOOT_STACK"
 fi
@@ -79,8 +79,8 @@ fi
 LINKER_BUILTIN=$LINKER
 LINK_FLGS_BUILTIN="-L$LIB -L`$C_COMPILER $C_COMP_FLGS -print-file-name=` -static --section-start $MACH_CODE_NAME=$APP_CODE --section-start $MACH_DATA_NAME=$APP_DATA"
 LINK_OBJI_BUILTIN="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
-LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o -R$SRC/system/system_$MMOD"
-LINK_OBJL_BUILTIN="$LIB/crtend_$MMOD.o"
+LINK_OBJN_BUILTIN="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o $LIB/crtend_$MMOD.o -R$SRC/system/system_$MMOD"
+# LINK_OBJL_BUILTIN=
 LINK_LIBS_BUILTIN="util_$MMOD gcc"
 if [ "$SETUP" = "" ] ; then
 LINK_OBJN_BUILTIN="$LIB/setup_$MMOD.o $LINK_OBJN_BUILTIN"
@@ -92,6 +92,8 @@ LINK_OBJI_KERNEL="$LIB/crt0_$MMOD.o $LIB/crtbegin_$MMOD.o"
 LINK_OBJN_KERNEL="$LIB/application_$MMOD.o $LIB/init_application_$MMOD.o"
 LINK_OBJL_KERNEL="$LIB/crtend_$MMOD.o"
 LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD gcc"
+# LINK_LIBS_KERNEL="util_$MMOD arch_$MMOD mach_$MMOD gcc"
+
 
 #=========================================================================
 # VARIABLES
@@ -271,6 +273,7 @@ done
 #=========================================================================
 # COMMAND ISSUING
 #=========================================================================
+
 if [ "$language" = "F77" ] ; then
     compiler=$F77_COMPILER
     compile_flgs="$compile_flgs $F77_COMP_FLGS"
@@ -347,51 +350,54 @@ if [ $need_compile = 1 -a ! -f "$key_file" ] ; then
 fi
 
 # disabled for EPOS
-if [ $need_analyze = 5 ] ; then
-    analyze_flgs=$compile_flgs
+# if [ $need_analyze = 5 ] ; then
+#     analyze_flgs=$compile_flgs
 
-    if [ $has_dash_c = 0 ] ; then
-        analyze_flgs="-c $analyze_flgs"
-    fi
-    tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
-    analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
-    analyze_flgs="$analyze_flgs -o $tmp_file.o"
-    $do_echo $compiler $analyze_flgs $analyze_args $input_file
-    $do_exec $compiler $analyze_flgs $analyze_args $input_file
-    status=$?
-    if [ $status != 0 ] ; then
-        $do_echo rm -f "$tmp_file.*"
-        $do_exec rm -f "$tmp_file.*"
-        exit $status
-    fi
+#     if [ $has_dash_c = 0 ] ; then
+#         analyze_flgs="-c $analyze_flgs"
+#     fi
+#     tmp_file="$TMP/epos`date +%Y%m%d%H%M%S`"
+#     analyze_flgs="$analyze_flgs $ANL_COMP_FLGS"
+#     analyze_flgs="$analyze_flgs -o $tmp_file.o"
+#     $do_echo $compiler $analyze_flgs $analyze_args $input_file
+#     $do_exec $compiler $analyze_flgs $analyze_args $input_file
+#     status=$?
+#     if [ $status != 0 ] ; then
+#         $do_echo rm -f "$tmp_file.*"
+#         $do_exec rm -f "$tmp_file.*"
+#         exit $status
+#     fi
 
-    $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
-    $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
-    status=$?
-    if [ $status != 0 ] ; then
-        $do_echo rm -f "$tmp_file.*"
-        $do_exec rm -f "$tmp_file.*"
-        exit $status
-    fi
+#     $do_echo $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+#     $do_exec $ANALYZER $ANL_FLAGS "$tmp_file.o" -o "$tmp_file.anl"
+#     status=$?
+#     if [ $status != 0 ] ; then
+#         $do_echo rm -f "$tmp_file.*"
+#         $do_exec rm -f "$tmp_file.*"
+#         exit $status
+#     fi
 
-    if [ $only_analyze = 1 -a -n "$output_file" ] ; then
-        configurator_output_file=$output_file
-    else
-        configurator_output_file=$key_file
-    fi
-    $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
-    $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+#     if [ $only_analyze = 1 -a -n "$output_file" ] ; then
+#         configurator_output_file=$output_file
+#     else
+#         configurator_output_file=$key_file
+#     fi
+#     $do_echo $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
+#     $do_exec $CONFIGURATOR "$tmp_file.anl" -o $configurator_output_file
 
-    status=$?
-    $do_echo rm -f "$tmp_file.*"
-    $do_exec rm -f "$tmp_file.*"
+#     status=$?
+#     $do_echo rm -f "$tmp_file.*"
+#     $do_exec rm -f "$tmp_file.*"
 
-    if [ $only_analyze = 1 ] ; then
-        exit $status
-    fi
-fi
+#     if [ $only_analyze = 1 ] ; then
+#         exit $status
+#     fi
+# fi
 
 if [ $need_compile = 1 ] ; then
+    # echo $has_dash_c
+    # echo $language
+    # echo $compile_flgs
     if [ $has_dash_c = 0 ] ; then
         compile_flgs="-c $compile_flgs"
     fi
@@ -412,7 +418,7 @@ if [ $need_link = 1 ] ; then
         link_flgs="$link_flgs -o $output_file"
     fi
     $do_echo "$linker $link_flgs $link_objs $link_args $link_libs"
-    $do_exec $linker $link_flgs $link_objs $link_args $link_libs
+    $do_exec $linker --trace $link_flgs $link_objs $link_args $link_libs
     status=$?
 fi
 
diff --git a/tools/eposcfg/eposcfg.cc b/tools/eposcfg/eposcfg.cc
index 51b0f64..b0f48d5 100644
--- a/tools/eposcfg/eposcfg.cc
+++ b/tools/eposcfg/eposcfg.cc
@@ -10,6 +10,7 @@
 
 // Traits are included in config.h
 #include <system/config.h>
+#include <system/memory_map.h>
 
 // Using only bare C to avoid conflicts with EPOS
 #include <stdio.h>
@@ -21,7 +22,7 @@ using namespace EPOS::S;
 using namespace EPOS::S::U;
 
 // Constants
-const unsigned int TOKENS = 24;
+const unsigned int TOKENS = 32;
 const unsigned int COMPONENTS = 62;
 const unsigned int STRING_SIZE = 128;
 
@@ -40,14 +41,22 @@ char tokens[TOKENS][STRING_SIZE] = {
     "MEM_TOP",
     "MEM_SIZE",
     "MEM_SIZE_KB",
+    "MIO_BASE",
+    "MIO_TOP",
+    "MMODE_F",
+    "MIO_SIZE",
+    "MIO_SIZE_KB",
     "BOOT_STACK",
     "BOOT",
+    "IMAGE",
     "SETUP",
     "INIT",
     "APP_CODE",
     "APP_DATA",
     "SYS_CODE",
     "SYS_DATA",
+    "SYS_STACK",
+    "SYS_HEAP",
     "BOOT_LENGTH_MIN",
     "BOOT_LENGTH_MAX",
     "EXPECTED_SIMULATION_TIME"
@@ -192,66 +201,99 @@ void populate_strings()
     snprintf(string, STRING_SIZE, "%i", Traits<CPU>::WORD_SIZE);
     set_token_value("WORD_SIZE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_BASE);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_BASE);
     set_token_value("MEM_BASE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP);
     set_token_value("MEM_TOP", string);
+    
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MMODE_F);
+    set_token_value("MMODE_F", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE);
     set_token_value("MEM_SIZE", string);
 
-    snprintf(string, STRING_SIZE, "0x%08x", (Traits<Machine>::MEM_TOP + 1 - Traits<Machine>::MEM_BASE) / 1024);
+    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MEM_TOP + 1 - Memory_Map::MEM_BASE) / 1024);
     set_token_value("MEM_SIZE_KB", string);
 
-    if(Traits<Machine>::BOOT_STACK != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT_STACK);
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_BASE);
+    set_token_value("MIO_BASE", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP);
+    set_token_value("MIO_TOP", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE);
+    set_token_value("MIO_SIZE", string);
+
+    snprintf(string, STRING_SIZE, "0x%08x", (Memory_Map::MIO_TOP + 1 - Memory_Map::MIO_BASE) / 1024);
+    set_token_value("MIO_SIZE_KB", string);
+
+    if(Memory_Map::BOOT_STACK != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT_STACK);
     else
         string[0] = '\0';
     set_token_value("BOOT_STACK", string);
 
-    if(Traits<Machine>::BOOT != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::BOOT);
+    if(Memory_Map::BOOT != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::BOOT);
     else
         string[0] = '\0';
     set_token_value("BOOT", string);
 
-    if(Traits<Machine>::SETUP != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SETUP);
+    if(Memory_Map::IMAGE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::IMAGE);
+    else
+        string[0] = '\0';
+    set_token_value("IMAGE", string);
+
+    if(Memory_Map::SETUP != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SETUP);
     else
         string[0] = '\0';
     set_token_value("SETUP", string);
 
-    if(Traits<Machine>::INIT != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::INIT);
+    if(Memory_Map::INIT != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::INIT);
     else
         string[0] = '\0';
     set_token_value("INIT", string);
 
-    if(Traits<Machine>::APP_CODE != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_CODE);
+    if(Memory_Map::APP_CODE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_CODE);
     else
         string[0] = '\0';
     set_token_value("APP_CODE", string);
 
-    if(Traits<Machine>::APP_DATA != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::APP_DATA);
+    if(Memory_Map::APP_DATA != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::APP_DATA);
     else
         string[0] = '\0';
     set_token_value("APP_DATA", string);
 
-    if(Traits<Machine>::SYS_CODE != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_CODE);
+    if(Memory_Map::SYS_CODE != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_CODE);
     else
         string[0] = '\0';
     set_token_value("SYS_CODE", string);
 
-    if(Traits<Machine>::SYS_DATA != Traits<Machine>::NOT_USED)
-        snprintf(string, STRING_SIZE, "0x%08x", Traits<Machine>::SYS_DATA);
+    if(Memory_Map::SYS_DATA != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_DATA);
     else
         string[0] = '\0';
     set_token_value("SYS_DATA", string);
 
+    if(Memory_Map::SYS_STACK != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_STACK);
+    else
+        string[0] = '\0';
+    set_token_value("SYS_STACK", string);
+
+    if(Memory_Map::SYS_HEAP != Memory_Map::NOT_USED)
+        snprintf(string, STRING_SIZE, "0x%08x", Memory_Map::SYS_HEAP);
+    else
+        string[0] = '\0';
+    set_token_value("SYS_HEAP", string);
+
     if(Traits<Machine>::BOOT_LENGTH_MIN != Traits<Machine>::NOT_USED)
         snprintf(string, STRING_SIZE, "%i", Traits<Machine>::BOOT_LENGTH_MIN);
     else
diff --git a/tools/eposctors/eposctors b/tools/eposctors/eposctors
index c54f943..d0e99b2 100755
--- a/tools/eposctors/eposctors
+++ b/tools/eposctors/eposctors
@@ -6,14 +6,16 @@
 ELF=$1
 GDB=$2
 
-INIT_ARRAY_OFFSET=`objdump -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
-INIT_ARRAY_SIZE=`objdump -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
-FINI_ARRAY_OFFSET=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
-FINI_ARRAY_SIZE=`objdump -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
+OBJDUMP=/usr/local/rv32/bin/riscv32-unknown-linux-gnu-objdump
+INIT_ARRAY_OFFSET=`$OBJDUMP -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
+INIT_ARRAY_SIZE=`$OBJDUMP -h $ELF|grep "\.init_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
+FINI_ARRAY_OFFSET=`$OBJDUMP -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f7`
+FINI_ARRAY_SIZE=`$OBJDUMP -h $ELF|grep "\.fini_array"|sed -e "s/  */#/g"|cut -d '#' -f4`
 
 echo "CTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n 0x$INIT_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    dec=`printf "%d" 0x$INIT_ARRAY_SIZE`
+    LIST=`hexdump -s 0x$INIT_ARRAY_OFFSET -n $dec -v -e '1/4 "%08x\n"' $ELF`
     for item in $LIST; do
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_I_//g"|c++filt`
         echo 0x$item $sym
@@ -25,7 +27,8 @@ fi
 echo
 echo "DTOR_LIST:"
 if [ "$GDB" = "" ] ; then
-    LIST=`hexdump -s 0x$FINI_ARRAY_OFFSET -n 0x$FINI_ARRAY_SIZE -v -e '1/4 "%08x\n"' $ELF`
+    dec=`printf "%d" 0x$FINI_ARRAY_SIZE`
+    LIST=`hexdump -s 0x$FINI_ARRAY_OFFSET -n $dec -v -e '1/4 "%08x\n"' $ELF`
     for item in $LIST; do
         sym=`nm $ELF|grep $item|grep GLOBAL|sed -e "s/.*_GLOBAL__sub_D_//g"|c++filt`
         echo 0x$item $sym
diff --git a/tools/eposmkbi/eposmkbi.cc b/tools/eposmkbi/eposmkbi.cc
index da82176..eb7eaa8 100644
--- a/tools/eposmkbi/eposmkbi.cc
+++ b/tools/eposmkbi/eposmkbi.cc
@@ -38,6 +38,8 @@ struct Configuration
     bool           endianess;  // true => little, false => big
     unsigned int   mem_base;
     unsigned int   mem_top;
+    unsigned int   mio_base;
+    unsigned int   mio_top;
     unsigned int   boot_length_min;
     unsigned int   boot_length_max;
     short          node_id;   // nodes in SAN (-1 => dynamic)
@@ -52,13 +54,13 @@ typedef _SYS::System_Info System_Info;
 
 // PROTOTYPES
 bool parse_config(FILE * cfg_file, Configuration * cfg);
-void strtolower (char *dst,const char* src);
+void strtolower (char * dst,const char * src);
 bool add_machine_secrets(int fd_img, unsigned int i_size, char * mach, char * mmod);
 
 bool file_exist(char *file);
 
-int put_buf(int fd_out, void *buf, int size);
-int put_file(int fd_out, char *file);
+int put_buf(int fd_out, void * buf, int size);
+int put_file(int fd_out, char * file);
 int pad(int fd_out, int size);
 bool lil_endian();
 
@@ -140,7 +142,7 @@ int main(int argc, char **argv)
     }
 
     // Open destination file (rewrite)
-    int fd_img = open(argv[optind + 1], O_WRONLY | O_CREAT | O_TRUNC, 00644);
+    int fd_img = open(argv[optind + 1], O_RDWR | O_CREAT | O_TRUNC, 00644);
     if(fd_img < 0) {
         fprintf(err, "Error: can't create boot image \"%s\"!\n", argv[optind + 1]);
         return 1;
@@ -152,7 +154,8 @@ int main(int argc, char **argv)
     fprintf(out, "  Model: %s\n", CONFIG.mmod);
     fprintf(out, "  Processor: %s (%d bits, %s-endian)\n", CONFIG.arch, CONFIG.word_size, CONFIG.endianess ? "little" : "big");
     fprintf(out, "  Memory: %d KBytes\n", (CONFIG.mem_top - CONFIG.mem_base) / 1024);
-    fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
+    if((CONFIG.boot_length_min + CONFIG.boot_length_max) > 0)
+        fprintf(out, "  Boot Length: %d - %d (min - max) KBytes\n", CONFIG.boot_length_min, CONFIG.boot_length_max);
     if(CONFIG.space_x != -1)
         fprintf(out, "  Node location: (%d, %d, %d)\n", CONFIG.space_x, CONFIG.space_y, CONFIG.space_z);
     fprintf(out, "  UUID: ");
@@ -162,7 +165,7 @@ int main(int argc, char **argv)
     // Create the boot image
     unsigned int image_size = 0;
     fprintf(out, "\n  Creating EPOS bootable image in \"%s\":\n", argv[optind + 1]);
-
+    
     // Add BOOT
     if(CONFIG.boot_length_max > 0) {
         sprintf(file, "%s/img/boot_%s", argv[optind], CONFIG.mmod);
@@ -179,38 +182,45 @@ int main(int argc, char **argv)
     }
     unsigned int boot_size = image_size;
 
+    // Determine if System_Info is needed and how it must be handled
+    bool need_si = (!strcmp(CONFIG.mach, "pc") || !strcmp(CONFIG.mach, "riscv"));
+    bool si_in_setup = (need_si && (boot_size == 0)); // If the image contains a boot sector, then SI will be on a separate disk sector. Otherwise, it will be inside SETUP.
+
     // Reserve space for System_Info if necessary
-    System_Info si;
-    bool need_si = true;
-    if(image_size == 0) {
-        need_si = false;
-    } else
-        if(sizeof(System_Info) > MAX_SI_LEN) {
+    if(need_si && !si_in_setup) {
+        if(sizeof(System_Info) <= MAX_SI_LEN) {
+            image_size += pad(fd_img, MAX_SI_LEN);
+        } else {
             fprintf(out, " failed!\n");
             fprintf(err, "System_Info structure is too large (%d)!\n", sizeof(System_Info));
             return 1;
-        } else
-            image_size += pad(fd_img, MAX_SI_LEN);
+        }
+    }
 
     // Initialize the Boot_Map in System_Info
-    si.bm.n_cpus   = CONFIG.n_cpus; // can be adjusted by SETUP in some machines
+    System_Info si;
+    si.bm.n_cpus   = CONFIG.n_cpus;     // can be adjusted by SETUP in some machines
     si.bm.mem_base = CONFIG.mem_base;
     si.bm.mem_top  = CONFIG.mem_top;
-    si.bm.io_base  = 0; // will be adjusted by SETUP
-    si.bm.io_top   = 0; // will be adjusted by SETUP
+    si.bm.mio_base = CONFIG.mio_base;   // can be adjusted by SETUP in some machines
+    si.bm.mio_top  = CONFIG.mio_top;    // can be adjusted by SETUP in some machines
     si.bm.node_id  = CONFIG.node_id;
     si.bm.space_x  = CONFIG.space_x;
     si.bm.space_y  = CONFIG.space_y;
     si.bm.space_z  = CONFIG.space_z;
+    si.bm.n_apps   = argc-3;
+
     for(unsigned int i = 0; i < 8; i++)
         si.bm.uuid[i]  = CONFIG.uuid[i];
 
     // Add SETUP
     sprintf(file, "%s/img/setup_%s", argv[optind], CONFIG.mmod);
     if(file_exist(file)) {
-        si.bm.setup_offset = image_size - boot_size;
+        // Setup is a raw binary file now; it has no Elf header to be read
+        si.bm.setup_offset = -1;
         fprintf(out, "    Adding setup \"%s\":", file);
         image_size += put_file(fd_img, file);
+        image_size += pad(fd_img, 4*4096 - (image_size % 4096));
     } else
         si.bm.setup_offset = -1;
 
@@ -233,22 +243,17 @@ int main(int argc, char **argv)
     }
 
     // Add application(s) and data
-    si.bm.application_offset = image_size - boot_size;
+    si.bm.application_offset[0] = image_size - boot_size;
     fprintf(out, "    Adding application \"%s\":", argv[optind + 2]);
     image_size += put_file(fd_img, argv[optind + 2]);
     if((argc - optind) == 3) // single APP
         si.bm.extras_offset = -1;
-    else { // multiple APPs or data
-        si.bm.extras_offset = image_size - boot_size;
-        struct stat file_stat;
-        for(int i = optind + 3; i < argc; i++) {
-            fprintf(out, "    Adding file \"%s\":", argv[i]);
-            stat(argv[i], &file_stat);
-            image_size += put_number(fd_img, file_stat.st_size);
+    else{
+        for(int i=4; i<argc; i++){
+            si.bm.application_offset[i-3] = image_size - boot_size;
+            fprintf(out, "    Adding application \"%s\":", argv[i]);
             image_size += put_file(fd_img, argv[i]);
         }
-        // Signalize last application by setting its size to 0
-        image_size += put_number(fd_img, 0);
     }
 
     // Add the size of the image to the Boot_Map in System_Info (excluding BOOT)
@@ -256,8 +261,42 @@ int main(int argc, char **argv)
 
     // Add System_Info
     if(need_si) {
-        fprintf(out, "    Adding system info:");
-        if(lseek(fd_img, boot_size, SEEK_SET) < 0) {
+        unsigned int si_offset = boot_size;
+        fprintf(out, "    Adding system info");
+        if(si_in_setup) {
+            fprintf(out, " to SETUP:");
+            struct stat stat;
+            if(fstat(fd_img, &stat) < 0)  {
+                fprintf(out, " failed! (stat)\n");
+                return 0;
+            }
+            char * buffer = (char *) malloc(stat.st_size);
+            if(!buffer) {
+                fprintf(out, " failed! (malloc)\n");
+                return 0;
+            }
+            memset(buffer, '\1', stat.st_size);
+            lseek(fd_img, 0, SEEK_SET);
+            if(read(fd_img, buffer, stat.st_size) < 0) {
+                fprintf(out, " failed! (read)\n");
+                free(buffer);
+                return 0;
+            }
+
+            char placeholder[] = "System_Info placeholder. Actual System_Info will be added by mkbi!";
+            char * setup_si = reinterpret_cast<char *>(memmem(buffer, stat.st_size, placeholder, strlen(placeholder)));
+            if(setup_si) {
+                si_offset = setup_si - buffer;
+            } else {
+                fprintf(out, " failed! (SETUP does not contain System_Info placeholder)\n");
+                free(buffer);
+                return 0;
+            }
+        } else {
+            fprintf(out, " to image:");
+            si_offset = boot_size;
+        }
+        if(lseek(fd_img, si_offset, SEEK_SET) < 0) {
             fprintf(err, "Error: can't seek the boot image!\n");
             return 1;
         }
@@ -279,7 +318,27 @@ int main(int argc, char **argv)
     }
     fprintf(out, " done.\n");
 
-    //Finish
+    fprintf(out, "\nBoot Map:");
+    fprintf(out, "\n    si.bm.n_cpus %u",       si.bm.n_cpus);
+    fprintf(out, "\n    si.bm.mem_base %08x",   si.bm.mem_base);
+    fprintf(out, "\n    si.bm.mem_top %08x",    si.bm.mem_top);
+    fprintf(out, "\n    si.bm.mio_base %08x",   si.bm.mio_base);
+    fprintf(out, "\n    si.bm.mio_top %08x",    si.bm.mio_top);
+    fprintf(out, "\n    si.bm.node_id %u",      si.bm.node_id);
+    fprintf(out, "\n    si.bm.space_x %u",      si.bm.space_x);
+    fprintf(out, "\n    si.bm.space_y %u",      si.bm.space_y);
+    fprintf(out, "\n    si.bm.space_z %u\n\n",  si.bm.space_z);
+
+    fprintf(out, "\n    si.bm.img_size %u",           si.bm.img_size);
+    fprintf(out, "\n    si.bm.setup_offset %08x",       si.bm.setup_offset);
+    fprintf(out, "\n    si.bm.init_offset %08x",        si.bm.init_offset);
+    fprintf(out, "\n    si.bm.system_offset %08x",      si.bm.system_offset);
+    for (unsigned i = 0; i < si.bm.n_apps; i++)
+        fprintf(out, "\n    si.bm.application_offset[%u] %08x", i, si.bm.application_offset[0]);
+    fprintf(out, "\n    si.bm.n_apps %u",             si.bm.n_apps);
+    fprintf(out, "\n    si.bm.extras_offset %08x",      si.bm.extras_offset);
+
+    // Finish
     close(fd_img);
     fprintf(out, "\n  Image successfully generated (%d bytes)!\n\n", image_size);
 
@@ -400,7 +459,7 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
         fprintf(err, "Error: no valid MEM_BASE in configuration!\n");
         return false;
     }
-    cfg->mem_base = strtol(token, 0, 16);
+    cfg->mem_base = strtoll(token, 0, 16);
 
     // Memory Top
     if(fgets(line, 256, cfg_file) != line) {
@@ -412,7 +471,31 @@ bool parse_config(FILE * cfg_file, Configuration * cfg)
         fprintf(err, "Error: no valid MEM_TOP in configuration!\n");
         return false;
     }
-    cfg->mem_top=strtol(token, 0, 16);
+    cfg->mem_top = strtoll(token, 0, 16);
+
+    // I/O Base
+    if(fgets(line, 256, cfg_file) != line) {
+        fprintf(err, "Error: failed to read MIO_BASE from configuration file!\n");
+        return false;
+    }
+    token = strtok(line, "=");
+    if(strcmp(token, "MIO_BASE") || !(token = strtok(NULL, "\n"))) {
+        fprintf(err, "Error: no valid MIO_BASE in configuration!\n");
+        return false;
+    }
+    cfg->mio_base = strtoll(token, 0, 16);
+
+    // I/O Top
+    if(fgets(line, 256, cfg_file) != line) {
+        fprintf(err, "Error: failed to read MIO_TOP from configuration file!\n");
+        return false;
+    }
+    token = strtok(line, "=");
+    if(strcmp(token, "MIO_TOP") || !(token = strtok(NULL, "\n"))) {
+        fprintf(err, "Error: no valid MIO_TOP in configuration!\n");
+        return false;
+    }
+    cfg->mio_top = strtoll(token, 0, 16);
 
     // Boot Length Min
     if(fgets(line, 256, cfg_file) != line)
@@ -474,9 +557,9 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
     if(!put_number(fd, static_cast<T>(si->bm.mem_top)))
         return false;
 
-    if(!put_number(fd, static_cast<T>(0))) // io_base
+    if(!put_number(fd, static_cast<T>(si->bm.mio_base)))
         return false;
-    if(!put_number(fd, static_cast<T>(0))) // io_top
+    if(!put_number(fd, static_cast<T>(si->bm.mio_top)))
         return false;
 
     if(!put_number(fd, si->bm.node_id))
@@ -499,7 +582,11 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
         return false;
     if(!put_number(fd, static_cast<T>(si->bm.system_offset)))
         return false;
-    if(!put_number(fd, static_cast<T>(si->bm.application_offset)))
+    for(int i=0; i<8; i++){
+        if(!put_number(fd, static_cast<T>(si->bm.application_offset[i])))                 
+            return false;
+    }
+    if(!put_number(fd, static_cast<T>(si->bm.n_apps)))
         return false;
     if(!put_number(fd, static_cast<T>(si->bm.extras_offset)))
         return false;
@@ -512,7 +599,7 @@ template<typename T> bool add_boot_map(int fd, System_Info * si)
 //=============================================================================
 bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
 {
-    if (!strcmp(mach, "pc")) { // PC
+    if(!strcmp(mach, "pc")) { // PC
         const unsigned int floppy_size   = 1474560;
         const unsigned int secrets_offset   = CONFIG.boot_length_min - 6;
         const unsigned short boot_id        = 0xaa55;
@@ -552,7 +639,7 @@ bool add_machine_secrets(int fd, unsigned int i_size, char * mach, char * mmod)
         char key_string[] = ":020000040027D3\r\n:0CFFD400FFFFFFEF000000000000200015\r\n:00000001FF\r\n"; // Bootloader Disabled
         const int key_offset = -strlen(":00000001FF\r\n");
 
-        // Write key string to unlock epos
+        // Write key string to unlock EPOS
         if(lseek(fd,key_offset,SEEK_END) < 0) {
             fprintf(err, "Error: can't seek the boot image!\n");
             return false;
